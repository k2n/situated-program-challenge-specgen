SCRIPT  /Users/kenji/.vim/plugged/ctrlp.vim/autoload/ctrlp/utils.vim
Sourced 1 time
Total time:   0.000208
 Self time:   0.000127

count  total (s)   self (s)
                            " =============================================================================
                            " File:          autoload/ctrlp/utils.vim
                            " Description:   Utilities
                            " Author:        Kien Nguyen <github.com/kien>
                            " =============================================================================
                            
                            " Static variables {{{1
    1              0.000005 fu! ctrlp#utils#lash()
                            	retu &ssl || !exists('+ssl') ? '/' : '\'
                            endf
                            
    1              0.000003 fu! s:lash(...)
                            	retu ( a:0 ? a:1 : getcwd() ) !~ '[\/]$' ? s:lash : ''
                            endf
                            
    1              0.000002 fu! ctrlp#utils#opts()
                            	let s:lash = ctrlp#utils#lash()
                            	let usrhome = $HOME . s:lash( $HOME )
                            	let cahome = exists('$XDG_CACHE_HOME') ? $XDG_CACHE_HOME : usrhome.'.cache'
                            	let cadir = isdirectory(usrhome.'.ctrlp_cache')
                            		\ ? usrhome.'.ctrlp_cache' : cahome.s:lash(cahome).'ctrlp'
                            	if exists('g:ctrlp_cache_dir')
                            		let cadir = expand(g:ctrlp_cache_dir, 1)
                            		if isdirectory(cadir.s:lash(cadir).'.ctrlp_cache')
                            			let cadir = cadir.s:lash(cadir).'.ctrlp_cache'
                            		en
                            	en
                            	let s:cache_dir = cadir
                            endf
    1   0.000091   0.000009 cal ctrlp#utils#opts()
                            
    1              0.000004 let s:wig_cond = v:version > 702 || ( v:version == 702 && has('patch051') )
                            " Files and Directories {{{1
    1              0.000002 fu! ctrlp#utils#cachedir()
                            	retu s:cache_dir
                            endf
                            
    1              0.000002 fu! ctrlp#utils#cachefile(...)
                            	let [tail, dir] = [a:0 == 1 ? '.'.a:1 : '', a:0 == 2 ? a:1 : getcwd()]
                            	let cache_file = substitute(dir, '\([\/]\|^\a\zs:\)', '%', 'g').tail.'.txt'
                            	retu a:0 == 1 ? cache_file : s:cache_dir.s:lash(s:cache_dir).cache_file
                            endf
                            
    1              0.000003 fu! ctrlp#utils#readfile(file)
                            	if filereadable(a:file)
                            		let data = readfile(a:file)
                            		if empty(data) || type(data) != 3
                            			unl data
                            			let data = []
                            		en
                            		retu data
                            	en
                            	retu []
                            endf
                            
    1              0.000002 fu! ctrlp#utils#mkdir(dir)
                            	if exists('*mkdir') && !isdirectory(a:dir)
                            		sil! cal mkdir(a:dir, 'p')
                            	en
                            	retu a:dir
                            endf
                            
    1              0.000002 fu! ctrlp#utils#writecache(lines, ...)
                            	if isdirectory(ctrlp#utils#mkdir(a:0 ? a:1 : s:cache_dir))
                            		sil! cal writefile(a:lines, a:0 >= 2 ? a:2 : ctrlp#utils#cachefile())
                            	en
                            endf
                            
    1              0.000002 fu! ctrlp#utils#glob(...)
                            	let path = ctrlp#utils#fnesc(a:1, 'g')
                            	retu s:wig_cond ? glob(path, a:2) : glob(path)
                            endf
                            
    1              0.000002 fu! ctrlp#utils#globpath(...)
                            	retu call('globpath', s:wig_cond ? a:000 : a:000[:1])
                            endf
                            
    1              0.000002 fu! ctrlp#utils#fnesc(path, type, ...)
                            	if exists('*fnameescape')
                            		if exists('+ssl')
                            			if a:type == 'c'
                            				let path = escape(a:path, '%#')
                            			elsei a:type == 'f'
                            				let path = fnameescape(a:path)
                            			elsei a:type == 'g'
                            				let path = escape(a:path, '?*')
                            			en
                            			let path = substitute(path, '[', '[[]', 'g')
                            		el
                            			let path = fnameescape(a:path)
                            		en
                            	el
                            		if exists('+ssl')
                            			if a:type == 'c'
                            				let path = escape(a:path, '%#')
                            			elsei a:type == 'f'
                            				let path = escape(a:path, " \t\n%#*?|<\"")
                            			elsei a:type == 'g'
                            				let path = escape(a:path, '?*')
                            			en
                            			let path = substitute(path, '[', '[[]', 'g')
                            		el
                            			let path = escape(a:path, " \t\n*?[{`$\\%#'\"|!<")
                            		en
                            	en
                            	retu a:0 ? escape(path, a:1) : path
                            endf
                            "}}}
                            
                            " vim:fen:fdm=marker:fmr={{{,}}}:fdl=0:fdc=1:ts=2:sw=2:sts=2

SCRIPT  /Users/kenji/.vim/plugged/vim-clojure-static/syntax/clojure.vim
Sourced 2 times
Total time:   0.012131
 Self time:   0.006498

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:     Clojure
                            " Authors:      Toralf Wittner <toralf.wittner@gmail.com>
                            "               modified by Meikel Brandmeyer <mb@kotka.de>
                            " URL:          http://kotka.de/projects/clojure/vimclojure.html
                            "
                            " Contributors: Joel Holdbrooks <cjholdbrooks@gmail.com> (Regexp support, bug fixes)
                            "
                            " Maintainer:   Sung Pae <self@sungpae.com>
                            " URL:          https://github.com/guns/vim-clojure-static
                            " License:      Same as Vim
                            " Last Change:  %%RELEASE_DATE%%
                            
    2              0.000027 if exists("b:current_syntax")
                            	finish
                            endif
                            
    2              0.000024 let s:cpo_sav = &cpo
    2              0.000019 set cpo&vim
                            
    2              0.000017 if has("folding") && exists("g:clojure_fold") && g:clojure_fold > 0
                            	setlocal foldmethod=syntax
                            endif
                            
                            " -*- KEYWORDS -*-
                            " Generated from https://github.com/guns/vim-clojure-static/blob/%%RELEASE_TAG%%/clj/src/vim_clojure_static/generate.clj
                            " Clojure version 1.8.0
    2              0.002883 let s:clojure_syntax_keywords = {
                                \   'clojureBoolean': ["false","true"]
                                \ , 'clojureCond': ["case","clojure.core/case","clojure.core/cond","clojure.core/cond->","clojure.core/cond->>","clojure.core/condp","clojure.core/if-let","clojure.core/if-not","clojure.core/if-some","clojure.core/when","clojure.core/when-first","clojure.core/when-let","clojure.core/when-not","clojure.core/when-some","cond","cond->","cond->>","condp","if-let","if-not","if-some","when","when-first","when-let","when-not","when-some"]
                                \ , 'clojureConstant': ["nil"]
                                \ , 'clojureDefine': ["clojure.core/definline","clojure.core/definterface","clojure.core/defmacro","clojure.core/defmethod","clojure.core/defmulti","clojure.core/defn","clojure.core/defn-","clojure.core/defonce","clojure.core/defprotocol","clojure.core/defrecord","clojure.core/defstruct","clojure.core/deftype","definline","definterface","defmacro","defmethod","defmulti","defn","defn-","defonce","defprotocol","defrecord","defstruct","deftype"]
                                \ , 'clojureException': ["catch","finally","throw","try"]
                                \ , 'clojureFunc': ["*","*'","+","+'","-","-'","->ArrayChunk","->Eduction","->Vec","->VecNode","->VecSeq","-cache-protocol-fn","-reset-methods","/","<","<=","=","==",">",">=","Throwable->map","accessor","aclone","add-classpath","add-watch","agent","agent-error","agent-errors","aget","alength","alias","all-ns","alter","alter-meta!","alter-var-root","ancestors","apply","array-map","aset","aset-boolean","aset-byte","aset-char","aset-double","aset-float","aset-int","aset-long","aset-short","assoc","assoc!","assoc-in","associative?","atom","await","await-for","await1","bases","bean","bigdec","bigint","biginteger","bit-and","bit-and-not","bit-clear","bit-flip","bit-not","bit-or","bit-set","bit-shift-left","bit-shift-right","bit-test","bit-xor","boolean","boolean-array","booleans","bound-fn*","bound?","butlast","byte","byte-array","bytes","cast","cat","char","char-array","char?","chars","chunk","chunk-append","chunk-buffer","chunk-cons","chunk-first","chunk-next","chunk-rest","chunked-seq?","class","class?","cle                                \ , 'clojureMacro': ["->","->>","..","amap","and","areduce","as->","assert","binding","bound-fn","clojure.core/->","clojure.core/->>","clojure.core/..","clojure.core/amap","clojure.core/and","clojure.core/areduce","clojure.core/as->","clojure.core/assert","clojure.core/binding","clojure.core/bound-fn","clojure.core/comment","clojure.core/declare","clojure.core/delay","clojure.core/dosync","clojure.core/doto","clojure.core/extend-protocol","clojure.core/extend-type","clojure.core/for","clojure.core/future","clojure.core/gen-class","clojure.core/gen-interface","clojure.core/import","clojure.core/io!","clojure.core/lazy-cat","clojure.core/lazy-seq","clojure.core/letfn","clojure.core/locking","clojure.core/memfn","clojure.core/ns","clojure.core/or","clojure.core/proxy","clojure.core/proxy-super","clojure.core/pvalues","clojure.core/refer-clojure","clojure.core/reify","clojure.core/some->","clojure.core/some->>","clojure.core/sync","clojure.core/time","clojure.core/vswap!","clojure.core/with-bindings","clojure                                \ , 'clojureRepeat': ["clojure.core/doseq","clojure.core/dotimes","clojure.core/while","doseq","dotimes","while"]
                                \ , 'clojureSpecial': [".","clojure.core/fn","clojure.core/let","clojure.core/loop","def","do","fn","if","let","loop","monitor-enter","monitor-exit","new","quote","recur","set!","var"]
                                \ , 'clojureVariable': ["*1","*2","*3","*agent*","*allow-unresolved-vars*","*assert*","*clojure-version*","*command-line-args*","*compile-files*","*compile-path*","*compiler-options*","*data-readers*","*default-data-reader-fn*","*e","*err*","*file*","*flush-on-newline*","*fn-loader*","*in*","*math-context*","*ns*","*out*","*print-dup*","*print-length*","*print-level*","*print-meta*","*print-readably*","*read-eval*","*source-path*","*suppress-read*","*unchecked-math*","*use-context-classloader*","*verbose-defrecords*","*warn-on-reflection*","EMPTY-NODE","char-escape-string","char-name-string","clojure.core/*1","clojure.core/*2","clojure.core/*3","clojure.core/*agent*","clojure.core/*allow-unresolved-vars*","clojure.core/*assert*","clojure.core/*clojure-version*","clojure.core/*command-line-args*","clojure.core/*compile-files*","clojure.core/*compile-path*","clojure.core/*compiler-options*","clojure.core/*data-readers*","clojure.core/*default-data-reader-fn*","clojure.core/*e","clojure.core/*err*","clojure.                                \ }
                            
    2              0.000023 function! s:syntax_keyword(dict)
                            	for key in keys(a:dict)
                            		execute 'syntax keyword' key join(a:dict[key], ' ')
                            	endfor
                            endfunction
                            
    2              0.000016 if exists('b:clojure_syntax_without_core_keywords') && b:clojure_syntax_without_core_keywords
                            	" Only match language specials and primitives
                            	for s:key in ['clojureBoolean', 'clojureConstant', 'clojureException', 'clojureSpecial']
                            		execute 'syntax keyword' s:key join(s:clojure_syntax_keywords[s:key], ' ')
                            	endfor
                            else
    2   0.005672   0.000039 	call s:syntax_keyword(s:clojure_syntax_keywords)
    2              0.000007 endif
                            
    2              0.000010 if exists('g:clojure_syntax_keywords')
                            	call s:syntax_keyword(g:clojure_syntax_keywords)
                            endif
                            
    2              0.000007 if exists('b:clojure_syntax_keywords')
                            	call s:syntax_keyword(b:clojure_syntax_keywords)
                            endif
                            
    2              0.000004 unlet! s:key
    2              0.000016 delfunction s:syntax_keyword
                            
                            " Keywords are symbols:
                            "   static Pattern symbolPat = Pattern.compile("[:]?([\\D&&[^/]].*/)?([\\D&&[^/]][^/]*)");
                            " But they:
                            "   * Must not end in a : or /
                            "   * Must not have two adjacent colons except at the beginning
                            "   * Must not contain any reader metacharacters except for ' and #
    2              0.000050 syntax match clojureKeyword "\v<:{1,2}%([^ \n\r\t()\[\]{}";@^`~\\%/]+/)*[^ \n\r\t()\[\]{}";@^`~\\%/]+:@<!>"
                            
    2              0.000028 syntax match clojureStringEscape "\v\\%([\\btnfr"]|u\x{4}|[0-3]\o{2}|\o{1,2})" contained
                            
    2              0.000043 syntax region clojureString matchgroup=clojureStringDelimiter start=/"/ skip=/\\\\\|\\"/ end=/"/ contains=clojureStringEscape,@Spell
                            
    2              0.000024 syntax match clojureCharacter "\\."
    2              0.000017 syntax match clojureCharacter "\\o\%([0-3]\o\{2\}\|\o\{1,2\}\)"
    2              0.000010 syntax match clojureCharacter "\\u\x\{4\}"
    2              0.000010 syntax match clojureCharacter "\\space"
    2              0.000012 syntax match clojureCharacter "\\tab"
    2              0.000011 syntax match clojureCharacter "\\newline"
    2              0.000008 syntax match clojureCharacter "\\return"
    2              0.000008 syntax match clojureCharacter "\\backspace"
    2              0.000008 syntax match clojureCharacter "\\formfeed"
                            
    2              0.000026 syntax match clojureSymbol "\v%([a-zA-Z!$&*_+=|<.>?-]|[^\x00-\x7F])+%(:?%([a-zA-Z0-9!#$%&*_+=|'<.>/?-]|[^\x00-\x7F]))*[#:]@<!"
                            
    2              0.000010 let s:radix_chars = "0123456789abcdefghijklmnopqrstuvwxyz"
   72              0.000085 for s:radix in range(2, 36)
   70              0.000616 	execute 'syntax match clojureNumber "\v\c<[-+]?' . s:radix . 'r[' . strpart(s:radix_chars, 0, s:radix) . ']+>"'
   70              0.000049 endfor
    2              0.000006 unlet! s:radix_chars s:radix
                            
    2              0.000013 syntax match clojureNumber "\v<[-+]?%(0\o*|0x\x+|[1-9]\d*)N?>"
    2              0.000015 syntax match clojureNumber "\v<[-+]?%(0|[1-9]\d*|%(0|[1-9]\d*)\.\d*)%(M|[eE][-+]?\d+)?>"
    2              0.000008 syntax match clojureNumber "\v<[-+]?%(0|[1-9]\d*)/%(0|[1-9]\d*)>"
                            
    2              0.000007 syntax match clojureVarArg "&"
                            
    2              0.000006 syntax match clojureQuote "'"
    2              0.000005 syntax match clojureQuote "`"
    2              0.000007 syntax match clojureUnquote "\~"
    2              0.000005 syntax match clojureUnquote "\~@"
    2              0.000007 syntax match clojureMeta "\^"
    2              0.000005 syntax match clojureDeref "@"
    2              0.000009 syntax match clojureDispatch "\v#[\^'=<_]?"
                            
                            " Clojure permits no more than 20 anonymous params.
    2              0.000011 syntax match clojureAnonArg "%\(20\|1\d\|[1-9]\|&\)\?"
                            
    2              0.000024 syntax match  clojureRegexpEscape "\v\\%([\\tnrfae.()\[\]{}^$*?+]|c\u|0[0-3]?\o{1,2}|x%(\x{2}|\{\x{1,6}\})|u\x{4})" contained display
    2              0.000021 syntax region clojureRegexpQuoted start=/\\Q/ms=e+1 skip=/\\\\\|\\"/ end=/\\E/me=s-1 end=/"/me=s-1 contained
    2              0.000022 syntax region clojureRegexpQuote  start=/\\Q/       skip=/\\\\\|\\"/ end=/\\E/       end=/"/me=s-1 contains=clojureRegexpQuoted keepend contained
                            
                            " -*- CHARACTER PROPERTY CLASSES -*-
                            " Generated from https://github.com/guns/vim-clojure-static/blob/%%RELEASE_TAG%%/clj/src/vim_clojure_static/generate.clj
                            " Java version 1.8.0_92
    2              0.000025 syntax match clojureRegexpPosixCharClass "\v\\[pP]\{%(Cntrl|A%(l%(pha|num)|SCII)|Space|Graph|Upper|P%(rint|unct)|Blank|XDigit|Digit|Lower)\}" contained display
    2              0.000034 syntax match clojureRegexpJavaCharClass "\v\\[pP]\{java%(Whitespace|JavaIdentifier%(Part|Start)|SpaceChar|Mirrored|TitleCase|I%(SOControl|de%(ographic|ntifierIgnorable))|D%(efined|igit)|U%(pperCase|nicodeIdentifier%(Part|Start))|L%(etter%(OrDigit)?|owerCase)|Alphabetic)\}" contained display
    2              0.000051 syntax match clojureRegexpUnicodeCharClass "\v\\[pP]\{\cIs%(l%(owercase|etter)|hex%(digit|_digit)|w%(hite%(_space|space)|ord)|noncharacter%(_code_point|codepoint)|p%(rint|unctuation)|ideographic|graph|a%(l%(num|phabetic)|ssigned)|uppercase|join%(control|_control)|titlecase|blank|digit|control)\}" contained display
    2              0.000008 syntax match clojureRegexpUnicodeCharClass "\v\\[pP][NSCMZPL]" contained display
    2              0.000017 syntax match clojureRegexpUnicodeCharClass "\v\\[pP]\{%(N[dlo]?|P[dcifeos]?|C[ncfos]?|M[nce]?|Z[lsp]?|S[mcko]?|L[muCDlto]?)\}" contained display
    2              0.000155 syntax match clojureRegexpUnicodeCharClass "\v\\[pP]\{%(Is|gc\=|general_category\=)?%(N[dlo]?|P[dcifeos]?|C[ncfos]?|M[nce]?|Z[lsp]?|S[mcko]?|L[muCDlto]?)\}" contained display
    2              0.000248 syntax match clojureRegexpUnicodeCharClass "\v\\[pP]\{\c%(Is|sc\=|script\=)%(l%(epc%(ha)?|y%([dc]i%(an)?)|a%(t%(n|in)|na|oo?)|i%(n%(b|ear_b)|mbu?|su))|p%(rti|lrd|h%(oenician|li|ag%(s_pa)?|nx))|vaii?|d%(srt|e%(seret|va%(nagari)?))|g%(lag%(olitic)?|eor%(gian)?|oth%(ic)?|re%(k|ek)|u%(j%(arati|r)|r%(u|mukhi)))|u%(gar%(itic)?|nknown)|a%(r%(ab%(ic)?|m%([ni]|enian))|v%(st|estan))|e%(thi%(opic)?|gyp%(tian_hieroglyphs)?)|z%(inh|yyy|zzz)|r%(un%(ic|r)|ejang|jng)|s%(inh%(ala)?|h%(rd|a%(vian|rada|w))|a%(ur%(ashtra)?|m%(r|aritan)|rb)|y%(r%(c|iac)|lo%(ti_nagri)?)|und%(anese)?|ora%(_sompeng)?)|i%(n%(scriptional_pa%(rthian|hlavi)|herited)|mperial_aramaic|tal)|b%(eng%(ali)?|a%(t%(ak|k)|li%(nese)?|mum?)|ra%(i%(lle)?|h%(mi)?)|opo%(mofo)?|u%(gi%(nese)?|h%(d|id)))|o%(g%(am|ham)|r%(iya|kh|ya)|sma%(nya)?|l%(d_%(south_arabian|persian|italic|turkic)|ck|_chiki))|k%(h%(m%(r|er)|ar%(oshthi)?)|nda|a%(li|n%(a|nada)|takana|yah_li|ithi)|thi)|m%(a%(nd%(aic)?|layalam)|lym|y%(anmar|mr)|tei|e%(r%(c|o%(itic_%(hieroglyphs|cursive))?)|etei_mayek)|o    2              0.000819 syntax match clojureRegexpUnicodeCharClass "\v\\[pP]\{\c%(In|blk\=|block\=)%(javanese|h%(a%(lfwidth%( and fullwidth forms|andfullwidthforms|_and_fullwidth_forms)|n%(unoo|gul%(compatibilityjamo|syllables|jamo%(extended\-[ab])?|_%(syllables|jamo%(_extended_[ab])?|compatibility_jamo)| %(syllables|compatibility jamo|jamo%( extended\-[ab])?))))|i%(ragana|gh%( %(private use surrogates|surrogates)|_%(private_use_surrogates|surrogates)|surrogates|privateusesurrogates))|ebrew)|i%(pa%([ _]extensions|extensions)|deographic%( description characters|_description_characters|descriptioncharacters)|nscriptional%(%([ _]pa%(rthian|hlavi))|pa%(rthian|hlavi))|mperial%(aramaic|[_ ]aramaic))|l%(e%(tterlike%([_ ]symbols|symbols)|pcha)|ow%([_ ]surrogates|surrogates)|i%(mbu|near%(_b_%(ideograms|syllabary)|b%(ideograms|syllabary)| b %(ideograms|syllabary))|su)|a%(tin%(extended%(additional|\-[dacb])| extended%( additional|\-[dacb])|\-1%(supplement| supplement)|_%(extended_%([dcb]|a%(dditional)?)|1_supplement))|o)|y[cd]ian)|b%(u%(ginese                            
    2              0.000015 syntax match   clojureRegexpPredefinedCharClass "\v%(\\[dDsSwW]|\.)" contained display
    2              0.000014 syntax cluster clojureRegexpCharPropertyClasses contains=clojureRegexpPosixCharClass,clojureRegexpJavaCharClass,clojureRegexpUnicodeCharClass
    2              0.000014 syntax cluster clojureRegexpCharClasses         contains=clojureRegexpPredefinedCharClass,clojureRegexpCharClass,@clojureRegexpCharPropertyClasses
    2              0.000024 syntax region  clojureRegexpCharClass           start="\[" skip=/\\\\\|\\]/ end="]" contained contains=clojureRegexpPredefinedCharClass,@clojureRegexpCharPropertyClasses
    2              0.000009 syntax match   clojureRegexpBoundary            "\\[bBAGZz]" contained display
    2              0.000006 syntax match   clojureRegexpBoundary            "[$^]" contained display
    2              0.000008 syntax match   clojureRegexpQuantifier          "[?*+][?+]\=" contained display
    2              0.000009 syntax match   clojureRegexpQuantifier          "\v\{\d+%(,|,\d+)?}\??" contained display
    2              0.000026 syntax match   clojureRegexpOr                  "|" contained display
    2              0.000016 syntax match   clojureRegexpBackRef             "\v\\%([1-9]\d*|k\<[a-zA-z]+\>)" contained display
                            
                            " Mode modifiers, mode-modified spans, lookaround, regular and atomic
                            " grouping, and named-capturing.
    2              0.000009 syntax match clojureRegexpMod "\v\(@<=\?:" contained display
    2              0.000010 syntax match clojureRegexpMod "\v\(@<=\?[xdsmiuU]*-?[xdsmiuU]+:?" contained display
    2              0.000007 syntax match clojureRegexpMod "\v\(@<=\?%(\<?[=!]|\>)" contained display
    2              0.000007 syntax match clojureRegexpMod "\v\(@<=\?\<[a-zA-Z]+\>" contained display
                            
    2              0.000027 syntax region clojureRegexpGroup start="(" skip=/\\\\\|\\)/ end=")" matchgroup=clojureRegexpGroup contained contains=clojureRegexpMod,clojureRegexpQuantifier,clojureRegexpBoundary,clojureRegexpEscape,@clojureRegexpCharClasses
    2              0.000033 syntax region clojureRegexp start=/\#"/ skip=/\\\\\|\\"/ end=/"/ contains=@clojureRegexpCharClasses,clojureRegexpEscape,clojureRegexpQuote,clojureRegexpBoundary,clojureRegexpQuantifier,clojureRegexpOr,clojureRegexpBackRef,clojureRegexpGroup keepend
                            
    2              0.000022 syntax keyword clojureCommentTodo contained FIXME XXX TODO FIXME: XXX: TODO:
                            
    2              0.000013 syntax match clojureComment ";.*$" contains=clojureCommentTodo,@Spell
    2              0.000005 syntax match clojureComment "#!.*$"
                            
                            " -*- TOP CLUSTER -*-
                            " Generated from https://github.com/guns/vim-clojure-static/blob/%%RELEASE_TAG%%/clj/src/vim_clojure_static/generate.clj
    2              0.000071 syntax cluster clojureTop contains=@Spell,clojureAnonArg,clojureBoolean,clojureCharacter,clojureComment,clojureCond,clojureConstant,clojureDefine,clojureDeref,clojureDispatch,clojureError,clojureException,clojureFunc,clojureKeyword,clojureMacro,clojureMap,clojureMeta,clojureNumber,clojureQuote,clojureRegexp,clojureRepeat,clojureSexp,clojureSpecial,clojureString,clojureSymbol,clojureUnquote,clojureVarArg,clojureVariable,clojureVector
                            
    2              0.000015 syntax region clojureSexp   matchgroup=clojureParen start="("  end=")" contains=@clojureTop fold
    2              0.000012 syntax region clojureVector matchgroup=clojureParen start="\[" end="]" contains=@clojureTop fold
    2              0.000012 syntax region clojureMap    matchgroup=clojureParen start="{"  end="}" contains=@clojureTop fold
                            
                            " Highlight superfluous closing parens, brackets and braces.
    2              0.000008 syntax match clojureError "]\|}\|)"
                            
    2              0.000003 syntax sync fromstart
                            
    2              0.000015 highlight default link clojureConstant                  Constant
    2              0.000005 highlight default link clojureBoolean                   Boolean
    2              0.000006 highlight default link clojureCharacter                 Character
    2              0.000004 highlight default link clojureKeyword                   Keyword
    2              0.000004 highlight default link clojureNumber                    Number
    2              0.000004 highlight default link clojureString                    String
    2              0.000005 highlight default link clojureStringDelimiter           String
    2              0.000005 highlight default link clojureStringEscape              Character
                            
    2              0.000004 highlight default link clojureRegexp                    Constant
    2              0.000004 highlight default link clojureRegexpEscape              Character
    2              0.000004 highlight default link clojureRegexpCharClass           SpecialChar
    2              0.000003 highlight default link clojureRegexpPosixCharClass      clojureRegexpCharClass
    2              0.000003 highlight default link clojureRegexpJavaCharClass       clojureRegexpCharClass
    2              0.000003 highlight default link clojureRegexpUnicodeCharClass    clojureRegexpCharClass
    2              0.000003 highlight default link clojureRegexpPredefinedCharClass clojureRegexpCharClass
    2              0.000004 highlight default link clojureRegexpBoundary            SpecialChar
    2              0.000004 highlight default link clojureRegexpQuantifier          SpecialChar
    2              0.000004 highlight default link clojureRegexpMod                 SpecialChar
    2              0.000004 highlight default link clojureRegexpOr                  SpecialChar
    2              0.000004 highlight default link clojureRegexpBackRef             SpecialChar
    2              0.000003 highlight default link clojureRegexpGroup               clojureRegexp
    2              0.000004 highlight default link clojureRegexpQuoted              clojureString
    2              0.000003 highlight default link clojureRegexpQuote               clojureRegexpBoundary
                            
    2              0.000005 highlight default link clojureVariable                  Identifier
    2              0.000005 highlight default link clojureCond                      Conditional
    2              0.000004 highlight default link clojureDefine                    Define
    2              0.000004 highlight default link clojureException                 Exception
    2              0.000009 highlight default link clojureFunc                      Function
    2              0.000005 highlight default link clojureMacro                     Macro
    2              0.000004 highlight default link clojureRepeat                    Repeat
                            
    2              0.000004 highlight default link clojureSpecial                   Special
    2              0.000005 highlight default link clojureVarArg                    Special
    2              0.000004 highlight default link clojureQuote                     SpecialChar
    2              0.000004 highlight default link clojureUnquote                   SpecialChar
    2              0.000004 highlight default link clojureMeta                      SpecialChar
    2              0.000004 highlight default link clojureDeref                     SpecialChar
    2              0.000004 highlight default link clojureAnonArg                   SpecialChar
    2              0.000004 highlight default link clojureDispatch                  SpecialChar
                            
    2              0.000004 highlight default link clojureComment                   Comment
    2              0.000004 highlight default link clojureCommentTodo               Todo
                            
    2              0.000004 highlight default link clojureError                     Error
                            
    2              0.000004 highlight default link clojureParen                     Delimiter
                            
    2              0.000009 let b:current_syntax = "clojure"
                            
    2              0.000024 let &cpo = s:cpo_sav
    2              0.000005 unlet! s:cpo_sav
                            
                            " vim:sts=8:sw=8:ts=8:noet

SCRIPT  /Users/kenji/.vim/plugged/slimv/syntax/clojure/slimv-syntax-clojure.vim
Sourced 2 times
Total time:   0.000064
 Self time:   0.000064

count  total (s)   self (s)
                            " slimv-syntax-clojure.vim:
                            "               Clojure syntax plugin for Slimv
                            " Version:      0.9.11
                            " Last Change:  10 Jun 2013
                            " Maintainer:   Tamas Kovacs <kovisoft at gmail dot com>
                            " License:      This file is placed in the public domain.
                            "               No warranty, express or implied.
                            "               *** ***   Use At-Your-Own-Risk!   *** ***
                            "
                            " =====================================================================
                            "
                            "  Load Once:
    2              0.000031 if exists("b:current_syntax") || exists("g:slimv_disable_clojure")
    2              0.000006   finish

SCRIPT  /usr/local/Cellar/neovim/0.2.0_1/share/nvim/runtime/syntax/clojure.vim
Sourced 2 times
Total time:   0.000056
 Self time:   0.000056

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:     Clojure
                            " Authors:      Toralf Wittner <toralf.wittner@gmail.com>
                            "               modified by Meikel Brandmeyer <mb@kotka.de>
                            " URL:          http://kotka.de/projects/clojure/vimclojure.html
                            "
                            " Contributors: Joel Holdbrooks <cjholdbrooks@gmail.com> (Regexp support, bug fixes)
                            "
                            " Maintainer:   Sung Pae <self@sungpae.com>
                            " URL:          https://github.com/guns/vim-clojure-static
                            " License:      Same as Vim
                            " Last Change:  18 July 2016
                            
    2              0.000024 if exists("b:current_syntax")
    2              0.000004 	finish

SCRIPT  /Users/kenji/.vim/plugged/vim-fireplace/plugin/fireplace/zip.vim
Sourced 1 time
Total time:   0.000019
 Self time:   0.000019

count  total (s)   self (s)
                            " Location:     plugin/fireplace/zip.vim
                            
    1              0.000013 if exists("g:loaded_zip") || &cp || v:version >= 704
    1              0.000002   finish

SCRIPT  /Users/kenji/.vim/plugged/vim-fireplace/plugin/fireplace.vim
Sourced 1 time
Total time:   0.006590
 Self time:   0.006590

count  total (s)   self (s)
                            " fireplace.vim - Clojure REPL support
                            " Maintainer:   Tim Pope <http://tpo.pe/>
                            " Version:      1.1
                            " GetLatestVimScripts: 4978 1 :AutoInstall: fireplace.vim
                            
    1              0.000013 if exists("g:loaded_fireplace") || v:version < 700 || &cp
                              finish
                            endif
    1              0.000003 let g:loaded_fireplace = 1
                            
                            " Section: File type
                            
    1              0.000005 augroup fireplace_file_type
    1              0.000175   autocmd!
    1              0.000063   autocmd BufNewFile,BufReadPost *.clj setfiletype clojure
    1              0.000002 augroup END
                            
                            " Section: Utilities
                            
    1              0.000005 function! s:map(mode, lhs, rhs, ...) abort
                              if get(g:, 'fireplace_no_maps')
                                return
                              endif
                              let flags = (a:0 ? a:1 : '') . (a:rhs =~# '^<Plug>' ? '' : '<script>')
                              if flags =~# '<unique>' && !empty(mapcheck(a:lhs, a:mode))
                                return
                              endif
                              execute a:mode.'map <buffer>' flags a:lhs a:rhs
                            endfunction
                            
                            " Section: Escaping
                            
    1              0.000002 function! s:str(string) abort
                              return '"' . escape(a:string, '"\') . '"'
                            endfunction
                            
    1              0.000002 function! s:qsym(symbol) abort
                              if a:symbol =~# '^[[:alnum:]?*!+/=<>.:-]\+$'
                                return "'".a:symbol
                              else
                                return '(symbol '.s:str(a:symbol).')'
                              endif
                            endfunction
                            
    1              0.000002 function! s:to_ns(path) abort
                              return tr(substitute(a:path, '\.\w\+$', '', ''), '\/_', '..-')
                            endfunction
                            
                            " Section: Completion
                            
    1              0.000003 let s:jar_contents = {}
                            
    1              0.000921 function! fireplace#jar_contents(path) abort
                              if !exists('s:zipinfo')
                                if executable('zipinfo')
                                  let s:zipinfo = 'zipinfo -1 '
                                elseif executable('jar')
                                  let s:zipinfo = 'jar tf '
                                elseif executable('python')
                                  let s:zipinfo = 'python -c '.shellescape('import zipfile, sys; print chr(10).join(zipfile.ZipFile(sys.argv[1]).namelist())').' '
                                else
                                  let s:zipinfo = ''
                                endif
                              endif
                            
                              if !has_key(s:jar_contents, a:path) && has('python')
                                python import vim, zipfile
                                python vim.command("let s:jar_contents[a:path] = split('" + "\n".join(zipfile.ZipFile(vim.eval('a:path')).namelist()) + "', \"\n\")")
                              elseif !has_key(s:jar_contents, a:path) && !empty(s:zipinfo)
                                let s:jar_contents[a:path] = split(system(s:zipinfo.shellescape(a:path)), "\n")
                                if v:shell_error
                                  let s:jar_contents[a:path] = []
                                endif
                              endif
                            
                              return copy(get(s:jar_contents, a:path, []))
                            endfunction
                            
    1              0.000010 function! fireplace#eval_complete(A, L, P) abort
                              let prefix = matchstr(a:A, '\%(.* \|^\)\%(#\=[\[{('']\)*')
                              let keyword = a:A[strlen(prefix) : -1]
                              return sort(map(fireplace#omnicomplete(0, keyword), 'prefix . v:val.word'))
                            endfunction
                            
    1              0.000004 function! fireplace#ns_complete(A, L, P) abort
                              let matches = []
                              for dir in fireplace#path()
                                if dir =~# '\.jar$'
                                  let files = filter(fireplace#jar_contents(dir), 'v:val =~# "\\.clj$"')
                                else
                                  let files = split(glob(dir."/**/*.clj", 1), "\n")
                                  call map(files, 'v:val[strlen(dir)+1 : -1]')
                                endif
                                let matches += files
                              endfor
                              return filter(map(matches, 's:to_ns(v:val)'), 'a:A ==# "" || a:A ==# v:val[0 : strlen(a:A)-1]')
                            endfunction
                            
    1              0.000037 let s:short_types = {
                                  \ 'function': 'f',
                                  \ 'macro': 'm',
                                  \ 'var': 'v',
                                  \ 'special-form': 's',
                                  \ 'class': 'c',
                                  \ 'keyword': 'k',
                                  \ 'local': 'l',
                                  \ 'namespace': 'n',
                                  \ 'field': 'i',
                                  \ 'method': 'f',
                                  \ 'static-field': 'i',
                                  \ 'static-method': 'f',
                                  \ 'resource': 'r'
                                  \ }
                            
    1              0.000006 function! s:candidate(val) abort
                              let type = get(a:val, 'type', '')
                              let arglists = get(a:val, 'arglists', [])
                              return {
                                    \ 'word': get(a:val, 'candidate'),
                                    \ 'kind': get(s:short_types, type, type),
                                    \ 'info': get(a:val, 'doc', ''),
                                    \ 'menu': empty(arglists) ? '' : '(' . join(arglists, ' ') . ')'
                                    \ }
                            endfunction
                            
    1              0.000003 function! s:get_complete_context() abort
                              " Find toplevel form
                              " If cursor is on start parenthesis we don't want to find the form
                              " If cursor is on end parenthesis we want to find the form
                              let [line1, col1] = searchpairpos('(', '', ')', 'Wrnb', g:fireplace#skip)
                              let [line2, col2] = searchpairpos('(', '', ')', 'Wrnc', g:fireplace#skip)
                            
                              if (line1 == 0 && col1 == 0) || (line2 == 0 && col2 == 0)
                                return ""
                              endif
                            
                              if line1 == line2
                                let expr = getline(line1)[col1-1 : col2-1]
                              else
                                let expr = getline(line1)[col1-1 : -1] . ' '
                                      \ . join(getline(line1+1, line2-1), ' ')
                                      \ . getline(line2)[0 : col2-1]
                              endif
                            
                              " Calculate the position of cursor inside the expr
                              if line1 == line('.')
                                let p = col('.') - col1
                              else
                                let p = strlen(getline(line1)[col1-1 : -1])
                                      \ + strlen(join(getline(line1 + 1, line('.') - 1), ' '))
                                      \ + col('.')
                              endif
                            
                              return strpart(expr, 0, p) . ' __prefix__ ' . strpart(expr, p)
                            endfunction
                            
    1              0.000010 function! fireplace#omnicomplete(findstart, base) abort
                              if a:findstart
                                let line = getline('.')[0 : col('.')-2]
                                return col('.') - strlen(matchstr(line, '\k\+$')) - 1
                              else
                                try
                            
                                  if fireplace#op_available('complete')
                                    let response = fireplace#message({
                                          \ 'op': 'complete',
                                          \ 'symbol': a:base,
                                          \ 'extra-metadata': ['arglists', 'doc'],
                                          \ 'context': s:get_complete_context()
                                          \ })
                                    let trans = '{"word": (v:val =~# ''[./]'' ? "" : matchstr(a:base, ''^.\+/'')) . v:val}'
                                    let value = get(response[0], 'value', get(response[0], 'completions'))
                                    if type(value) == type([])
                                      if type(get(value, 0)) == type({})
                                        return map(value, 's:candidate(v:val)')
                                      elseif type(get(value, 0)) == type([])
                                        return map(value[0], trans)
                                      elseif type(get(value, 0)) == type('')
                                        return map(value, trans)
                                      else
                                        return []
                                      endif
                                    endif
                                  endif
                            
                                  let omnifier = '(fn [[k v]] (let [{:keys [arglists] :as m} (meta v)]' .
                                        \ ' {:word k :menu (pr-str (or arglists (symbol ""))) :info (str (when arglists (str arglists "\n")) "  " (:doc m)) :kind (if arglists "f" "v")}))'
                            
                                  let ns = fireplace#ns()
                            
                                  let [aliases, namespaces, maps] = fireplace#evalparse(
                                        \ '[(ns-aliases '.s:qsym(ns).') (all-ns) '.
                                        \ '(sort-by :word (map '.omnifier.' (ns-map '.s:qsym(ns).')))]')
                            
                                  if a:base =~# '^[^/]*/[^/]*$'
                                    let ns = matchstr(a:base, '^.*\ze/')
                                    let prefix = ns . '/'
                                    let ns = get(aliases, ns, ns)
                                    let keyword = matchstr(a:base, '.*/\zs.*')
                                    let results = fireplace#evalparse(
                                          \ '(sort-by :word (map '.omnifier.' (ns-publics '.s:qsym(ns).')))')
                                    for r in results
                                      let r.word = prefix . r.word
                                    endfor
                                  else
                                    let keyword = a:base
                                    let results = maps + map(sort(keys(aliases) + namespaces), '{"word": v:val."/", "kind": "t", "info": ""}')
                                  endif
                                  if type(results) == type([])
                                    return filter(results, 'a:base ==# "" || a:base ==# v:val.word[0 : strlen(a:base)-1]')
                                  else
                                    return []
                                  endif
                                catch /.*/
                                  return []
                                endtry
                              endif
                            endfunction
                            
    1              0.000008 augroup fireplace_completion
    1              0.000217   autocmd!
    1              0.000019   autocmd FileType clojure setlocal omnifunc=fireplace#omnicomplete
    1              0.000002 augroup END
                            
                            " Section: REPL client
                            
    1              0.000017 let s:repl = {"requires": {}}
                            
    1              0.000008 if !exists('s:repls')
    1              0.000003   let s:repls = []
    1              0.000003   let s:repl_paths = {}
    1              0.000003   let s:repl_portfiles = {}
    1              0.000002 endif
                            
    1              0.000003 function! s:repl.path() dict abort
                              return self.connection.path()
                            endfunction
                            
    1              0.000004 function! s:conn_try(connection, function, ...) abort
                              try
                                return call(a:connection[a:function], a:000, a:connection)
                              catch /^\w\+ Connection Error:/
                                call s:unregister_connection(a:connection)
                                throw v:exception
                              endtry
                            endfunction
                            
    1              0.000003 function! s:repl.message(payload, ...) dict abort
                              if has_key(a:payload, 'ns') && a:payload.ns !=# self.user_ns()
                                let ignored_error = self.preload(a:payload.ns)
                              endif
                              return call('s:conn_try', [self.connection, 'message', a:payload] + a:000, self)
                            endfunction
                            
    1              0.000003 function! s:repl.preload(lib) dict abort
                              if !empty(a:lib) && a:lib !=# self.user_ns() && !get(self.requires, a:lib)
                                let reload = has_key(self.requires, a:lib) ? ' :reload' : ''
                                let self.requires[a:lib] = 0
                                let clone = s:conn_try(self.connection, 'clone')
                                if self.user_ns() ==# 'user'
                                  let qsym = s:qsym(a:lib)
                                  let expr = '(when-not (find-ns '.qsym.') (try'
                                        \ . ' (#''clojure.core/load-one '.qsym.' true true)'
                                        \ . ' (catch Exception e (when-not (find-ns '.qsym.') (throw e)))))'
                                else
                                  let expr = '(ns '.self.user_ns().' (:require '.a:lib.reload.'))'
                                endif
                                try
                                  let result = clone.eval(expr, {'ns': self.user_ns()})
                                finally
                                  call clone.close()
                                endtry
                                let self.requires[a:lib] = !has_key(result, 'ex')
                                if has_key(result, 'ex')
                                  return result
                                endif
                              endif
                              return {}
                            endfunction
                            
    1              0.000012 let s:piggieback = copy(s:repl)
                            
    1              0.000003 function! s:repl.piggieback(arg, ...) abort
                              if a:0 && a:1
                                if len(self.piggiebacks)
                                  let result = fireplace#session_eval(':cljs/quit', {})
                                  call remove(self.piggiebacks, 0)
                                endif
                                return {}
                              endif
                            
                              let connection = s:conn_try(self.connection, 'clone')
                              if empty(a:arg)
                                let arg = '(cljs.repl.rhino/repl-env)'
                              elseif a:arg =~# '^\d\{1,5}$'
                                let replns = 'weasel.repl.websocket'
                                if has_key(connection.eval("(require '" . replns . ")"), 'ex')
                                  let replns = 'cljs.repl.browser'
                                  call connection.eval("(require '" . replns . ")")
                                endif
                                let port = matchstr(a:arg, '^\d\{1,5}$')
                                let arg = '('.replns.'/repl-env :port '.port.')'
                              else
                                let arg = a:arg
                              endif
                              let response = connection.eval('(cemerick.piggieback/cljs-repl'.' '.arg.')')
                            
                              if empty(get(response, 'ex'))
                                call insert(self.piggiebacks, extend({'connection': connection}, deepcopy(s:piggieback)))
                                return {}
                              endif
                              call connection.close()
                              return response
                            endfunction
                            
    1              0.000003 function! s:piggieback.user_ns() abort
                              return 'cljs.user'
                            endfunction
                            
    1              0.000003 function! s:piggieback.eval(expr, options) abort
                              let options = copy(a:options)
                              if has_key(options, 'file_path')
                                call remove(options, 'file_path')
                              endif
                              return call(s:repl.eval, [a:expr, options], self)
                            endfunction
                            
    1              0.000002 function! s:repl.user_ns() abort
                              return 'user'
                            endfunction
                            
    1              0.000003 function! s:repl.eval(expr, options) dict abort
                              if has_key(a:options, 'ns') && a:options.ns !=# self.user_ns()
                                let error = self.preload(a:options.ns)
                                if !empty(error)
                                  return error
                                endif
                              endif
                              return s:conn_try(self.connection, 'eval', a:expr, a:options)
                            endfunction
                            
    1              0.000004 function! s:register_connection(conn, ...) abort
                              call insert(s:repls, extend({'connection': a:conn, 'piggiebacks': []}, deepcopy(s:repl)))
                              if a:0 && a:1 !=# ''
                                let s:repl_paths[a:1] = s:repls[0]
                              endif
                              return s:repls[0]
                            endfunction
                            
    1              0.000003 function! s:unregister_connection(conn) abort
                              call filter(s:repl_paths, 'v:val.connection.transport isnot# a:conn.transport')
                              call filter(s:repls, 'v:val.connection.transport isnot# a:conn.transport')
                              call filter(s:repl_portfiles, 'v:val.connection.transport isnot# a:conn.transport')
                            endfunction
                            
    1              0.000007 function! fireplace#register_port_file(portfile, ...) abort
                              let old = get(s:repl_portfiles, a:portfile, {})
                              if has_key(old, 'time') && getftime(a:portfile) !=# old.time
                                call s:unregister_connection(old.connection)
                                let old = {}
                              endif
                              if empty(old) && getfsize(a:portfile) > 0
                                let port = matchstr(readfile(a:portfile, 'b', 1)[0], '\d\+')
                                try
                                  let conn = fireplace#nrepl_connection#open(port)
                                  let s:repl_portfiles[a:portfile] = {
                                        \ 'time': getftime(a:portfile),
                                        \ 'connection': conn}
                                  call s:register_connection(conn, a:0 ? a:1 : '')
                                  return conn
                                catch /^nREPL Connection Error:/
                                  if &verbose
                                    echohl WarningMSG
                                    echomsg v:exception
                                    echohl None
                                  endif
                                  return {}
                                endtry
                              else
                                return get(old, 'connection', {})
                              endif
                            endfunction
                            
                            " Section: :Connect
                            
    1              0.000022 command! -bar -complete=customlist,s:connect_complete -nargs=* FireplaceConnect :exe s:Connect(<f-args>)
                            
    1              0.000006 function! fireplace#input_host_port() abort
                              let arg = input('Host> ', 'localhost')
                              if arg ==# ''
                                return ''
                              endif
                              echo "\n"
                              let arg .= ':' . input('Port> ')
                              if arg =~# ':$'
                                return ''
                              endif
                              echo "\n"
                              return arg
                            endfunction
                            
    1              0.000004 function! s:protos() abort
                              return map(split(globpath(&runtimepath, 'autoload/fireplace/*_connection.vim'), "\n"), 'fnamemodify(v:val, ":t")[0:-16]')
                            endfunction
                            
    1              0.000004 function! s:connect_complete(A, L, P) abort
                              let proto = matchstr(a:A, '\w\+\ze://')
                              if proto ==# ''
                                let options = map(s:protos(), 'v:val."://"')
                              else
                                let rest = matchstr(a:A, '://\zs.*')
                                try
                                  let options = fireplace#{proto}_connection#complete(rest)
                                catch /^Vim(let):E117/
                                  let options = ['localhost:']
                                endtry
                                call map(options, 'proto."://".v:val')
                              endif
                              if a:A !=# ''
                                call filter(options, 'v:val[0 : strlen(a:A)-1] ==# a:A')
                              endif
                              return options
                            endfunction
                            
    1              0.000004 function! s:Connect(...) abort
                              if (a:0 ? a:1 : '') =~# '^\w\+://'
                                let [proto, arg] = split(a:1, '://')
                              elseif (a:0 ? a:1 : '') =~# '^\%([[:alnum:].-]\+:\)\=\d\+$'
                                let [proto, arg] = ['nrepl', a:1]
                              elseif a:0
                                return 'echoerr '.string('Usage: :Connect proto://...')
                              else
                                let protos = s:protos()
                                if empty(protos)
                                  return 'echoerr '.string('No protocols available')
                                endif
                                let proto = s:inputlist('Protocol> ', protos)
                                if proto ==# ''
                                  return
                                endif
                                redraw!
                                echo ':Connect'
                                echo 'Protocol> '.proto
                                let arg = fireplace#{proto}_connection#prompt()
                              endif
                              try
                                let connection = fireplace#{proto}_connection#open(arg)
                              catch /.*/
                                return 'echoerr '.string(v:exception)
                              endtry
                              if type(connection) !=# type({}) || empty(connection)
                                return ''
                              endif
                              let client = s:register_connection(connection)
                              echo 'Connected to '.proto.'://'.arg
                              let path = fnamemodify(exists('b:java_root') ? b:java_root : fnamemodify(expand('%'), ':p:s?.*\zs[\/]src[\/].*??'), ':~')
                              let root = a:0 > 1 ? expand(a:2) : input('Scope connection to: ', path, 'dir')
                              if root !=# '' && root !=# '-'
                                let s:repl_paths[fnamemodify(root, ':p:s?.\zs[\/]$??')] = client
                              endif
                              return ''
                            endfunction
                            
    1              0.000005 function! s:piggieback(arg, remove) abort
                              let response = fireplace#platform().piggieback(a:arg, a:remove)
                              call s:output_response(response)
                            endfunction
                            
    1              0.000007 augroup fireplace_connect
    1              0.000233   autocmd!
    1              0.000020   autocmd FileType clojure command! -buffer -bar  -complete=customlist,s:connect_complete -nargs=*
                                    \ Connect FireplaceConnect <args>
    1              0.000008   autocmd FileType clojure command! -buffer -bang -complete=customlist,fireplace#eval_complete -nargs=*
                                    \ Piggieback call s:piggieback(<q-args>, <bang>0)
    1              0.000002 augroup END
                            
                            " Section: Java runner
                            
    1              0.000012 let s:oneoff_pr  = tempname()
    1              0.000004 let s:oneoff_ex  = tempname()
    1              0.000004 let s:oneoff_stk = tempname()
    1              0.000004 let s:oneoff_in  = tempname()
    1              0.000004 let s:oneoff_out = tempname()
    1              0.000007 let s:oneoff_err = tempname()
                            
    1              0.000005 function! s:spawning_eval(classpath, expr, ns) abort
                              if a:ns !=# '' && a:ns !=# 'user'
                                let ns = '(require '.s:qsym(a:ns).') (in-ns '.s:qsym(a:ns).') '
                              else
                                let ns = ''
                              endif
                              call writefile([], s:oneoff_pr, 'b')
                              call writefile([], s:oneoff_ex, 'b')
                              call writefile([], s:oneoff_stk, 'b')
                              call writefile(split('(do '.a:expr.')', "\n"), s:oneoff_in, 'b')
                              call writefile([], s:oneoff_out, 'b')
                              call writefile([], s:oneoff_err, 'b')
                              let java_cmd = exists('$JAVA_CMD') ? $JAVA_CMD : 'java'
                              let command = java_cmd.' -cp '.shellescape(a:classpath).' clojure.main -e ' .
                                    \ shellescape(
                                    \   '(binding [*out* (java.io.FileWriter. '.s:str(s:oneoff_out).')' .
                                    \   '          *err* (java.io.FileWriter. '.s:str(s:oneoff_err).')]' .
                                    \   '  (try' .
                                    \   '    (require ''clojure.repl ''clojure.java.javadoc) '.ns.'(spit '.s:str(s:oneoff_pr).' (pr-str (eval (read-string (slurp '.s:str(s:oneoff_in).')))))' .
                                    \   '    (catch Exception e' .
                                    \   '      (spit *err* (.toString e))' .
                                    \   '      (spit '.s:str(s:oneoff_ex).' (class e))' .
                                    \   '      (spit '.s:str(s:oneoff_stk).' (apply str (interpose "\n" (.getStackTrace e))))))' .
                                    \   '  nil)')
                              let captured = system(command)
                              let result = {}
                              let result.value = join(readfile(s:oneoff_pr, 'b'), "\n")
                              let result.out   = join(readfile(s:oneoff_out, 'b'), "\n")
                              let result.err   = join(readfile(s:oneoff_err, 'b'), "\n")
                              let result.ex    = join(readfile(s:oneoff_ex, 'b'), "\n")
                              let result.stacktrace = readfile(s:oneoff_stk)
                              if empty(result.ex)
                                let result.status = ['done']
                              else
                                let result.status = ['eval-error', 'done']
                              endif
                              call filter(result, '!empty(v:val)')
                              if v:shell_error && get(result, 'ex', '') ==# ''
                                throw 'Error running Java: '.get(split(captured, "\n"), -1, '')
                              else
                                return result
                              endif
                            endfunction
                            
    1              0.000004 let s:oneoff = {}
                            
    1              0.000003 function! s:oneoff.user_ns() abort
                              return 'user'
                            endfunction
                            
    1              0.000002 function! s:oneoff.path() dict abort
                              return self._path
                            endfunction
                            
    1              0.000003 function! s:oneoff.eval(expr, options) dict abort
                              if !empty(get(a:options, 'session', 1))
                                throw 'Fireplace: no live REPL connection'
                              endif
                              let result = s:spawning_eval(join(self.path(), has('win32') ? ';' : ':'),
                                    \ a:expr, get(a:options, 'ns', self.user_ns()))
                              if has_key(a:options, 'id')
                                let result.id = a:options.id
                              endif
                              return result
                            endfunction
                            
    1              0.000002 function! s:oneoff.message(...) abort
                              throw 'Fireplace: no live REPL connection'
                            endfunction
                            
    1              0.000006 let s:oneoff.piggieback = s:oneoff.message
                            
                            " Section: Client
                            
    1              0.000003 function! s:buffer_path(...) abort
                              let buffer = a:0 ? a:1 : s:buf()
                              if getbufvar(buffer, '&buftype') =~# '^no'
                                return ''
                              endif
                              let path = substitute(fnamemodify(bufname(buffer), ':p'), '\C^zipfile:\(.*\)::', '\1/', '')
                              for dir in fireplace#path(buffer)
                                if dir !=# '' && path[0 : strlen(dir)-1] ==# dir && path[strlen(dir)] =~# '[\/]'
                                  return path[strlen(dir)+1:-1]
                                endif
                              endfor
                              return ''
                            endfunction
                            
    1              0.000004 function! fireplace#ns(...) abort
                              let buffer = a:0 ? a:1 : s:buf()
                              if !empty(getbufvar(buffer, 'fireplace_ns'))
                                return getbufvar(buffer, 'fireplace_ns')
                              endif
                              let head = getbufline(buffer, 1, 500)
                              let blank = '^\s*\%(;.*\)\=$'
                              call filter(head, 'v:val !~# blank')
                              let keyword_group = '[A-Za-z0-9_?*!+/=<>.-]'
                              let lines = join(head[0:49], ' ')
                              let lines = substitute(lines, '"\%(\\.\|[^"]\)*"\|\\.', '', 'g')
                              let lines = substitute(lines, '\^\={[^{}]*}', '', '')
                              let lines = substitute(lines, '\^:'.keyword_group.'\+', '', 'g')
                              let ns = matchstr(lines, '\C^(\s*\%(in-ns\s*''\|ns\s\+\)\zs'.keyword_group.'\+\ze')
                              if ns !=# ''
                                return ns
                              endif
                              let path = s:buffer_path(buffer)
                              return s:to_ns(path ==# '' ? fireplace#client(buffer).user_ns() : path)
                            endfunction
                            
    1              0.000003 function! s:buf() abort
                              if exists('s:input')
                                return s:input
                              elseif has_key(s:qffiles, expand('%:p'))
                                return s:qffiles[expand('%:p')].buffer
                              else
                                return '%'
                              endif
                            endfunction
                            
    1              0.000003 function! s:repl_ns() abort
                              let buf = a:0 ? a:1 : s:buf()
                              if fnamemodify(bufname(buf), ':e') ==# 'cljs'
                                return 'cljs.repl'
                              endif
                                return 'clojure.repl'
                              endif
                            endfunction
                            
    1              0.000003 function! s:slash() abort
                              return exists('+shellslash') && !&shellslash ? '\' : '/'
                            endfunction
                            
    1              0.000003 function! s:includes_file(file, path) abort
                              let file = substitute(a:file, '\C^zipfile:\(.*\)::', '\1/', '')
                              let file = substitute(file, '\C^fugitive:[\/][\/]\(.*\)\.git[\/][\/][^\/]\+[\/]', '\1', '')
                              for path in a:path
                                if file[0 : len(path)-1] ==? path
                                  return 1
                                endif
                              endfor
                            endfunction
                            
    1              0.000003 function! s:path_extract(path)
                              let path = []
                              if a:path =~# '\.jar'
                                for elem in split(substitute(a:path, ',$', '', ''), ',')
                                  if elem ==# ''
                                    let path += ['.']
                                  else
                                    let path += split(glob(substitute(elem, '\\\ze[\\ ,]', '', 'g'), 1), "\n")
                                  endif
                                endfor
                              endif
                              return path
                            endfunction
                            
    1              0.000004 function! fireplace#path(...) abort
                              let buf = a:0 ? a:1 : s:buf()
                              for repl in s:repls
                                if s:includes_file(fnamemodify(bufname(buf), ':p'), repl.path())
                                  return repl.path()
                                endif
                              endfor
                              return s:path_extract(getbufvar(buf, '&path'))
                            endfunction
                            
    1              0.000003 function! fireplace#platform(...) abort
                              for [k, v] in items(s:repl_portfiles)
                                if getftime(k) != v.time
                                  call s:unregister_connection(v.connection)
                                endif
                              endfor
                            
                              let portfile = findfile('.nrepl-port', '.;')
                              if !empty(portfile)
                                call fireplace#register_port_file(portfile, fnamemodify(portfile, ':p:h'))
                              endif
                              silent doautocmd User FireplacePreConnect
                            
                              let buf = a:0 ? a:1 : s:buf()
                              let root = simplify(fnamemodify(bufname(buf), ':p:s?[\/]$??'))
                              let previous = ""
                              while root !=# previous
                                if has_key(s:repl_paths, root)
                                  return s:repl_paths[root]
                                endif
                                let previous = root
                                let root = fnamemodify(root, ':h')
                              endwhile
                              for repl in s:repls
                                if s:includes_file(fnamemodify(bufname(buf), ':p'), repl.path())
                                  return repl
                                endif
                              endfor
                              let path = s:path_extract(getbufvar(buf, '&path'))
                              if !empty(path) && fnamemodify(bufname(buf), ':e') =~# '^clj[cx]\=$'
                                return extend({'_path': path, 'nr': bufnr(buf)}, s:oneoff)
                              endif
                              throw 'Fireplace: :Connect to a REPL or install classpath.vim'
                            endfunction
                            
    1              0.000004 function! fireplace#client(...) abort
                              let buf = a:0 ? a:1 : s:buf()
                              let client = fireplace#platform(buf)
                              if fnamemodify(bufname(buf), ':e') ==# 'cljs'
                                if !has_key(client, 'connection')
                                  throw 'Fireplace: no live REPL connection'
                                endif
                                if empty(client.piggiebacks)
                                  let result = client.piggieback('')
                                  if has_key(result, 'ex')
                                    throw 'Fireplace: '.result.ex
                                  endif
                                endif
                                return client.piggiebacks[0]
                              endif
                              return client
                            endfunction
                            
    1              0.000004 function! fireplace#message(payload, ...) abort
                              let client = fireplace#client()
                              let payload = copy(a:payload)
                              if !has_key(payload, 'ns')
                                let payload.ns = fireplace#ns()
                              elseif empty(payload.ns)
                                unlet payload.ns
                              endif
                              return call(client.message, [payload] + a:000, client)
                            endfunction
                            
    1              0.000004 function! fireplace#op_available(op) abort
                              try
                                let client = fireplace#platform()
                                if has_key(client, 'connection')
                                  return client.connection.has_op(a:op)
                                endif
                              catch /^Fireplace: :Connect to a REPL/
                              endtry
                            endfunction
                            
    1              0.000004 function! fireplace#findresource(resource, ...) abort
                              if a:resource ==# ''
                                return ''
                              endif
                              let resource = a:resource
                              if a:0 > 2 && type(a:3) == type([])
                                let suffixes = a:3
                              else
                                let suffixes = [''] + split(get(a:000, 2, ''), ',')
                              endif
                              for dir in a:0 ? a:1 : fireplace#path()
                                for suffix in suffixes
                                  if fnamemodify(dir, ':e') ==# 'jar' && index(fireplace#jar_contents(dir), resource . suffix) >= 0
                                    return 'zipfile:' . dir . '::' . resource . suffix
                                  elseif filereadable(dir . '/' . resource . suffix)
                                    return dir . s:slash() . resource . suffix
                                  endif
                                endfor
                              endfor
                              return ''
                            endfunction
                            
    1              0.000004 function! s:output_response(response) abort
                              let substitution_pat =  '\e\[[0-9;]*m\|\r\|\n$'
                              if get(a:response, 'err', '') !=# ''
                                echohl ErrorMSG
                                echo substitute(a:response.err, substitution_pat, '', 'g')
                                echohl NONE
                              endif
                              if get(a:response, 'out', '') !=# ''
                                echo substitute(a:response.out, substitution_pat, '', 'g')
                              endif
                            endfunction
                            
    1              0.000003 function! s:eval(expr, ...) abort
                              let options = a:0 ? copy(a:1) : {}
                              let client = fireplace#client()
                              if !has_key(options, 'ns')
                                let options.ns = fireplace#ns()
                              endif
                              return client.eval(a:expr, options)
                            endfunction
                            
    1              0.000004 function! s:temp_response(response) abort
                              let output = []
                              if get(a:response, 'err', '') !=# ''
                                let output = map(split(a:response.err, "\n"), '";!!".v:val')
                              endif
                              if get(a:response, 'out', '') !=# ''
                                let output = map(split(a:response.out, "\n"), '";".v:val')
                              endif
                              if has_key(a:response, 'value')
                                let output += [a:response.value]
                              endif
                              let temp = tempname().'.clj'
                              call writefile(output, temp)
                              return temp
                            endfunction
                            
    1              0.000007 if !exists('s:history')
    1              0.000005   let s:history = []
    1              0.000002 endif
                            
    1              0.000004 if !exists('s:qffiles')
    1              0.000003   let s:qffiles = {}
    1              0.000001 endif
                            
    1              0.000004 function! s:qfentry(entry) abort
                              if !has_key(a:entry, 'tempfile')
                                let a:entry.tempfile = s:temp_response(a:entry.response)
                              endif
                              let s:qffiles[a:entry.tempfile] = a:entry
                              return {'filename': a:entry.tempfile, 'text': a:entry.code, 'type': 'E'}
                            endfunction
                            
    1              0.000003 function! s:qfhistory() abort
                              let list = []
                              for entry in reverse(s:history)
                                if !has_key(entry, 'tempfile')
                                  let entry.tempfile = s:temp_response(entry.response)
                                endif
                                call extend(list, [s:qfentry(entry)])
                              endfor
                              return list
                            endfunction
                            
    1              0.000004 function! fireplace#session_eval(expr, ...) abort
                              let response = s:eval(a:expr, a:0 ? a:1 : {})
                            
                              if !empty(get(response, 'value', '')) || !empty(get(response, 'err', ''))
                                call insert(s:history, {'buffer': bufnr(''), 'code': a:expr, 'ns': fireplace#ns(), 'response': response})
                              endif
                              if len(s:history) > &history
                                call remove(s:history, &history, -1)
                              endif
                            
                              if !empty(get(response, 'stacktrace', []))
                                let nr = 0
                                if has_key(s:qffiles, expand('%:p'))
                                  let nr = winbufnr(s:qffiles[expand('%:p')].buffer)
                                endif
                                if nr != -1
                                  call setloclist(nr, fireplace#quickfix_for(response.stacktrace))
                                endif
                              endif
                            
                              try
                                silent doautocmd User FireplaceEvalPost
                              catch
                                echohl ErrorMSG
                                echomsg v:exception
                                echohl NONE
                              endtry
                            
                              call s:output_response(response)
                            
                              if get(response, 'ex', '') !=# ''
                                let err = 'Clojure: '.response.ex
                              elseif has_key(response, 'value')
                                return response.value
                              else
                                let err = 'fireplace.vim: Something went wrong: '.string(response)
                              endif
                              throw err
                            endfunction
                            
    1              0.000004 function! fireplace#eval(...) abort
                              return call('fireplace#session_eval', a:000)
                            endfunction
                            
    1              0.000004 function! fireplace#echo_session_eval(expr, ...) abort
                              try
                                echo fireplace#session_eval(a:expr, a:0 ? a:1 : {})
                              catch /^Clojure:/
                              catch
                                echohl ErrorMSG
                                echomsg v:exception
                                echohl NONE
                              endtry
                              return ''
                            endfunction
                            
    1              0.000005 function! fireplace#evalprint(expr) abort
                              return fireplace#echo_session_eval(a:expr)
                            endfunction
                            
    1              0.000004 function! fireplace#macroexpand(fn, form) abort
                              return fireplace#evalprint('('.a:fn.' (quote '.a:form.'))')
                            endfunction
                            
    1              0.000031 let g:fireplace#reader =
                                  \ '(symbol ((fn *vimify [x]' .
                                  \  ' (cond' .
                                  \    ' (map? x)     (str "{" (apply str (interpose ", " (map (fn [[k v]] (str (*vimify k) ": " (*vimify v))) x))) "}")' .
                                  \    ' (coll? x)    (str "[" (apply str (interpose ", " (map *vimify x))) "]")' .
                                  \    ' (true? x)    "1"' .
                                  \    ' (false? x)   "0"' .
                                  \    ' (number? x)  (pr-str x)' .
                                  \    ' (keyword? x) (pr-str (name x))' .
                                  \    ' :else        (pr-str (str x)))) %s))'
                            
    1              0.000004 function! fireplace#evalparse(expr, ...) abort
                              let options = extend({'session': 0}, a:0 ? a:1 : {})
                              let response = s:eval(printf(g:fireplace#reader, a:expr), options)
                              call s:output_response(response)
                            
                              if get(response, 'ex', '') !=# ''
                                let err = 'Clojure: '.response.ex
                              elseif has_key(response, 'value')
                                return empty(response.value) ? '' : eval(response.value)
                              else
                                let err = 'fireplace.vim: Something went wrong: '.string(response)
                              endif
                              throw err
                            endfunction
                            
    1              0.000004 function! fireplace#query(expr, ...) abort
                              return fireplace#evalparse(a:expr, a:0 ? a:1 : {})
                            endfunction
                            
                            " Section: Quickfix
                            
    1              0.000004 function! s:qfmassage(line, path) abort
                              let entry = {'text': a:line}
                              let match = matchlist(a:line, '\(\S\+\)\s\=(\(\S\+\))')
                              if !empty(match)
                                let [_, class, file; __] = match
                                if file =~# '^NO_SOURCE_FILE:' || file !~# ':'
                                  let entry.resource = ''
                                  let entry.lnum = 0
                                else
                                  let truncated = substitute(class, '\.[A-Za-z0-9_]\+\%([$/].*\)$', '', '')
                                  let entry.resource = tr(truncated, '.', '/').'/'.split(file, ':')[0]
                                  let entry.lnum = split(file, ':')[-1]
                                endif
                                let entry.filename = fireplace#findresource(entry.resource, a:path)
                                if empty(entry.filename)
                                  let entry.lnum = 0
                                else
                                  let entry.text = class
                                endif
                              endif
                              return entry
                            endfunction
                            
    1              0.000004 function! fireplace#quickfix_for(stacktrace) abort
                              let path = fireplace#path()
                              return map(copy(a:stacktrace), 's:qfmassage(v:val, path)')
                            endfunction
                            
    1              0.000003 function! s:massage_quickfix() abort
                              let p = substitute(matchstr(','.&errorformat, ',classpath\zs\%(\\.\|[^\,]\)*'), '\\\ze[\,%]', '', 'g')
                              if empty(p)
                                return
                              endif
                              let path = p[0] ==# ',' ? s:path_extract(p[1:-1]) : split(p[1:-1], p[0])
                              let qflist = getqflist()
                              for entry in qflist
                                call extend(entry, s:qfmassage(get(entry, 'text', ''), path))
                              endfor
                              call setqflist(qflist, 'r')
                            endfunction
                            
    1              0.000005 augroup fireplace_quickfix
    1              0.000197   autocmd!
    1              0.000023   autocmd QuickFixCmdPost make,cfile,cgetfile call s:massage_quickfix()
    1              0.000003 augroup END
                            
                            " Section: Eval
                            
    1              0.000006 let fireplace#skip = 'synIDattr(synID(line("."),col("."),1),"name") =~? "comment\\|string\\|char\\|regexp"'
                            
    1              0.000004 function! s:opfunc(type) abort
                              let sel_save = &selection
                              let cb_save = &clipboard
                              let reg_save = @@
                              try
                                set selection=inclusive clipboard-=unnamed clipboard-=unnamedplus
                                if type(a:type) == type(0)
                                  let open = '[[{(]'
                                  let close = '[]})]'
                                  if getline('.')[col('.')-1] =~# close
                                    let [line1, col1] = searchpairpos(open, '', close, 'bn', g:fireplace#skip)
                                    let [line2, col2] = [line('.'), col('.')]
                                  else
                                    let [line1, col1] = searchpairpos(open, '', close, 'bcn', g:fireplace#skip)
                                    let [line2, col2] = searchpairpos(open, '', close, 'n', g:fireplace#skip)
                                  endif
                                  while col1 > 1 && getline(line1)[col1-2] =~# '[#''`~@]'
                                    let col1 -= 1
                                  endwhile
                                  call setpos("'[", [0, line1, col1, 0])
                                  call setpos("']", [0, line2, col2, 0])
                                  silent exe "normal! `[v`]y"
                                elseif a:type =~# '^.$'
                                  silent exe "normal! `<" . a:type . "`>y"
                                elseif a:type ==# 'line'
                                  silent exe "normal! '[V']y"
                                elseif a:type ==# 'block'
                                  silent exe "normal! `[\<C-V>`]y"
                                elseif a:type ==# 'outer'
                                  call searchpair('(','',')', 'Wbcr', g:fireplace#skip)
                                  silent exe "normal! vaby"
                                else
                                  silent exe "normal! `[v`]y"
                                endif
                                redraw
                                if fireplace#client().user_ns() ==# 'user'
                                  return repeat("\n", line("'<")-1) . repeat(" ", col("'<")-1) . @@
                                else
                                  return @@
                                endif
                              finally
                                let @@ = reg_save
                                let &selection = sel_save
                                let &clipboard = cb_save
                              endtry
                            endfunction
                            
    1              0.000006 function! s:filterop(type) abort
                              let reg_save = @@
                              let sel_save = &selection
                              let cb_save = &clipboard
                              try
                                set selection=inclusive clipboard-=unnamed clipboard-=unnamedplus
                                let expr = s:opfunc(a:type)
                                let @@ = fireplace#session_eval(matchstr(expr, '^\n\+').expr).matchstr(expr, '\n\+$')
                                if @@ !~# '^\n*$'
                                  normal! gvp
                                endif
                              catch /^Clojure:/
                                return ''
                              finally
                                let @@ = reg_save
                                let &selection = sel_save
                                let &clipboard = cb_save
                              endtry
                            endfunction
                            
    1              0.000004 function! s:macroexpandop(type) abort
                              call fireplace#macroexpand("clojure.walk/macroexpand-all", s:opfunc(a:type))
                            endfunction
                            
    1              0.000004 function! s:macroexpand1op(type) abort
                              call fireplace#macroexpand("macroexpand-1", s:opfunc(a:type))
                            endfunction
                            
    1              0.000003 function! s:printop(type) abort
                              let s:todo = s:opfunc(a:type)
                              call feedkeys("\<Plug>FireplacePrintLast")
                            endfunction
                            
    1              0.000003 function! s:print_last() abort
                              call fireplace#echo_session_eval(s:todo, {'file_path': s:buffer_path()})
                              return ''
                            endfunction
                            
    1              0.000003 function! s:editop(type) abort
                              call feedkeys(eval('"\'.&cedit.'"') . "\<Home>", 'n')
                              let input = s:input(substitute(substitute(substitute(
                                    \ s:opfunc(a:type), "\s*;[^\n\"]*\\%(\n\\@=\\|$\\)", '', 'g'),
                                    \ '\n\+\s*', ' ', 'g'),
                                    \ '^\s*', '', ''))
                              if input !=# ''
                                call fireplace#echo_session_eval(input)
                              endif
                            endfunction
                            
    1              0.000005 function! s:Eval(bang, line1, line2, count, args) abort
                              let options = {}
                              if a:args !=# ''
                                let expr = a:args
                              else
                                if a:count ==# 0
                                  let open = '[[{(]'
                                  let close = '[]})]'
                                  let [line1, col1] = searchpairpos(open, '', close, 'bcrn', g:fireplace#skip)
                                  let [line2, col2] = searchpairpos(open, '', close, 'rn', g:fireplace#skip)
                                  if !line1 && !line2
                                    let [line1, col1] = searchpairpos(open, '', close, 'brn', g:fireplace#skip)
                                    let [line2, col2] = searchpairpos(open, '', close, 'crn', g:fireplace#skip)
                                  endif
                                  while col1 > 1 && getline(line1)[col1-2] =~# '[#''`~@]'
                                    let col1 -= 1
                                  endwhile
                                else
                                  let line1 = a:line1
                                  let line2 = a:line2
                                  let col1 = 1
                                  let col2 = strlen(getline(line2))
                                endif
                                if !line1 || !line2
                                  return ''
                                endif
                                let options.file_path = s:buffer_path()
                                if expand('%:e') ==# 'cljs'
                                  "leading line feed don't work on cljs repl
                                  let expr = ''
                                else
                                  let expr = repeat("\n", line1-1).repeat(" ", col1-1)
                                endif
                                if line1 == line2
                                  let expr .= getline(line1)[col1-1 : col2-1]
                                else
                                  let expr .= getline(line1)[col1-1 : -1] . "\n"
                                        \ . join(map(getline(line1+1, line2-1), 'v:val . "\n"'))
                                        \ . getline(line2)[0 : col2-1]
                                endif
                                if a:bang
                                  exe line1.','.line2.'delete _'
                                endif
                              endif
                              if a:bang
                                try
                                  let result = fireplace#session_eval(expr, options)
                                  if a:args !=# ''
                                    call append(a:line1, result)
                                    exe a:line1
                                  else
                                    call append(a:line1-1, result)
                                    exe a:line1-1
                                  endif
                                catch /^Clojure:/
                                endtry
                              else
                                call fireplace#echo_session_eval(expr, options)
                              endif
                              return ''
                            endfunction
                            
                            " If we call input() directly inside a try, and the user opens the command
                            " line window and tries to switch out of it (such as with ctrl-w), Vim will
                            " crash when the command line window closes.  Adding an indirect function call
                            " works around this.
    1              0.000004 function! s:actually_input(...) abort
                              return call(function('input'), a:000)
                            endfunction
                            
    1              0.000005 function! s:input(default) abort
                              if !exists('g:FIREPLACE_HISTORY') || type(g:FIREPLACE_HISTORY) != type([])
                                unlet! g:FIREPLACE_HISTORY
                                let g:FIREPLACE_HISTORY = []
                              endif
                              try
                                let s:input = bufnr('%')
                                let s:oldhist = s:histswap(g:FIREPLACE_HISTORY)
                                return s:actually_input(fireplace#ns().'=> ', a:default, 'customlist,fireplace#eval_complete')
                              finally
                                unlet! s:input
                                if exists('s:oldhist')
                                  let g:FIREPLACE_HISTORY = s:histswap(s:oldhist)
                                endif
                              endtry
                            endfunction
                            
    1              0.000003 function! s:inputclose() abort
                              let l = substitute(getcmdline(), '"\%(\\.\|[^"]\)*"\|\\.', '', 'g')
                              let open = len(substitute(l, '[^(]', '', 'g'))
                              let close = len(substitute(l, '[^)]', '', 'g'))
                              if open - close == 1
                                return ")\<CR>"
                              else
                                return ")"
                              endif
                            endfunction
                            
    1              0.000003 function! s:inputeval() abort
                              let input = s:input('')
                              redraw
                              if input !=# ''
                                call fireplace#echo_session_eval(input)
                              endif
                              return ''
                            endfunction
                            
    1              0.000003 function! s:recall() abort
                              try
                                cnoremap <expr> ) <SID>inputclose()
                                let input = s:input('(')
                                if input =~# '^(\=$'
                                  return ''
                                else
                                  return fireplace#session_eval(input)
                                endif
                              catch /^Clojure:/
                                return ''
                              finally
                                silent! cunmap )
                              endtry
                            endfunction
                            
    1              0.000003 function! s:histswap(list) abort
                              let old = []
                              for i in range(1, histnr('@') * (histnr('@') > 0))
                                call extend(old, [histget('@', i)])
                              endfor
                              call histdel('@')
                              for entry in a:list
                                call histadd('@', entry)
                              endfor
                              return old
                            endfunction
                            
    1              0.000030 nnoremap <silent> <Plug>FireplacePrintLast :exe <SID>print_last()<CR>
    1              0.000020 nnoremap <silent> <Plug>FireplacePrint  :<C-U>set opfunc=<SID>printop<CR>g@
    1              0.000017 xnoremap <silent> <Plug>FireplacePrint  :<C-U>call <SID>printop(visualmode())<CR>
    1              0.000016 nnoremap <silent> <Plug>FireplaceCountPrint  :<C-U>call <SID>printop(v:count)<CR>
                            
    1              0.000015 nnoremap <silent> <Plug>FireplaceFilter :<C-U>set opfunc=<SID>filterop<CR>g@
    1              0.000014 xnoremap <silent> <Plug>FireplaceFilter :<C-U>call <SID>filterop(visualmode())<CR>
    1              0.000013 nnoremap <silent> <Plug>FireplaceCountFilter :<C-U>call <SID>filterop(v:count)<CR>
                            
    1              0.000013 nnoremap <silent> <Plug>FireplaceMacroExpand  :<C-U>set opfunc=<SID>macroexpandop<CR>g@
    1              0.000013 xnoremap <silent> <Plug>FireplaceMacroExpand  :<C-U>call <SID>macroexpandop(visualmode())<CR>
    1              0.000016 nnoremap <silent> <Plug>FireplaceCountMacroExpand  :<C-U>call <SID>macroexpandop(v:count)<CR>
    1              0.000014 nnoremap <silent> <Plug>Fireplace1MacroExpand :<C-U>set opfunc=<SID>macroexpand1op<CR>g@
    1              0.000016 xnoremap <silent> <Plug>Fireplace1MacroExpand :<C-U>call <SID>macroexpand1op(visualmode())<CR>
    1              0.000020 nnoremap <silent> <Plug>FireplaceCount1MacroExpand :<C-U>call <SID>macroexpand1op(v:count)<CR>
                            
    1              0.000014 nnoremap <silent> <Plug>FireplaceEdit   :<C-U>set opfunc=<SID>editop<CR>g@
    1              0.000014 xnoremap <silent> <Plug>FireplaceEdit   :<C-U>call <SID>editop(visualmode())<CR>
    1              0.000021 nnoremap <silent> <Plug>FireplaceCountEdit :<C-U>call <SID>editop(v:count)<CR>
                            
    1              0.000013 nnoremap          <Plug>FireplacePrompt :exe <SID>inputeval()<CR>
                            
    1              0.000012 noremap!          <Plug>FireplaceRecall <C-R>=<SID>recall()<CR>
                            
    1              0.000004 function! s:Last(bang, count) abort
                              if len(s:history) < a:count
                                return 'echoerr "History entry not found"'
                              endif
                              let history = s:qfhistory()
                              let last = s:qfhistory()[a:count-1]
                              execute 'pedit '.last.filename
                              if !&previewwindow
                                let nr = winnr()
                                wincmd p
                                wincmd P
                              endif
                              call setloclist(0, history)
                              silent exe 'llast '.(len(history)-a:count+1)
                              if exists('nr') && a:bang
                                wincmd p
                                exe nr.'wincmd w'
                              endif
                              return ''
                            endfunction
                            
    1              0.000004 function! s:set_up_eval() abort
                              command! -buffer -bang -range=0 -nargs=? -complete=customlist,fireplace#eval_complete Eval :exe s:Eval(<bang>0, <line1>, <line2>, <count>, <q-args>)
                              command! -buffer -bang -bar -count=1 Last exe s:Last(<bang>0, <count>)
                            
                              if get(g:, 'fireplace_no_maps') | return | endif
                            
                              call s:map('n', 'cp', '<Plug>FireplacePrint')
                              call s:map('n', 'cpp', '<Plug>FireplaceCountPrint')
                            
                              call s:map('n', 'c!', '<Plug>FireplaceFilter')
                              call s:map('n', 'c!!', '<Plug>FireplaceCountFilter')
                            
                              call s:map('n', 'cm', '<Plug>FireplaceMacroExpand')
                              call s:map('n', 'cmm', '<Plug>FireplaceCountMacroExpand')
                              call s:map('n', 'c1m', '<Plug>Fireplace1MacroExpand')
                              call s:map('n', 'c1mm', '<Plug>FireplaceCount1MacroExpand')
                            
                              call s:map('n', 'cq', '<Plug>FireplaceEdit')
                              call s:map('n', 'cqq', '<Plug>FireplaceCountEdit')
                            
                              call s:map('n', 'cqp', '<Plug>FireplacePrompt')
                              call s:map('n', 'cqc', '<Plug>FireplacePrompt' . &cedit . 'i')
                            
                              call s:map('i', '<C-R>(', '<Plug>FireplaceRecall')
                              call s:map('c', '<C-R>(', '<Plug>FireplaceRecall')
                              call s:map('s', '<C-R>(', '<Plug>FireplaceRecall')
                            endfunction
                            
    1              0.000003 function! s:set_up_historical() abort
                              setlocal readonly nomodifiable
                              call s:map('n', 'q', ':bdelete<CR>', '<silent>')
                            endfunction
                            
    1              0.000002 function! s:cmdwinenter() abort
                              setlocal filetype=clojure
                            endfunction
                            
    1              0.000002 function! s:cmdwinleave() abort
                              setlocal filetype< omnifunc<
                            endfunction
                            
    1              0.000005 augroup fireplace_eval
    1              0.000193   autocmd!
    1              0.000014   autocmd FileType clojure call s:set_up_eval()
    1              0.000083   autocmd BufReadPost * if has_key(s:qffiles, expand('<amatch>:p')) |
                                    \   call s:set_up_historical() |
                                    \ endif
    1              0.000013   autocmd CmdWinEnter @ if exists('s:input') | call s:cmdwinenter() | endif
    1              0.000006   autocmd CmdWinLeave @ if exists('s:input') | call s:cmdwinleave() | endif
    1              0.000002 augroup END
                            
                            " Section: :Require
                            
    1              0.000005 function! s:Require(bang, echo, ns) abort
                              if &autowrite || &autowriteall
                                silent! wall
                              endif
                              if expand('%:e') ==# 'cljs'
                                let cmd = '(load-file '.s:str(tr(a:ns ==# '' ? fireplace#ns() : a:ns, '-.', '_/').'.cljs').')'
                              else
                                let cmd = ('(clojure.core/require '.s:qsym(a:ns ==# '' ? fireplace#ns() : a:ns).' :reload'.(a:bang ? '-all' : '').')')
                              endif
                              if a:echo
                                echo cmd
                              endif
                              try
                                call fireplace#session_eval(cmd, {'ns': fireplace#client().user_ns()})
                                return ''
                              catch /^Clojure:.*/
                                return ''
                              endtry
                            endfunction
                            
    1              0.000003 function! s:set_up_require() abort
                              command! -buffer -bar -bang -complete=customlist,fireplace#ns_complete -nargs=? Require :exe s:Require(<bang>0, 1, <q-args>)
                            
                              call s:map('n', 'cpr', ":<C-R>=expand('%:e') ==# 'cljs' ? 'Require' : 'RunTests'<CR><CR>", '<silent>')
                            endfunction
                            
    1              0.000003 augroup fireplace_require
    1              0.000189   autocmd!
    1              0.000017   autocmd FileType clojure call s:set_up_require()
    1              0.000005 augroup END
                            
                            " Section: Go to source
                            
    1              0.000005 function! fireplace#info(symbol) abort
                              if fireplace#op_available('info')
                                let response = fireplace#message({'op': 'info', 'symbol': a:symbol})[0]
                                if type(get(response, 'value')) == type({})
                                  return response.value
                                elseif has_key(response, 'file') || has_key(response, 'doc')
                                  return response
                                endif
                              endif
                            
                              let sym = s:qsym(a:symbol)
                              let cmd =
                                    \ '(cond'
                                    \ . '(not (symbol? ' . sym . '))'
                                    \ . '{}'
                                    \ . '(special-symbol? ' . sym . ')'
                                    \ . "(if-let [m (#'clojure.repl/special-doc " . sym . ")]"
                                    \ .   ' {:name (:name m)'
                                    \ .    ' :special-form "true"'
                                    \ .    ' :doc (:doc m)'
                                    \ .    ' :url (:url m)'
                                    \ .    ' :forms-str (str "  " (:forms m))}'
                                    \ .   ' {})'
                                    \ . '(find-ns ' . sym . ')'
                                    \ . "(if-let [m (#'clojure.repl/namespace-doc (find-ns " . sym . "))]"
                                    \ .   ' {:ns (:name m)'
                                    \ .   '  :doc (:doc m)}'
                                    \ .   ' {})'
                                    \ . ':else'
                                    \ . '(if-let [m (meta (resolve ' . sym .'))]'
                                    \ .   ' {:name (:name m)'
                                    \ .    ' :ns (:ns m)'
                                    \ .    ' :macro (when (:macro m) true)'
                                    \ .    ' :resource (:file m)'
                                    \ .    ' :line (:line m)'
                                    \ .    ' :doc (:doc m)'
                                    \ .    ' :arglists-str (str (:arglists m))}'
                                    \ .   ' {})'
                                    \ . ' )'
                              return fireplace#evalparse(cmd)
                            endfunction
                            
    1              0.000004 function! fireplace#source(symbol) abort
                              let info = fireplace#info(a:symbol)
                            
                              let file = ''
                              if !empty(get(info, 'resource'))
                                let file = fireplace#findresource(info.resource)
                              elseif has_key(info, 'file')
                                let fpath = ''
                                if get(info, 'file') =~# '^/\|^\w:\\'
                                  let file = info.file
                                elseif get(info, 'file') =~# '^file:'
                                  let file = substitute(strpart(info.file,5), '/', s:slash(), 'g')
                                end
                            
                                if !empty(fpath) && filereadable(fpath)
                                  let file = fpath
                                end
                              endif
                            
                              if !empty(file) && !empty(get(info, 'line', ''))
                                return '+' . info.line . ' ' . fnameescape(file)
                              endif
                              return ''
                            endfunction
                            
    1              0.000004 function! fireplace#location(keyword) abort
                              if a:keyword =~# '^\k\+[/.]$'
                                return fireplace#findfile(a:keyword[0: -2])
                              elseif a:keyword =~# '^\k\+\.[^/.]\+$'
                                return fireplace#findfile(a:keyword)
                              else
                                return fireplace#source(a:keyword)
                              endif
                            endfunction
                            
    1              0.000004 function! s:Edit(cmd, keyword) abort
                              try
                                let location = fireplace#location(a:keyword)
                              catch /^Clojure:/
                                return ''
                              endtry
                              if location !=# ''
                                if matchstr(location, '^+\d\+ \zs.*') ==# fnameescape(expand('%:p')) && a:cmd ==# 'edit'
                                  normal! m'
                                  return matchstr(location, '\d\+')
                                else
                                  return substitute(a:cmd, '^\%(<mods>\)\= ', '', '') . ' ' . location .
                                        \ '|let &l:path = ' . string(&l:path)
                                endif
                              endif
                              let v:errmsg = "Couldn't find source for ".a:keyword
                              return 'echoerr v:errmsg'
                            endfunction
                            
    1              0.000025 nnoremap <silent> <Plug>FireplaceDjump :<C-U>exe <SID>Edit('edit', expand('<cword>'))<CR>
    1              0.000019 nnoremap <silent> <Plug>FireplaceDsplit :<C-U>exe <SID>Edit('split', expand('<cword>'))<CR>
    1              0.000018 nnoremap <silent> <Plug>FireplaceDtabjump :<C-U>exe <SID>Edit('tabedit', expand('<cword>'))<CR>
                            
    1              0.000003 function! s:set_up_source() abort
                              setlocal define=^\\s*(def\\w*
                              command! -bar -buffer -nargs=1 -complete=customlist,fireplace#eval_complete Djump  :exe s:Edit('edit', <q-args>)
                              command! -bar -buffer -nargs=1 -complete=customlist,fireplace#eval_complete Dsplit :exe s:Edit('<mods> split', <q-args>)
                            
                              call s:map('n', '[<C-D>',     '<Plug>FireplaceDjump')
                              call s:map('n', ']<C-D>',     '<Plug>FireplaceDjump')
                              call s:map('n', '<C-W><C-D>', '<Plug>FireplaceDsplit')
                              call s:map('n', '<C-W>d',     '<Plug>FireplaceDsplit')
                              call s:map('n', '<C-W>gd',    '<Plug>FireplaceDtabjump')
                            endfunction
                            
    1              0.000004 augroup fireplace_source
    1              0.000167   autocmd!
    1              0.000012   autocmd FileType clojure call s:set_up_source()
    1              0.000002 augroup END
                            
                            " Section: Go to file
                            
    1              0.000005 function! fireplace#findfile(path) abort
                              let path = a:path
                              if a:path !~# '/'
                                let path = tr(a:path, '.-', '/_')
                              else
                                let path = substitute(a:path, '^/', '', '')
                              endif
                              let resource = fireplace#findresource(path, fireplace#path(), 0, &suffixesadd)
                              if !empty(resource)
                                return resource
                              elseif fnamemodify(a:path, ':p') ==# a:path && filereadable(a:path)
                                return path
                              elseif a:path[0] !=# '/' && filereadable(expand('%:h') . '/' . path)
                                return expand('%:h') . '/' . path
                              endif
                              return ''
                            endfunction
                            
    1              0.000008 let s:iskeyword = '[[:alnum:]_=?!#$%&*+|./<>:-]'
    1              0.000011 let s:token = '^\%(#"\%(\\\@<!\%(\\\\\)*\\"\|[^"]\)*"\|"\%(\\.\|[^"]\)*"\|[[:space:],]\+\|\%(;\|#!\)[^'."\n".']*\|\~@\|#[[:punct:]]\|'.s:iskeyword.'\+\|\\\%(space\|tab\|newline\|return\|.\)\|.\)'
    1              0.000004 function! s:read_token(str, pos) abort
                              let pos = a:pos
                              let match = ' '
                              while match =~# '^[[:space:],;]'
                                let match = matchstr(a:str, s:token, pos)
                                let pos += len(match)
                              endwhile
                              if empty(match)
                                throw 'fireplace: Clojure parse error'
                              endif
                              return [match, pos]
                            endfunction
                            
    1              0.000003 function! s:read(str, pos) abort
                              let [token, pos] = s:read_token(a:str, a:pos)
                              if token =~# '^#\=[[{(]'
                                let list = []
                                while index([')', ']', '}', ''], get(list, -1)) < 0
                                  unlet token
                                  let [token, pos] = s:read(a:str, pos)
                                  call add(list, token)
                                endwhile
                                call remove(list, -1)
                                return [list, pos]
                              elseif token ==# '#_'
                                let pos = s:read(a:str, pos)[1]
                                return s:read(a:str, pos)
                              else
                                return [token, pos]
                              endif
                            endfunction
                            
    1              0.000003 function! s:ns(...) abort
                              let buffer = a:0 ? a:1 : s:buf()
                              let head = getbufline(buffer, 1, 1000)
                              let blank = '^\s*\%(;.*\)\=$'
                              call filter(head, 'v:val !~# blank')
                              let keyword_group = '[A-Za-z0-9_?*!+/=<>.-]'
                              let lines = join(head, "\n")
                              let match = matchstr(lines, '\C^(\s*ns\s\+.*')
                              if len(match)
                                try
                                  return s:read(match, 0)[0]
                                catch /^fireplace: Clojure parse error$/
                                endtry
                              endif
                              return []
                            endfunction
                            
    1              0.000006 function! fireplace#resolve_alias(name) abort
                              if a:name =~# '\.'
                                return a:name
                              endif
                              let _ = {}
                              for refs in filter(copy(s:ns()), 'type(v:val) == type([])')
                                if a:name =~# '^\u' && get(refs, 0) is# ':import'
                                  for _.ref in refs
                                    if type(_.ref) == type([]) && index(_.ref, a:name) > 0
                                      return _.ref[0] . '.' . a:name
                                    elseif type(_.ref) == type('') && _.ref =~# '\.'.a:name.'$'
                                      return _.ref
                                    endif
                                  endfor
                                endif
                                if get(refs, 0) is# ':require'
                                  for _.ref in refs
                                    if type(_.ref) == type([])
                                      let i = index(_.ref, ':as')
                                      if i > 0 && get(_.ref, i+1) ==# a:name
                                        return _.ref[0]
                                      endif
                                      for nref in filter(copy(_.ref), 'type(v:val) == type([])')
                                        let i = index(nref, ':as')
                                        if i > 0 && get(nref, i+1) ==# a:name
                                          return _.ref[0].'.'.nref[0]
                                        endif
                                      endfor
                                    endif
                                  endfor
                                endif
                              endfor
                              return a:name
                            endfunction
                            
    1              0.000004 function! fireplace#cfile() abort
                              let file = expand('<cfile>')
                              if file =~# '^\w[[:alnum:]_/]*$' &&
                                    \ synIDattr(synID(line("."),col("."),1),"name") =~# 'String'
                                let file = substitute(expand('%:p'), '[^\/:]*$', '', '').file
                              elseif file =~# '^[^/]*/[^/.]*$' && file =~# '^\k\+$'
                                let [file, jump] = split(file, "/")
                                let file = fireplace#resolve_alias(file)
                                if file !~# '\.' && fireplace#op_available('info')
                                  let res = fireplace#message({'op': 'info', 'symbol': file})
                                  let file = get(get(res, 0, {}), 'ns', file)
                                endif
                                let file = tr(file, '.-', '/_')
                              elseif file =~# '^\w[[:alnum:].-]*$'
                                let file = tr(fireplace#resolve_alias(file), '.-', '/_')
                              endif
                              if exists('jump')
                                return '+sil!dj\ ' . jump . ' ' . fnameescape(file)
                              else
                                return fnameescape(file)
                              endif
                            endfunction
                            
    1              0.000004 function! s:Find(find, edit) abort
                              let cfile = fireplace#cfile()
                              let prefix = matchstr(cfile, '^\%(+\%(\\.\|\S\)*\s\+\)')
                              let file = fireplace#findfile(expand(strpart(cfile, len(prefix))))
                              if file =~# '^zipfile:'
                                let setpath = 'let\ &l:path=getbufvar('.bufnr('').",'&path')"
                                if prefix =~# '^+[^+]'
                                  let prefix = substitute(prefix, '+', '\="+".setpath."\\|"', '')
                                else
                                  let prefix = '+'.setpath.' '.prefix
                                endif
                              endif
                              if len(file)
                                return (len(a:edit) ? a:edit . ' ' : '') . prefix . fnameescape(file)
                              else
                                return len(a:find) ? a:find . ' ' . cfile : "\<C-R>\<C-P>"
                              endif
                            endfunction
                            
    1              0.000020 nnoremap <silent> <Plug>FireplaceEditFile    :<C-U>exe <SID>Find('find','edit')<CR>
    1              0.000014 nnoremap <silent> <Plug>FireplaceSplitFile   :<C-U>exe <SID>Find('sfind','split')<CR>
    1              0.000015 nnoremap <silent> <Plug>FireplaceTabeditFile :<C-U>exe <SID>Find('tabfind','tabedit')<CR>
                            
    1              0.000004 function! s:set_up_go_to_file() abort
                              if expand('%:e') ==# 'cljs'
                                setlocal suffixesadd=.cljs,.cljc,.cljx,.clj,.java
                              else
                                setlocal suffixesadd=.clj,.cljc,.cljx,.cljs,.java
                              endif
                            
                              cmap <buffer><script><expr> <Plug><cfile> substitute(fireplace#cfile(),'^$',"\022\006",'')
                              cmap <buffer><script><expr> <Plug><cpath> <SID>Find('','')
                              if get(g:, 'fireplace_no_maps') | return | endif
                              call s:map('c', '<C-R><C-F>', '<Plug><cfile>')
                              call s:map('c', '<C-R><C-P>', '<Plug><cpath>')
                              call s:map('n', 'gf',         '<Plug>FireplaceEditFile',    '<unique>')
                              call s:map('n', '<C-W>f',     '<Plug>FireplaceSplitFile',   '<unique>')
                              call s:map('n', '<C-W><C-F>', '<Plug>FireplaceSplitFile',   '<unique>')
                              call s:map('n', '<C-W>gf',    '<Plug>FireplaceTabeditFile', '<unique>')
                            endfunction
                            
    1              0.000004 augroup fireplace_go_to_file
    1              0.000150   autocmd!
    1              0.000011   autocmd FileType clojure call s:set_up_go_to_file()
    1              0.000002 augroup END
                            
                            " Section: Formatting
                            
    1              0.000005 function! fireplace#format(lnum, count, char) abort
                              if mode() =~# '[iR]'
                                return -1
                              endif
                              let reg_save = @@
                              let sel_save = &selection
                              let cb_save = &clipboard
                              try
                                set selection=inclusive clipboard-=unnamed clipboard-=unnamedplus
                                silent exe "normal! " . string(a:lnum) . "ggV" . string(a:count-1) . "jy"
                                let response = fireplace#message({'op': 'format-code', 'code': @@})[0]
                                if !empty(get(response, 'formatted-code'))
                                  let @@ = get(response, 'formatted-code')
                                  if @@ !~# '^\n*$'
                                    normal! gvp
                                  endif
                                endif
                              finally
                                let @@ = reg_save
                                let &selection = sel_save
                                let &clipboard = cb_save
                              endtry
                            endfunction
                            
    1              0.000003 augroup fireplace_formatting
    1              0.000126   autocmd!
    1              0.000010   autocmd FileType clojure
                                    \ setlocal formatexpr=fireplace#format(v:lnum,v:count,v:char)
    1              0.000002 augroup END
                            
                            " Section: Documentation
                            
    1              0.000005 function! s:Lookup(ns, macro, arg) abort
                              try
                                let response = s:eval('('.a:ns.'/'.a:macro.' '.a:arg.')')
                                call s:output_response(response)
                              catch /^Clojure:/
                              catch /.*/
                                echohl ErrorMSG
                                echo v:exception
                                echohl None
                              endtry
                              return ''
                            endfunction
                            
    1              0.000004 function! s:inputlist(label, entries) abort
                              let choices = [a:label]
                              for i in range(len(a:entries))
                                let choices += [printf('%2d. %s', i+1, a:entries[i])]
                              endfor
                              let choice = inputlist(choices)
                              if choice
                                return a:entries[choice-1]
                              else
                                return ''
                              endif
                            endfunction
                            
    1              0.000004 function! s:Doc(symbol) abort
                              let info = fireplace#info(a:symbol)
                              if has_key(info, 'ns') && has_key(info, 'name')
                                echo info.ns . '/' . info.name
                              elseif has_key(info, 'ns')
                                echo info.ns
                              elseif has_key(info, 'name')
                                echo info.name
                              endif
                            
                              if get(info, 'forms-str', 'nil') !=# 'nil'
                                echo info['forms-str']
                              endif
                            
                              if get(info, 'arglists-str', '') !=# ''
                                echo info['arglists-str']
                              endif
                            
                              if get(info, 'special-form', 'nil') !=# 'nil'
                                echo "Special Form"
                            
                                if has_key(info, 'url')
                                  if !empty(get(info, 'url', ''))
                                    echo '  Please see http://clojure.org/' . info.url
                                  else
                                    echo '  Please see http://clojure.org/special_forms#' . info.name
                                  endif
                                endif
                            
                              elseif get(info, 'macro', '') !=# ''
                                echo "Macro"
                              endif
                            
                              if !empty(get(info, 'doc', ''))
                                echo '  ' . info.doc
                              endif
                            
                              return ''
                            endfunction
                            
    1              0.000003 function! s:K() abort
                              let word = expand('<cword>')
                              let java_candidate = matchstr(word, '^\%(\w\+\.\)*\u\l[[:alnum:]$]*\ze\%(\.\|\/\w\+\)\=$')
                              if java_candidate !=# ''
                                return 'Javadoc '.java_candidate
                              else
                                return 'Doc '.word
                              endif
                            endfunction
                            
    1              0.000015 nnoremap <Plug>FireplaceK :<C-R>=<SID>K()<CR><CR>
    1              0.000011 nnoremap <Plug>FireplaceSource :Source <C-R><C-W><CR>
                            
    1              0.000003 function! s:set_up_doc() abort
                              command! -buffer -nargs=1 FindDoc :exe s:Lookup(s:repl_ns(), 'find-doc', printf('#"%s"', <q-args>))
                              command! -buffer -bar -nargs=1 Javadoc :exe s:Lookup('clojure.java.javadoc', 'javadoc', <q-args>)
                              command! -buffer -bar -nargs=1 -complete=customlist,fireplace#eval_complete Doc     :exe s:Doc(<q-args>)
                              command! -buffer -bar -nargs=1 -complete=customlist,fireplace#eval_complete Source  :exe s:Lookup(s:repl_ns(), 'source', <q-args>)
                              setlocal keywordprg=:Doc
                            
                              if get(g:, 'fireplace_no_maps') | return | endif
                              call s:map('n', 'K', '<Plug>FireplaceK', '<unique>')
                              call s:map('n', '[d', '<Plug>FireplaceSource')
                              call s:map('n', ']d', '<Plug>FireplaceSource')
                            endfunction
                            
    1              0.000004 augroup fireplace_doc
    1              0.000083   autocmd!
    1              0.000009   autocmd FileType clojure call s:set_up_doc()
    1              0.000002 augroup END
                            
                            " Section: Tests
                            
    1              0.000005 function! fireplace#capture_test_run(expr, ...) abort
                              let expr = '(try'
                                    \ . ' ' . (a:0 ? a:1 : '')
                                    \ . ' (clojure.core/require ''clojure.test)'
                                    \ . ' (clojure.core/binding [clojure.test/report (fn [m]'
                                    \ .  ' (clojure.core/case (:type m)'
                                    \ .    ' (:fail :error)'
                                    \ .    ' (clojure.core/let [{file :file line :line test :name} (clojure.core/meta (clojure.core/last clojure.test/*testing-vars*))]'
                                    \ .      ' (clojure.test/with-test-out'
                                    \ .        ' (clojure.test/inc-report-counter (:type m))'
                                    \ .        ' (clojure.core/println (clojure.string/join "\t" [file line (clojure.core/name (:type m)) test]))'
                                    \ .        ' (clojure.core/when (clojure.core/seq clojure.test/*testing-contexts*) (clojure.core/println (clojure.test/testing-contexts-str)))'
                                    \ .        ' (clojure.core/when-let [message (:message m)] (clojure.core/println message))'
                                    \ .        ' (clojure.core/println "expected:" (clojure.core/pr-str (:expected m)))'
                                    \ .        ' (clojure.core/println "  actual:" (clojure.core/pr-str (:actual m)))))'
                                    \ .    ' ((.getRawRoot #''clojure.test/report) m)))]'
                                    \ . ' ' . a:expr . ')'
                                    \ . ' (catch Exception e'
                                    \ . '   (clojure.core/println (clojure.core/str e))'
                                    \ . '   (clojure.core/println (clojure.string/join "\n" (.getStackTrace e)))))'
                              let qflist = []
                              let response = s:eval(expr, {'session': 0})
                              if !has_key(response, 'out')
                                call setqflist(fireplace#quickfix_for(get(response, 'stacktrace', [])))
                                return s:output_response(response)
                              endif
                              for line in split(response.out, "\r\\=\n")
                                if line =~# '\t.*\t.*\t'
                                  let entry = {'text': line}
                                  let [resource, lnum, type, name] = split(line, "\t", 1)
                                  let entry.lnum = lnum
                                  let entry.type = (type ==# 'fail' ? 'W' : 'E')
                                  let entry.text = name
                                  if resource ==# 'NO_SOURCE_FILE'
                                    let resource = ''
                                    let entry.lnum = 0
                                  endif
                                  let entry.filename = fireplace#findresource(resource, fireplace#path())
                                  if empty(entry.filename)
                                    let entry.lnum = 0
                                  endif
                                else
                                  let entry = s:qfmassage(line, fireplace#path())
                                endif
                                call add(qflist, entry)
                              endfor
                              call setqflist(qflist)
                              let was_qf = &buftype ==# 'quickfix'
                              botright cwindow
                              if &buftype ==# 'quickfix' && !was_qf
                                wincmd p
                              endif
                              for winnr in range(1, winnr('$'))
                                if getwinvar(winnr, '&buftype') ==# 'quickfix'
                                  call setwinvar(winnr, 'quickfix_title', a:expr)
                                  return
                                endif
                              endfor
                            endfunction
                            
    1              0.000004 function! s:RunTests(bang, count, ...) abort
                              if &autowrite || &autowriteall
                                silent! wall
                              endif
                              if a:count < 0
                                let pre = ''
                                if a:0
                                  let expr = ['(clojure.test/run-all-tests #"'.join(a:000, '|').'")']
                                else
                                  let expr = ['(clojure.test/run-all-tests)']
                                endif
                              else
                                if a:0 && a:000 !=# [fireplace#ns()]
                                  let args = a:000
                                else
                                  let args = [fireplace#ns()]
                                  if a:count
                                    let pattern = '^\s*(def\k*\s\+\(\h\k*\)'
                                    let line = search(pattern, 'bcWn')
                                    if line
                                      let args[0] .= '/' . matchlist(getline(line), pattern)[1]
                                    endif
                                  endif
                                endif
                                let reqs = map(copy(args), '"''".v:val')
                                let pre = '(clojure.core/require '.substitute(join(reqs, ' '), '/\k\+', '', 'g').' :reload) '
                                let expr = []
                                let vars = filter(copy(reqs), 'v:val =~# "/"')
                                let nses = filter(copy(reqs), 'v:val !~# "/"')
                                if len(vars) == 1
                                  call add(expr, '(clojure.test/test-vars [#' . vars[0] . '])')
                                elseif !empty(vars)
                                  call add(expr, join(['(clojure.test/test-vars'] + map(vars, '"#".v:val'), ' ').')')
                                endif
                                if !empty(nses)
                                  call add(expr, join(['(clojure.test/run-tests'] + nses, ' ').')')
                                endif
                              endif
                              call fireplace#capture_test_run(join(expr, ' '), pre)
                              echo join(expr, ' ')
                            endfunction
                            
    1              0.000003 function! s:set_up_tests() abort
                              command! -buffer -bar -bang -range=0 -nargs=*
                                    \ -complete=customlist,fireplace#ns_complete RunTests
                                    \ call s:RunTests(<bang>0, <line1> == 0 ? -1 : <count>, <f-args>)
                              command! -buffer -bang -nargs=* RunAllTests
                                    \ call s:RunTests(<bang>0, -1, <f-args>)
                            endfunction
                            
    1              0.000006 augroup fireplace_tests
    1              0.000054   autocmd!
    1              0.000009   autocmd FileType clojure call s:set_up_tests()
    1              0.000005 augroup END

SCRIPT  /Users/kenji/.vim/plugged/vim-leiningen/plugin/salve.vim
Sourced 1 time
Total time:   0.000784
 Self time:   0.000784

count  total (s)   self (s)
                            " Location: plugin/salve.vim
                            " Author:   Tim Pope <http://tpo.pe/>
                            
    1              0.000010 if exists('g:loaded_salve')
                              finish
                            endif
    1              0.000005 let g:loaded_salve = 1
                            
    1              0.000004 if !exists('g:classpath_cache')
    1              0.000004   let g:classpath_cache = '~/.cache/vim/classpath'
    1              0.000002 endif
                            
    1              0.000025 if !isdirectory(expand(g:classpath_cache))
                              call mkdir(expand(g:classpath_cache), 'p')
                            endif
                            
    1              0.000005 function! s:portfile() abort
                              if !exists('b:salve')
                                return ''
                              endif
                            
                              let root = b:salve.root
                              let portfiles = [root.'/.nrepl-port', root.'/target/repl-port', root.'/target/repl/repl-port']
                            
                              for f in portfiles
                                if getfsize(f) > 0
                                  return f
                                endif
                              endfor
                              return ''
                            endfunction
                            
    1              0.000004 function! s:repl(background, args) abort
                              let args = empty(a:args) ? '' : ' ' . a:args
                              let portfile = s:portfile()
                              if a:background && !empty(portfile)
                                return
                              endif
                              let cd = exists('*haslocaldir') && haslocaldir() ? 'lcd' : 'cd'
                              let cwd = getcwd()
                              try
                                let cmd = b:salve.repl_cmd
                                execute cd fnameescape(b:salve.root)
                                if exists(':Start') == 2
                                  execute 'Start'.(a:background ? '!' : '') '-title='
                                        \ . escape(fnamemodify(b:salve.root, ':t') . ' repl', ' ')
                                        \ cmd.args
                                  if get(get(g:, 'dispatch_last_start', {}), 'handler', 'headless') ==# 'headless'
                                    return
                                  endif
                                elseif a:background
                                  echohl WarningMsg
                                  echomsg "Can't start background console without dispatch.vim"
                                  echohl None
                                  return
                                elseif has('win32')
                                  execute '!start '.cmd.args
                                else
                                  execute '!'.cmd.args
                                  return
                                endif
                              finally
                                execute cd fnameescape(cwd)
                              endtry
                            
                              let i = 0
                              while empty(portfile) && i < 300 && !getchar(0)
                                let i += 1
                                sleep 100m
                                let portfile = s:portfile()
                              endwhile
                            endfunction
                            
    1              0.000004 function! s:connect(autostart) abort
                              if !exists('b:salve') || !exists(':FireplaceConnect')
                                return {}
                              endif
                              let portfile = s:portfile()
                              if exists('g:salve_auto_start_repl') && a:autostart && empty(portfile) && exists(':Start') ==# 2
                                call s:repl(1, '')
                                let portfile = s:portfile()
                              endif
                            
                              return empty(portfile) ? {} :
                                    \ fireplace#register_port_file(portfile, b:salve.root)
                            endfunction
                            
    1              0.000003 function! s:detect(file) abort
                              if !exists('b:salve')
                                let root = simplify(fnamemodify(a:file, ':p:s?[\/]$??'))
                                if !isdirectory(fnamemodify(root, ':h'))
                                  return ''
                                endif
                                let previous = ""
                                while root !=# previous
                                  if filereadable(root . '/project.clj') && join(readfile(root . '/project.clj', '', 50)) =~# '(\s*defproject\%(\s*{{\)\@!'
                                    let b:salve = { "local_manifest": root.'/project.clj',
                                                      \ "global_manifest": expand('~/.lein/profiles.clj'),
                                                      \ "root": root,
                                                      \ "compiler": "lein",
                                                      \ "repl_cmd": "lein repl",
                                                      \ "classpath_cmd": "lein -o classpath",
                                                      \ "start_cmd": "lein run" }
                                    let b:java_root = root
                                    break
                                  elseif filereadable(root . '/build.boot')
                                    if $BOOT_HOME
                                      let boot_home = $BOOT_HOME
                                    else
                                      let boot_home = expand('~/.boot')
                                    endif
                                    let b:salve = { "local_manifest": root.'/build.boot',
                                                      \ "global_manifest": boot_home.'/.profile.boot',
                                                      \ "root": root,
                                                      \ "compiler": "boot",
                                                      \ "repl_cmd": "boot repl",
                                                      \ "classpath_cmd": "boot show --fake-classpath",
                                                      \ "start_cmd": "boot repl -s" }
                                    let b:java_root = root
                                    break
                                  endif
                                  let previous = root
                                  let root = fnamemodify(root, ':h')
                                endwhile
                              endif
                              return exists('b:salve')
                            endfunction
                            
    1              0.000004 function! s:split(path) abort
                              return split(a:path, has('win32') ? ';' : ':')
                            endfunction
                            
    1              0.000003 function! s:scrape_path(root) abort
                              let cd = exists('*haslocaldir') && haslocaldir() ? 'lcd' : 'cd'
                              let cwd = getcwd()
                              try
                                execute cd fnameescape(a:root)
                                let path = matchstr(system(b:salve.classpath_cmd), "[^\n]*\\ze\n*$")
                                if v:shell_error
                                  return []
                                endif
                                return s:split(path)
                              finally
                                execute cd fnameescape(cwd)
                              endtry
                            endfunction
                            
    1              0.000005 function! s:path() abort
                              let conn = s:connect(0)
                            
                              let projts = getftime(b:salve.local_manifest)
                              let profts = getftime(b:salve.global_manifest)
                              let cache = expand(g:classpath_cache . '/') . substitute(b:salve.root, '[:\/]', '%', 'g')
                            
                              let ts = getftime(cache)
                              if ts > projts && ts > profts
                                let path = split(get(readfile(cache), 0, ''), ',')
                            
                              elseif has_key(conn, 'path')
                                let ts = +get(conn.eval('(.getStartTime (java.lang.management.ManagementFactory/getRuntimeMXBean))', {'session': '', 'ns': 'user'}), 'value', '-2000')[0:-4]
                                if ts > projts && ts > profts
                                  let response = conn.eval(
                                        \ '[(System/getProperty "path.separator") (or (System/getProperty "fake.class.path") (System/getProperty "java.class.path"))]',
                                        \ {'session': '', 'ns': 'user'})
                                  let path = split(eval(response.value[5:-2]), response.value[2])
                                  call writefile([join(path, ',')], cache)
                                endif
                              endif
                            
                              if !exists('path')
                                let path = s:scrape_path(b:salve.root)
                                if empty(path)
                                  let path = map(['test', 'src', 'dev-resources', 'resources'], 'b:salve.root."/".v:val')
                                endif
                                call writefile([join(path, ',')], cache)
                              endif
                            
                              return path
                            endfunction
                            
    1              0.000003 function! s:activate() abort
                              if !exists('b:salve')
                                return
                              endif
                              command! -buffer -bar -bang -nargs=* Console call s:repl(<bang>0, <q-args>)
                              execute "compiler ".b:salve.compiler
                              let &l:errorformat .= ',' . escape('chdir '.b:salve.root, '\,')
                              let &l:errorformat .= ',' . escape('classpath,'.join(s:path()), '\,')
                            endfunction
                            
    1              0.000003 function! s:projectionist_detect() abort
                              if !s:detect(get(g:, 'projectionist_file', get(b:, 'projectionist_file', '')))
                                return
                              endif
                              let mypaths = map(filter(copy(s:path()),
                                    \ 'strpart(v:val, 0, len(b:salve.root)) ==# b:salve.root'),
                                    \ 'v:val[strlen(b:salve.root)+1:-1]')
                              let projections = {}
                              let main = []
                              let test = []
                              let spec = []
                              for path in mypaths
                                let projections[path.'/*'] = {'type': 'resource'}
                                if path !~# 'target\|resources'
                                  let projections[path.'/*.clj'] = {'type': 'source', 'template': ['(ns {dot|hyphenate})']}
                                  let projections[path.'/*.cljc'] = {'type': 'source', 'template': ['(ns {dot|hyphenate})']}
                                  let projections[path.'/*.java'] = {'type': 'source'}
                                endif
                                if path =~# 'resource'
                                elseif path =~# 'test'
                                  let test += [path]
                                elseif path =~# 'spec'
                                  let spec += [path]
                                elseif path =~# 'src'
                                  let main += [path]
                                endif
                              endfor
                              let projections['*'] = {'start': b:salve.start_cmd}
                              call projectionist#append(b:salve.root, projections)
                              let projections = {}
                            
                              let proj = {'type': 'test', 'alternate': map(copy(main), 'v:val."/{}.clj"')}
                              let proj = {'type': 'test', 'alternate': map(copy(main), 'v:val."/{}.cljc"')}
                              for path in test
                                let projections[path.'/*_test.clj'] = proj
                                let projections[path.'/*_test.cljc'] = proj
                                let projections[path.'/**/test/*.clj'] = proj
                                let projections[path.'/**/test/*.cljc'] = proj
                                let projections[path.'/**/t_*.clj'] = proj
                                let projections[path.'/**/t_*.cljc'] = proj
                                let projections[path.'/**/test_*.clj'] = proj
                                let projections[path.'/**/test_*.cljc'] = proj
                                let projections[path.'/*.clj'] = {'dispatch': ':RunTests {dot|hyphenate}'}
                                let projections[path.'/*.cljc'] = {'dispatch': ':RunTests {dot|hyphenate}'}
                              endfor
                              for path in spec
                                let projections[path.'/*_spec.clj'] = proj
                                let projections[path.'/*_spec.cljc'] = proj
                              endfor
                            
                              for path in main
                                let proj = {'type': 'main', 'alternate': map(copy(spec), 'v:val."/{}_spec.clj"')}
                                let proj = {'type': 'main', 'alternate': map(copy(spec), 'v:val."/{}_spec.cljc"')}
                                for tpath in test
                                  call extend(proj.alternate, [
                                        \ tpath.'/{}_test.clj',
                                        \ tpath.'/{}_test.cljc',
                                        \ tpath.'/{dirname}/test/{basename}.clj',
                                        \ tpath.'/{dirname}/test/{basename}.cljc',
                                        \ tpath.'/{dirname}/t_{basename}.clj',
                                        \ tpath.'/{dirname}/t_{basename}.cljc',
                                        \ tpath.'/{dirname}/t_{basename}.clj',
                                        \ tpath.'/{dirname}/t_{basename}.cljc'])
                                endfor
                                let projections[path.'/*.clj'] = proj
                                let projections[path.'/*.cljc'] = proj
                              endfor
                              call projectionist#append(b:salve.root, projections)
                            endfunction
                            
    1              0.000006 augroup salve
    1              0.000176   autocmd!
    1              0.000014   autocmd User FireplacePreConnect call s:connect(1)
    1              0.000011   autocmd FileType clojure
                                    \ if s:detect(expand('%:p')) |
                                    \  let &l:path = join(s:path(), ',') |
                                    \ endif
    1              0.000009   autocmd User ProjectionistDetect call s:projectionist_detect()
    1              0.000007   autocmd User ProjectionistActivate call s:activate()
    1              0.000033   autocmd BufReadPost *
                                    \ if !exists(':ProjectDo') && s:detect(expand('%:p')) |
                                    \  call s:activate() |
                                    \ endif
    1              0.000005 augroup END

SCRIPT  /Users/kenji/.vim/plugged/vim-slamhound/plugin/slamhound.vim
Sourced 1 time
Total time:   0.000225
 Self time:   0.000225

count  total (s)   self (s)
                            " vim-slamhound
                            "
                            " Author:   guns <self@sungpae.com>
                            " License:  Eclipse Public License
                            " Homepage: https://github.com/guns/vim-slamhound
                            " Requires: slamhound - https://github.com/technomancy/slamhound
                            "           fireplace.vim - https://github.com/tpope/vim-fireplace
                            
    1              0.000008 augroup slamhound
    1              0.000180         autocmd!
    1              0.000019         autocmd FileType clojure
                                            \ command! -bar -buffer Slamhound
                                            \ if &modified |
                                            \       echom "Buffer contains unsaved changes!" |
                                            \ else |
                                            \       call slamhound#reconstruct(expand('%'), &textwidth) |
                                            \ endif
    1              0.000007 augroup END

SCRIPT  /Users/kenji/.vim/plugged/vim-cljfmt/plugin/cljfmt.vim
Sourced 1 time
Total time:   0.001171
 Self time:   0.001171

count  total (s)   self (s)
                            " cljfmt.vim - A tool for formatting Clojure code
                            " Maintainer:  Venantius <http://venanti.us>
                            " Version:     0.6
                            
    1              0.000006 let g:clj_fmt_required = 0
    1              0.000006 let fireplace#skip = 'synIDattr(synID(line("."),col("."),1),"name") =~? "comment\\|string\\|char\\|regexp"'
                            
    1              0.000006 function! s:RequireCljfmt()
                                let l:cmd = "(require 'cljfmt.core)"
                                try
                                    silent! call fireplace#session_eval(l:cmd)
                                    return 1
                                catch /^Clojure: class java.io.FileNotFoundException*/
                                    echom "vim-cljfmt: Could not locate cljfmt/core__init.class or cljfmt/core.clj on classpath."
                                    return 0
                                catch /^Fireplace:.*/
                                    echom v:exception
                                    return 0
                                endtry
                            endfunction
                            
    1              0.000002 function! s:GetCurrentBufferContents()
                                " Escape newlines
                                let l:temp = []
                                for l:line in getline(1, '$')
                                    let l:line = substitute(l:line, '\', '\\\\', 'g')
                                    call add(l:temp, l:line)
                                endfor
                                let l:escaped_buffer_contents = join(l:temp, '\n')
                            
                                " Take care of escaping quotes
                                let l:escaped_buffer_contents = substitute(l:escaped_buffer_contents, '"', '\\"', 'g')
                                return escaped_buffer_contents
                            endfunction
                            
    1              0.000002 function! s:GetReformatString(CurrentBufferContents)
                                return '(print (cljfmt.core/reformat-string "' . a:CurrentBufferContents . '" nil))'
                            endfunction
                            
    1              0.000002 function! s:FilterOutput(lines, ...)
                                let l:output = []
                                let l:join_result = 1
                            
                                if a:0 == 1 && !a:1
                                    let l:join_result = 0
                                endif
                            
                                for line in a:lines
                                    if line != "No matching autocommands" && line != "Keine passenden Autokommandos"
                                        call add(l:output, line)
                                    endif
                                endfor
                                if l:join_result
                                    return join(l:output, "\n")
                                else
                                    return l:output
                                endif
                            endfunction
                            
    1              0.000002 function! s:GetFormattedFile()
                                let l:bufcontents = s:GetCurrentBufferContents()
                                redir => l:cljfmt_output
                                try
                                    silent! call fireplace#session_eval(s:GetReformatString(l:bufcontents))
                                catch /^Clojure:.*/
                                    redir END
                                    throw "fmterr"
                                catch
                                  redir END
                                  throw v:exception
                                endtry
                                redir END
                                return s:FilterOutput(split(l:cljfmt_output, "\n"))
                            endfunction
                            
    1              0.000567 function! cljfmt#Format()
                                let g:clj_fmt_required = s:RequireCljfmt()
                            
                                " If cljfmt.core has already been required, or was successfully imported
                                " above
                                if g:clj_fmt_required
                                    " save cursor position and many other things
                                    let l:curw = winsaveview()
                            
                                    try
                                        let formatted_output = s:GetFormattedFile()
                                        :0,substitute/\_.*/\=formatted_output/g
                                    catch "fmterr"
                                        echoerr "Cljfmt: Failed to format file, likely due to a syntax error."
                                    endtry
                            
                                    " restore our cursor/windows positions
                                    call winrestview(l:curw)
                                endif
                            endfunction
                            
    1              0.000004 function! cljfmt#AutoFormat()
                                silent! write
                                if expand('%:t') != "project.clj" && expand('%:t') != "profiles.clj"
                                    silent! call cljfmt#Format()
                                endif
                            endfunction
                            
    1              0.000004 function! s:CljfmtRange(bang, line1, line2, count, args) abort
                              if a:args !=# ''
                                let expr = a:args
                              else
                                if a:count ==# 0
                                  let open = '[[{(]'
                                  let close = '[]})]'
                                  let [line1, col1] = searchpairpos(open, '', close, 'bcrn', g:fireplace#skip)
                                  let [line2, col2] = searchpairpos(open, '', close, 'rn', g:fireplace#skip)
                                  if !line1 && !line2
                                    let [line1, col1] = searchpairpos(open, '', close, 'brn', g:fireplace#skip)
                                    let [line2, col2] = searchpairpos(open, '', close, 'crn', g:fireplace#skip)
                                  endif
                                  while col1 > 1 && getline(line1)[col1-2] =~# '[#''`~@]'
                                    let col1 -= 1
                                  endwhile
                                else
                                  let line1 = a:line1
                                  let line2 = a:line2
                                  let col1 = 1
                                  let col2 = strlen(getline(line2))
                                endif
                                if !line1 || !line2
                                  return ''
                                endif
                                let expr = getline(line1)[col1-1 : -1] . "\n"
                                        \ . join(map(getline(line1+1, line2-1), 'v:val . "\n"'))
                                        \ . getline(line2)[0 : col2-1]
                            
                              let g:clj_fmt_required = s:RequireCljfmt()
                              if g:clj_fmt_required
                                  let escaped_contents = substitute(expr, '"', '\\"', 'g')
                                  let l:preformatted = s:GetReformatString(escaped_contents)
                            
                                  redir => l:formatted_content
                                  silent! call fireplace#session_eval(l:preformatted)
                                  redir END
                            
                                  let content = s:FilterOutput(split(l:formatted_content, "\n"), 0)
                                  exe line1.','.line2.'delete _'
                                  call append(a:line1 - 1, content)
                                  exe a:line1
                              endif
                              return ''
                            endfunction
                            
    1              0.000008 augroup vim-cljfmt
    1              0.000195     autocmd!
                            
                                " code formatting on save
    1              0.000011     if get(g:, "clj_fmt_autosave", 1)
    1              0.000013         autocmd BufWritePre *.clj call cljfmt#AutoFormat()
    1              0.000007         autocmd BufWritePre *.cljc call cljfmt#AutoFormat()
    1              0.000006         autocmd BufWritePre *.cljs call cljfmt#AutoFormat()
                            
    1              0.000002     endif
    1              0.000002 augroup END
                            
    1              0.000009 command! Cljfmt call cljfmt#Format()
    1              0.000004 command! CljfmtRequire call s:RequireCljfmt()
    1              0.000020 command! -buffer -bang -range=0 -nargs=? CljfmtRange :exe s:CljfmtRange(<bang>0, <line1>, <line2>, <count>, <q-args>)

SCRIPT  /Users/kenji/.vim/plugged/paredit.vim/plugin/paredit.vim
Sourced 1 time
Total time:   0.000026
 Self time:   0.000026

count  total (s)   self (s)
                            " paredit.vim:
                            "               Paredit mode for Slimv
                            " Version:      0.9.12
                            " Last Change:  20 Nov 2013
                            " Maintainer:   Tamas Kovacs <kovisoft at gmail dot com>
                            " License:      This file is placed in the public domain.
                            "               No warranty, express or implied.
                            "               *** ***   Use At-Your-Own-Risk!   *** ***
                            "
                            " =====================================================================
                            "
                            "  Load Once:
    1              0.000015 if &cp || exists( 'g:paredit_loaded' )
    1              0.000003     finish

SCRIPT  /Users/kenji/.vim/plugged/vim-salve/plugin/salve.vim
Sourced 1 time
Total time:   0.000017
 Self time:   0.000017

count  total (s)   self (s)
                            " Location: plugin/salve.vim
                            " Author:   Tim Pope <http://tpo.pe/>
                            
    1              0.000009 if exists('g:loaded_salve')
    1              0.000003   finish

SCRIPT  /Users/kenji/.vim/plugged/vim-clojure-static/ftplugin/clojure.vim
Sourced 3 times
Total time:   0.000680
 Self time:   0.000680

count  total (s)   self (s)
                            " Vim filetype plugin file
                            " Language:     Clojure
                            " Author:       Meikel Brandmeyer <mb@kotka.de>
                            "
                            " Maintainer:   Sung Pae <self@sungpae.com>
                            " URL:          https://github.com/guns/vim-clojure-static
                            " License:      Same as Vim
                            " Last Change:  %%RELEASE_DATE%%
                            
    3              0.000027 if exists("b:did_ftplugin")
                            	finish
                            endif
    3              0.000009 let b:did_ftplugin = 1
                            
    3              0.000016 let s:cpo_save = &cpo
    3              0.000017 set cpo&vim
                            
    3              0.000008 let b:undo_ftplugin = 'setlocal iskeyword< define< formatoptions< comments< commentstring< lispwords<'
                            
    3              0.000099 setlocal iskeyword+=?,-,*,!,+,/,=,<,>,.,:,$
                            
                            " There will be false positives, but this is better than missing the whole set
                            " of user-defined def* definitions.
    3              0.000012 setlocal define=\\v[(/]def(ault)@!\\S*
                            
                            " Remove 't' from 'formatoptions' to avoid auto-wrapping code.
    3              0.000013 setlocal formatoptions-=t
                            
                            " Lisp comments are routinely nested (e.g. ;;; SECTION HEADING)
    3              0.000009 setlocal comments=n:;
    3              0.000009 setlocal commentstring=;\ %s
                            
                            " Specially indented symbols from clojure.core and clojure.test.
                            "
                            " Clojure symbols are indented in the defn style when they:
                            "
                            "   * Define vars and anonymous functions
                            "   * Create new lexical scopes or scopes with altered environments
                            "   * Create conditional branches from a predicate function or value
                            "
                            " The arglists for these functions are generally in the form of [x & body];
                            " Functions that accept a flat list of forms do not treat the first argument
                            " specially and hence are not indented specially.
                            "
                            " -*- LISPWORDS -*-
                            " Generated from https://github.com/guns/vim-clojure-static/blob/%%RELEASE_TAG%%/clj/src/vim_clojure_static/generate.clj
    3              0.000034 setlocal lispwords=as->,binding,bound-fn,case,catch,cond->,cond->>,condp,def,definline,definterface,defmacro,defmethod,defmulti,defn,defn-,defonce,defprotocol,defrecord,defstruct,deftest,deftest-,deftype,doseq,dotimes,doto,extend,extend-protocol,extend-type,fn,for,if,if-let,if-not,if-some,let,letfn,locking,loop,ns,proxy,reify,set-test,testing,when,when-first,when-let,when-not,when-some,while,with-bindings,with-in-str,with-local-vars,with-open,with-precision,with-redefs,with-redefs-fn,with-test
                            
                            " Provide insert mode completions for special forms and clojure.core. As
                            " 'omnifunc' is set by popular Clojure REPL client plugins, we also set
                            " 'completefunc' so that the user has some form of completion available when
                            " 'omnifunc' is set and no REPL connection exists.
    9              0.000020 for s:setting in ['omnifunc', 'completefunc']
    6              0.000038 	if exists('&' . s:setting) && empty(eval('&' . s:setting))
    6              0.000039 		execute 'setlocal ' . s:setting . '=clojurecomplete#Complete'
    6              0.000022 		let b:undo_ftplugin .= ' | setlocal ' . s:setting . '<'
    6              0.000005 	endif
    6              0.000006 endfor
                            
                            " Take all directories of the CLOJURE_SOURCE_DIRS environment variable
                            " and add them to the path option.
                            "
                            " This is a legacy option for VimClojure users.
    3              0.000017 if exists('$CLOJURE_SOURCE_DIRS')
                            	for s:dir in split($CLOJURE_SOURCE_DIRS, (has("win32") || has("win64")) ? ';' : ':')
                            		let s:dir = fnameescape(s:dir)
                            		" Whitespace escaping for Windows
                            		let s:dir = substitute(s:dir, '\', '\\\\', 'g')
                            		let s:dir = substitute(s:dir, '\ ', '\\ ', 'g')
                            		execute "setlocal path+=" . s:dir . "/**"
                            	endfor
                            	let b:undo_ftplugin .= ' | setlocal path<'
                            endif
                            
                            " Skip brackets in ignored syntax regions when using the % command
    3              0.000008 if exists('loaded_matchit')
    3              0.000007 	let b:match_words = &matchpairs
    3              0.000006 	let b:match_skip = 's:comment\|string\|regex\|character'
    3              0.000008 	let b:undo_ftplugin .= ' | unlet! b:match_words b:match_skip'
    3              0.000002 endif
                            
                            " Win32 can filter files in the browse dialog
    3              0.000015 if has("gui_win32") && !exists("b:browsefilter")
                            	let b:browsefilter = "Clojure Source Files (*.clj)\t*.clj\n" .
                            	                   \ "ClojureScript Source Files (*.cljs)\t*.cljs\n" .
                            	                   \ "Java Source Files (*.java)\t*.java\n" .
                            	                   \ "All Files (*.*)\t*.*\n"
                            	let b:undo_ftplugin .= ' | unlet! b:browsefilter'
                            endif
                            
    3              0.000020 let &cpo = s:cpo_save
                            
    3              0.000009 unlet! s:cpo_save s:setting s:dir
                            
                            " vim:sts=8:sw=8:ts=8:noet

SCRIPT  /Users/kenji/.vim/plugged/slimv/ftplugin/clojure/slimv-clojure.vim
Sourced 3 times
Total time:   0.040552
 Self time:   0.005446

count  total (s)   self (s)
                            " slimv-clojure.vim:
                            "               Clojure filetype plugin for Slimv
                            " Version:      0.9.13
                            " Last Change:  04 May 2014
                            " Maintainer:   Tamas Kovacs <kovisoft at gmail dot com>
                            " License:      This file is placed in the public domain.
                            "               No warranty, express or implied.
                            "               *** ***   Use At-Your-Own-Risk!   *** ***
                            "
                            " =====================================================================
                            "
                            "  Load Once:
    3              0.000030 if exists("b:slimv_did_ftplugin") || exists("g:slimv_disable_clojure")
    2              0.000004     finish
                            endif
                            
                            " ---------- Begin part loaded once ----------
    1              0.000003 if !exists( 'g:slimv_clojure_loaded' )
                            
    1              0.000003 let g:slimv_clojure_loaded = 1
                            
                            " Transform filename so that it will not contain spaces
    1              0.000005 function! s:TransformFilename( name )
                                if match( a:name, ' ' ) >= 0
                                    return fnamemodify( a:name , ':8' )
                                else
                                    return a:name
                                endif
                            endfunction
                            
                            " Build a Clojure startup command by adding
                            " all clojure*.jar files found to the classpath
    1              0.000002 function! s:BuildStartCmd( lisps )
                                let cp = s:TransformFilename( a:lisps[0] )
                                let i = 1
                                while i < len( a:lisps )
                                    let cp = cp . ';' . s:TransformFilename( a:lisps[i] )
                                    let i = i + 1
                                endwhile
                            
                                " Try to find swank-clojure and add it to classpath
                                let swanks = split( globpath( &runtimepath, 'swank-clojure'), '\n' )
                                if len( swanks ) > 0
                                    let cp = cp . ';' . s:TransformFilename( swanks[0] )
                                endif
                                return ['java -cp ' . cp . ' clojure.main', 'clojure']
                            endfunction
                            
                            " Try to autodetect Clojure executable
                            " Returns list [Clojure executable, Clojure implementation]
    1              0.000001 function! SlimvAutodetect( preferred )
                                " Firts try the most basic setup: everything in the path
                                if executable( 'lein' )
                                    return ['"lein repl"', 'clojure']
                                endif
                                if executable( 'cake' )
                                    return ['"cake repl"', 'clojure']
                                endif
                                if executable( 'clojure' )
                                    return ['clojure', 'clojure']
                                endif
                                let lisps = []
                                if executable( 'clojure.jar' )
                                    let lisps = ['clojure.jar']
                                endif
                                if executable( 'clojure-contrib.jar' )
                                    let lisps = lisps + 'clojure-contrib.jar'
                                endif
                                if len( lisps ) > 0
                                    return s:BuildStartCmd( lisps )
                                endif
                            
                                " Check if Clojure is bundled with Slimv
                                let lisps = split( globpath( &runtimepath, 'swank-clojure/clojure*.jar'), '\n' )
                                if len( lisps ) > 0
                                    return s:BuildStartCmd( lisps )
                                endif
                            
                                " Try to find Clojure in the PATH
                                let path = substitute( $PATH, ';', ',', 'g' )
                                let lisps = split( globpath( path, 'clojure*.jar' ), '\n' )
                                if len( lisps ) > 0
                                    return s:BuildStartCmd( lisps )
                                endif
                            
                                if g:slimv_windows
                                    " Try to find Clojure on the standard installation places
                                    let lisps = split( globpath( 'c:/*clojure*,c:/*clojure*/lib', 'clojure*.jar' ), '\n' )
                                    if len( lisps ) > 0
                                        return s:BuildStartCmd( lisps )
                                    endif
                                else
                                    " Try to find Clojure in the home directory
                                    let lisps = split( globpath( '/usr/local/bin/*clojure*', 'clojure*.jar' ), '\n' )
                                    if len( lisps ) > 0
                                        return s:BuildStartCmd( lisps )
                                    endif
                                    let lisps = split( globpath( '~/*clojure*', 'clojure*.jar' ), '\n' )
                                    if len( lisps ) > 0
                                        return s:BuildStartCmd( lisps )
                                    endif
                                endif
                            
                                return ['', '']
                            endfunction
                            
                            " Try to find out the Clojure implementation
    1              0.000002 function! SlimvImplementation()
                                if exists( 'g:slimv_impl' ) && g:slimv_impl != ''
                                    " Return Lisp implementation if defined
                                    return tolower( g:slimv_impl )
                                endif
                            
                                return 'clojure'
                            endfunction
                            
                            " Try to autodetect SWANK and build the command to load the SWANK server
    1              0.000001 function! SlimvSwankLoader()
                                " First autodetect Leiningen and Cake
                                if executable( 'lein' )
                                    if globpath( '~/.lein/plugins', 'lein-ritz*.jar' ) != ''
                                        return '"lein ritz ' . g:swank_port . '"'
                                    else
                                        return '"lein swank"'
                                    endif
                                elseif executable( 'cake' )
                                    return '"cake swank"'
                                else
                                    " Check if swank-clojure is bundled with Slimv
                                    let swanks = split( globpath( &runtimepath, 'swank-clojure/swank/swank.clj'), '\n' )
                                    if len( swanks ) == 0
                                        return ''
                                    endif
                                    let sclj = substitute( swanks[0], '\', '/', "g" )
                                    return g:slimv_lisp . ' -i "' . sclj . '" -e "(swank.swank/start-repl)" -r'
                                endif
                            endfunction
                            
                            " Filetype specific initialization for the REPL buffer
    1              0.000004 function! SlimvInitRepl()
                                set filetype=clojure
                            endfunction
                            
                            " Lookup symbol in the list of Clojure Hyperspec symbol databases
    1              0.000002 function! SlimvHyperspecLookup( word, exact, all )
                                if !exists( 'g:slimv_cljapi_loaded' )
                                    runtime ftplugin/**/slimv-cljapi.vim
                                endif
                            
                                if !exists( 'g:slimv_javadoc_loaded' )
                                    runtime ftplugin/**/slimv-javadoc.vim
                                endif
                            
                                let symbol = []
                                if exists( 'g:slimv_cljapi_db' )
                                    let symbol = SlimvFindSymbol( a:word, a:exact, a:all, g:slimv_cljapi_db,  g:slimv_cljapi_root,  symbol )
                                endif
                                if exists( 'g:slimv_javadoc_db' )
                                    let symbol = SlimvFindSymbol( a:word, a:exact, a:all, g:slimv_javadoc_db, g:slimv_javadoc_root, symbol )
                                endif
                                if exists( 'g:slimv_cljapi_user_db' )
                                    " Give a choice for the user to extend the symbol database
                                    if exists( 'g:slimv_cljapi_user_root' )
                                        let user_root = g:slimv_cljapi_user_root
                                    else
                                        let user_root = ''
                                    endif
                                    let symbol = SlimvFindSymbol( a:word, a:exact, a:all, g:slimv_cljapi_user_db, user_root, symbol )
                                endif
                                return symbol
                            endfunction
                            
                            " Implementation specific REPL initialization
    1              0.000003 function! SlimvReplInit( lisp_version )
                                " Import functions commonly used in REPL but not present when not running in repl mode
                                if a:lisp_version[0:2] >= '1.3'
                                    call SlimvSendSilent( ["(use '[clojure.repl :only (source apropos dir pst doc find-doc)])",
                                    \                      "(use '[clojure.java.javadoc :only (javadoc)])",
                                    \                      "(use '[clojure.pprint :only (pp pprint)])"] )
                                elseif a:lisp_version[0:2] >= '1.2'
                                    call SlimvSendSilent( ["(use '[clojure.repl :only (source apropos)])",
                                    \                      "(use '[clojure.java.javadoc :only (javadoc)])",
                                    \                      "(use '[clojure.pprint :only (pp pprint)])"] )
                                endif
                            endfunction
                            
                            " Source Slimv general part
    1              0.001092 runtime ftplugin/**/slimv.vim
                            
    1              0.000001 endif "!exists( 'g:slimv_clojure_loaded' )
                            " ---------- End of part loaded once ----------
                            
    1              0.003573 runtime ftplugin/**/lisp.vim
                            
                            " Must be called for each lisp buffer
    1   0.000577   0.000010 call SlimvInitBuffer()
                            
                            " Don't initiate Slimv again for this buffer
    1              0.000003 let b:slimv_did_ftplugin = 1
                            

SCRIPT  /Users/kenji/.vim/plugged/slimv/ftplugin/slimv.vim
Sourced 1 time
Total time:   0.034343
 Self time:   0.010808

count  total (s)   self (s)
                            " slimv.vim:    The Superior Lisp Interaction Mode for VIM
                            " Version:      0.9.14
                            " Last Change:  10 Jul 2017
                            " Maintainer:   Tamas Kovacs <kovisoft at gmail dot com>
                            " License:      This file is placed in the public domain.
                            "               No warranty, express or implied.
                            "               *** ***   Use At-Your-Own-Risk!   *** ***
                            "
                            " =====================================================================
                            "
                            "  Load Once:
    1              0.000018 if &cp || exists( 'g:slimv_loaded' )
                                finish
                            endif
                            
    1              0.000005 let g:slimv_loaded = 1
                            
    1              0.000003 let g:slimv_windows = 0
    1              0.000003 let g:slimv_cygwin  = 0
    1              0.000003 let g:slimv_osx     = 0
                            
    1              0.000014 if has( 'win32' ) || has( 'win95' ) || has( 'win64' ) || has( 'win16' )
                                let g:slimv_windows = 1
                            elseif has( 'win32unix' )
                                let g:slimv_cygwin = 1
                            elseif has( 'macunix' )
    1              0.000003     let g:slimv_osx = 1
    1              0.000002 endif
                            
    1              0.000419 if ( !exists( 'g:slimv_python_version' ) && has( 'python3' ) ) ||
                            \  (  exists( 'g:slimv_python_version' ) && g:slimv_python_version == 3 )
    1              0.000003     let s:py_cmd = 'python3 ' "note space
    1              0.000002     let s:pyfile_cmd = 'py3file '
    1              0.000001 else
                                let s:py_cmd = 'python '  "note space
                                let s:pyfile_cmd = 'pyfile '
                            endif
                            
                            
                            " =====================================================================
                            "  Functions used by global variable definitions
                            " =====================================================================
                            
                            " Convert Cygwin path to Windows path, if needed
    1              0.000003 function! s:Cygpath( path )
                                let path = a:path
                                if g:slimv_cygwin
                                    let path = system( 'cygpath -w ' . path )
                                    let path = substitute( path, "\n", "", "g" )
                                    let path = substitute( path, "\\", "/", "g" )
                                endif
                                return path
                            endfunction
                            
                            " Find swank.py in the Vim ftplugin directory (if not given in vimrc)
    1              0.000003 if !exists( 'g:swank_path' )
    1              0.005194     let plugins = split( globpath( &runtimepath, 'ftplugin/**/swank.py'), '\n' )
    1              0.000014     if len( plugins ) > 0
    1   0.000053   0.000029         let g:swank_path = s:Cygpath( plugins[0] )
    1              0.000003     else
                                    let g:swank_path = 'swank.py'
                                endif
    1              0.000002 endif
                            
                            " Get the filetype (Lisp dialect) used by Slimv
    1              0.000004 function! SlimvGetFiletype()
                                if &ft != ''
                                    " Return Vim filetype if defined
                                    return &ft
                                endif
                            
                                if match( tolower( g:slimv_lisp ), 'clojure' ) >= 0 || match( tolower( g:slimv_lisp ), 'clj' ) >= 0
                                    " Must be Clojure
                                    return 'clojure'
                                endif
                            
                                " We have no clue, guess its lisp
                                return 'lisp'
                            endfunction
                            
                            " Try to autodetect SWANK and build the command to start the SWANK server
    1              0.000003 function! SlimvSwankCommand()
                                if exists( 'g:slimv_swank_clojure' ) && SlimvGetFiletype() =~ '.*clojure.*'
                                    return g:slimv_swank_clojure
                                endif
                                if exists( 'g:slimv_swank_scheme' ) && SlimvGetFiletype() == 'scheme'
                                    return g:slimv_swank_scheme
                                endif
                                if exists( 'g:slimv_swank_cmd' )
                                    return g:slimv_swank_cmd
                                endif
                            
                                if g:slimv_lisp == ''
                                    let g:slimv_lisp = input( 'Enter Lisp path (or fill g:slimv_lisp in your vimrc): ', '', 'file' )
                                endif
                            
                                let cmd = SlimvSwankLoader()
                                if cmd != ''
                                    if g:slimv_windows || g:slimv_cygwin
                                        return '!start /MIN ' . cmd
                                    elseif g:slimv_osx
                                        let result = system('osascript -e "exists application \"iterm\""')
                                            if result[:-2] == 'true'
                                                let path2as = globpath( &runtimepath, 'ftplugin/**/iterm.applescript')
                                                return '!' . path2as . ' ' . cmd
                                            else
                                                " doubles quotes within 'cmd' need to become '\\\"'
                                                return '!osascript -e "tell application \"Terminal\" to do script \"' . escape(escape(cmd, '"'), '\"') . '\""'
                                            endif 
                                    elseif $STY != ''
                                        " GNU screen under Linux
                                        return "! screen -X eval 'title swank' 'screen " . cmd . "' 'select swank'"
                                    elseif $TMUX != ''
                                        " tmux under Linux
                                        return "! tmux new-window -d -n swank '" . cmd . "'"
                                    elseif $DISPLAY == ''
                                        " No X, no terminal multiplexer. Cannot run swank server.
                                        call SlimvErrorWait( 'No X server. Run Vim from screen/tmux or start SWANK server manually.' )
                                        return ''
                                    else
                                        " Must be Linux
                                        return '! SWANK_PORT=' . g:swank_port . ' xterm -iconic -e ' . cmd . ' &'
                                    endif
                                endif
                                return ''
                            endfunction
                            
                            " =====================================================================
                            "  Global variable definitions
                            " =====================================================================
                            
                            " Host name or IP address of the SWANK server
    1              0.000009 if !exists( 'g:swank_host' )
    1              0.000018     let g:swank_host = 'localhost'
    1              0.000002 endif
                            
                            " TCP port number to use for the SWANK server
    1              0.000005 if !exists( 'g:swank_port' )
    1              0.000003     let g:swank_port = 4005
    1              0.000002 endif
                            
                            " Find Lisp (if not given in vimrc)
    1              0.000007 if !exists( 'g:slimv_lisp' )
    1              0.000004     let lisp = ['', '']
    1              0.000004     if exists( 'g:slimv_preferred' )
                                    let lisp = SlimvAutodetect( tolower(g:slimv_preferred) )
                                endif
    1              0.000005     if lisp[0] == ''
    1   0.000122   0.000019         let lisp = SlimvAutodetect( '' )
    1              0.000003     endif
    1              0.000005     let g:slimv_lisp = lisp[0]
    1              0.000004     if !exists( 'g:slimv_impl' )
    1              0.000003         let g:slimv_impl = lisp[1]
    1              0.000002     endif
    1              0.000001 endif
                            
                            " Try to find out the Lisp implementation
                            " if not autodetected and not given in vimrc
    1              0.000005 if !exists( 'g:slimv_impl' )
                                let g:slimv_impl = SlimvImplementation()
                            endif
                            
                            " REPL buffer name
    1              0.000004 if !exists( 'g:slimv_repl_name' )
    1              0.000003     let g:slimv_repl_name = 'REPL'
    1              0.000002 endif
                            
                            " SLDB buffer name
    1              0.000004 if !exists( 'g:slimv_sldb_name' )
    1              0.000003     let g:slimv_sldb_name = 'SLDB'
    1              0.000002 endif
                            
                            " INSPECT buffer name
    1              0.000004 if !exists( 'g:slimv_inspect_name' )
    1              0.000003     let g:slimv_inspect_name = 'INSPECT'
    1              0.000001 endif
                            
                            " THREADS buffer name
    1              0.000004 if !exists( 'g:slimv_threads_name' )
    1              0.000003     let g:slimv_threads_name = 'THREADS'
    1              0.000001 endif
                            
                            " Shall we open REPL buffer in split window?
    1              0.000003 if !exists( 'g:slimv_repl_split' )
    1              0.000003     let g:slimv_repl_split = 1
    1              0.000001 endif
                            
                            " Wrap long lines in REPL buffer
    1              0.000003 if !exists( 'g:slimv_repl_wrap' )
    1              0.000005     let g:slimv_repl_wrap = 1
    1              0.000001 endif
                            
                            " Wrap long lines in SLDB buffer
    1              0.000003 if !exists( 'g:slimv_sldb_wrap' )
    1              0.000003     let g:slimv_sldb_wrap = 0
    1              0.000002 endif
                            
                            " Maximum number of lines echoed from the evaluated form
    1              0.000004 if !exists( 'g:slimv_echolines' )
    1              0.000003     let g:slimv_echolines = 4
    1              0.000002 endif
                            
                            " Syntax highlighting for the REPL buffer
    1              0.000004 if !exists( 'g:slimv_repl_syntax' )
    1              0.000003     let g:slimv_repl_syntax = 1
    1              0.000001 endif
                            
                            " Specifies the behaviour of insert mode <CR>, <Up>, <Down> in the REPL buffer:
                            " 1: <CR>   evaluates,      <Up>/<Down>     brings up command history
                            " 0: <C-CR> evaluates,      <C-Up>/<C-Down> brings up command history,
                            "    <CR>   opens new line, <Up>/<Down>     moves cursor up/down
    1              0.000004 if !exists( 'g:slimv_repl_simple_eval' )
    1              0.000003     let g:slimv_repl_simple_eval = 1
    1              0.000001 endif
                            
                            " Alternative value (in msec) for 'updatetime' while the REPL buffer is changing
    1              0.000004 if !exists( 'g:slimv_updatetime' )
    1              0.000003     let g:slimv_updatetime = 500
    1              0.000001 endif
                            
                            " Slimv keybinding set (0 = no keybindings)
    1              0.000005 if !exists( 'g:slimv_keybindings' )
    1              0.000003     let g:slimv_keybindings = 1
    1              0.000002 endif
                            
                            " Append Slimv menu to the global menu (0 = no menu)
    1              0.000004 if !exists( 'g:slimv_menu' )
    1              0.000003     let g:slimv_menu = 1
    1              0.000002 endif
                            
                            " Build the ctags command capable of generating lisp tags file
                            " The command can be run with execute 'silent !' . g:slimv_ctags
    1              0.000004 if !exists( 'g:slimv_ctags' )
    1   0.021185   0.000541     let ctags = split( globpath( '$vim,$vimruntime', 'ctags.exe' ), '\n' )
    1              0.000013     if len( ctags ) > 0
                                    " Remove -a option to regenerate every time
                                    let g:slimv_ctags = '"' . ctags[0] . '" -a --language-force=lisp *.lisp *.clj'
                                endif
    1              0.000002 endif
                            
                            " Name of tags file used by slimv for find-definitions
                            " If this is the empty string then no tags file is used
    1              0.000004 if !exists( 'g:slimv_tags_file' )
    1              0.000008     let g:slimv_tags_file = tempname()
    1              0.000001 endif
                            
                            " Prepend tags file to the tags list
    1              0.000003 if g:slimv_tags_file != ''
    1              0.000004     if &tags == ''
                                    let &tags=g:slimv_tags_file
                                else
    1              0.000014         let &tags=g:slimv_tags_file . ',' . &tags
    1              0.000001     endif
    1              0.000001 endif
                            
                            " Package/namespace handling
    1              0.000004 if !exists( 'g:slimv_package' )
    1              0.000005     let g:slimv_package = 1
    1              0.000001 endif
                            
                            " General timeout for various startup and connection events (seconds)
    1              0.000003 if !exists( 'g:slimv_timeout' )
    1              0.000004     let g:slimv_timeout = 20
    1              0.000001 endif
                            
                            " Use balloonexpr to display symbol description
    1              0.000003 if !exists( 'g:slimv_balloon' )
    1              0.000002     let g:slimv_balloon = 1
    1              0.000002 endif
                            
                            " Shall we use simple or fuzzy completion?
    1              0.000077 if !exists( 'g:slimv_simple_compl' )
    1              0.000003     let g:slimv_simple_compl = 0
    1              0.000001 endif
                            
                            " Custom <Leader> for the Slimv plugin
    1              0.000002 if !exists( 'g:slimv_leader' )
    1              0.000004     if exists( 'mapleader' ) && mapleader != ' '
    1              0.000002         let g:slimv_leader = mapleader
    1              0.000001     else
                                    let g:slimv_leader = ','
                                endif
    1              0.000001 endif
                            
                            " Maximum number of lines searched backwards for indenting special forms
    1              0.000005 if !exists( 'g:slimv_indent_maxlines' )
    1              0.000003     let g:slimv_indent_maxlines = 50
    1              0.000001 endif
                            
                            " Special indentation for keyword lists
    1              0.000002 if !exists( 'g:slimv_indent_keylists' )
    1              0.000001     let g:slimv_indent_keylists = 1
    1              0.000001 endif
                            
                            " Maximum length of the REPL buffer
    1              0.000002 if !exists( 'g:slimv_repl_max_len' )
    1              0.000001     let g:slimv_repl_max_len = 0
    1              0.000001 endif
                            
                            " =====================================================================
                            "  Template definitions
                            " =====================================================================
                            
    1              0.000002 if !exists( 'g:slimv_template_apropos' )
    1   0.000043   0.000031     if SlimvGetFiletype() =~ '.*clojure.*'
    1              0.000002         let g:slimv_template_apropos = '(find-doc "%1")'
    1              0.000001     else
                                    let g:slimv_template_apropos = '(apropos "%1")'
                                endif
    1              0.000001 endif
                            
                            
                            " =====================================================================
                            "  Other non-global script variables
                            " =====================================================================
                            
    1              0.000002 let s:indent = ''                                         " Most recent indentation info
    1              0.000001 let s:last_update = 0                                     " The last update time for the REPL buffer
    1              0.000002 let s:save_updatetime = &updatetime                       " The original value for 'updatetime'
    1              0.000002 let s:save_showmode = &showmode                           " The original value for 'showmode'
    1              0.000002 let s:python_initialized = 0                              " Is the embedded Python initialized?
    1              0.000002 let s:swank_version = ''                                  " SWANK server version string
    1              0.000001 let s:swank_connected = 0                                 " Is the SWANK server connected?
    1              0.000002 let s:swank_package = ''                                  " Package to use at the next SWANK eval
    1              0.000002 let s:swank_package_form = ''                             " The entire form that was used to set current package
    1              0.000001 let s:swank_form = ''                                     " Form to send to SWANK
    1              0.000002 let s:refresh_disabled = 0                                " Set this variable temporarily to avoid recursive REPL rehresh calls
    1              0.000001 let s:sldb_level = -1                                     " Are we in the SWANK debugger? -1 == no, else SLDB level
    1              0.000002 let s:break_on_exception = 0                              " Enable debugger break on exceptions (for ritz-swank)
    1              0.000001 let s:compiled_file = ''                                  " Name of the compiled file
    1              0.000001 let s:win_id = 0                                          " Counter for generating unique window id
    1              0.000001 let s:repl_buf = -1                                       " Buffer number for the REPL buffer
    1              0.000001 let s:current_buf = -1                                    " Swank action was requested from this buffer
    1              0.000001 let s:current_win = 0                                     " Swank action was requested from this window
    1              0.000002 let s:read_string_mode = 0                                " Read string mode indicator
    1              0.000001 let s:arglist_line = 0                                    " Arglist was requested in this line ...
    1              0.000001 let s:arglist_col = 0                                     " ... and column
    1              0.000002 let s:inspect_path = []                                   " Inspection path of the current object
    1              0.000002 let s:skip_sc = 'synIDattr(synID(line("."), col("."), 0), "name") =~ "[Ss]tring\\|[Cc]omment"'
                                                                                      " Skip matches inside string or comment 
    1              0.000002 let s:skip_q = 'getline(".")[col(".")-2] == "\\"'         " Skip escaped double quote characters in matches
    1              0.000002 let s:frame_def = '^\s\{0,2}\d\{1,}:'                     " Regular expression to match SLDB restart or frame identifier
    1              0.000002 let s:spec_indent = 'flet\|labels\|macrolet\|symbol-macrolet'
                                                                                      " List of symbols need special indenting
    1              0.000022 let s:spec_param = 'defmacro'                             " List of symbols with special parameter list
    1              0.000002 let s:binding_form = 'let\|let\*'                         " List of symbols with binding list
                            
                            " =====================================================================
                            "  General utility functions
                            " =====================================================================
                            
                            " Check that current SWANK version is same or newer than the given parameter
    1              0.000004 function! s:SinceVersion( ver )
                                " Before ver 2.18 SWANK version string was a date of form YYYY-MM-DD
                                if len( a:ver ) >= 8
                                    " Checking for old style version string YYYY-MM-DD
                                    if len( s:swank_version ) < 8
                                        " Current version is new style -> must be newer than the one we are checking for
                                        return 1
                                    endif
                                else
                                    " Checking for new style version string X.XX
                                    if len( s:swank_version ) >= 8
                                        " Current version is old style -> must be older than the one we are checking for
                                        return 0
                                    endif
                                endif
                                if s:swank_version >= a:ver
                                    return 1
                                else
                                    return 0
                                endif
                            endfunction 
                            
                            " Display an error message
    1              0.000002 function! SlimvError( msg )
                                echohl ErrorMsg
                                echo a:msg
                                echohl None
                            endfunction 
                            
                            " Display an error message and a question, return user response
    1              0.000002 function! SlimvErrorAsk( msg, question )
                                echohl ErrorMsg
                                let answer = input( a:msg . a:question )
                                echo ""
                                echohl None
                                return answer
                            endfunction 
                            
                            " Display an error message and wait for ENTER
    1              0.000001 function! SlimvErrorWait( msg )
                                call SlimvErrorAsk( a:msg, " Press ENTER to continue." )
                            endfunction 
                            
                            " Shorten long messages to fit status line
    1              0.000001 function! SlimvShortEcho( msg )
                                let saved=&shortmess
                                set shortmess+=T
                                exe "normal :echomsg a:msg\n" 
                                let &shortmess=saved
                            endfunction
                            
                            " Go to the end of buffer, make sure the cursor is positioned
                            " after the last character of the buffer when in insert mode
    1              0.000002 function s:EndOfBuffer()
                                normal! G$
                                if &virtualedit != 'all'
                                    call cursor( line('$'), 99999 )
                                endif
                            endfunction
                            
                            " Position the cursor at the end of the REPL buffer
                            " Optionally mark this position in Vim mark 's'
    1              0.000002 function! SlimvEndOfReplBuffer( force )
                                if line( '.' ) >= b:repl_prompt_line - 1 || a:force
                                    " Go to the end of file only if the user did not move up from here
                                    call s:EndOfBuffer()
                                endif
                            endfunction
                            
                            " Remember the end of the REPL buffer: user may enter commands here
                            " Also remember the prompt, because the user may overwrite it
    1              0.000002 function! SlimvMarkBufferEnd( force )
                                if exists( 'b:slimv_repl_buffer' )
                                    setlocal nomodified
                                    call SlimvEndOfReplBuffer( a:force )
                                    let b:repl_prompt_line = line( '$' )
                                    let b:repl_prompt_col = len( getline('$') ) + 1
                                    let b:repl_prompt = getline( b:repl_prompt_line )
                                endif
                            endfunction
                            
                            " Get REPL prompt line. Fix stored prompt position when corrupted
                            " (e.g. some lines were deleted from the REPL buffer)
    1              0.000003 function! s:GetPromptLine()
                                if b:repl_prompt_line > line( '$' )
                                    " Stored prompt line is corrupt
                                    let b:repl_prompt_line = line( '$' )
                                    let b:repl_prompt_col = len( getline('$') ) + 1
                                    let b:repl_prompt = getline( b:repl_prompt_line )
                                endif
                                return b:repl_prompt_line
                            endfunction
                            
                            " Generate unique window id for the current window
    1              0.000015 function s:MakeWindowId()
                                if g:slimv_repl_split && !exists('w:id')
                                    let s:win_id = s:win_id + 1
                                    let w:id = s:win_id
                                endif
                            endfunction
                            
                            " Find and switch to window with the specified window id
    1              0.000003 function s:SwitchToWindow( id )
                                for winnr in range( 1, winnr('$') )
                                    if getwinvar( winnr, 'id' ) is a:id
                                        execute winnr . "wincmd w"
                                    endif
                                endfor
                            endfunction
                            
                            " Save caller buffer identification
    1              0.000001 function! SlimvBeginUpdate()
                                call s:MakeWindowId()
                                let s:current_buf = bufnr( "%" )
                                let s:current_win = getwinvar( winnr(), 'id' )
                            endfunction
                            
                            " Switch to the buffer/window that was active before a swank action
    1              0.000001 function! SlimvRestoreFocus( hide_current_buf )
                                if exists("b:previous_buf")
                                    let new_buf = b:previous_buf
                                    let new_win = b:previous_win
                                else
                                    let new_buf = s:current_buf
                                    let new_win = s:current_win
                                endif
                                let buf = bufnr( "%" )
                                let win = getwinvar( winnr(), 'id' )
                                if a:hide_current_buf
                                    set nobuflisted
                                    b #
                                endif
                                if winnr('$') > 1 && new_win != '' && new_win != win
                                    " Switch to the caller window
                                    call s:SwitchToWindow( new_win )
                                endif
                                if new_buf >= 0 && buf != new_buf
                                    " Switch to the caller buffer
                                    execute "buf " . new_buf
                                endif
                            endfunction
                            
                            " Handle response coming from the SWANK listener
    1              0.000001 function! SlimvSwankResponse()
                                let s:swank_ok_result = ''
                                let s:refresh_disabled = 1
                                silent execute s:py_cmd . 'swank_output(1)'
                                let s:refresh_disabled = 0
                                let s:swank_action = ''
                                let s:swank_result = ''
                                silent execute s:py_cmd . 'swank_response("")'
                            
                                if s:swank_action == ':describe-symbol' && s:swank_result != ''
                                    echo substitute(s:swank_result,'^\n*','','')
                                elseif s:swank_ok_result != ''
                                    " Display the :ok result also in status bar in case the REPL buffer is not shown
                                    let s:swank_ok_result = substitute(s:swank_ok_result,"\<LF>",'','g')
                                    if s:swank_ok_result == ''
                                        call SlimvShortEcho( '=> OK' )
                                    else
                                        call SlimvShortEcho( '=> ' . s:swank_ok_result )
                                    endif
                                endif
                                if s:swank_actions_pending
                                    let s:last_update = -1
                                elseif s:last_update < 0
                                    " Remember the time when all actions are processed
                                    let s:last_update = localtime()
                                endif
                                if s:swank_actions_pending == 0 && s:last_update >= 0 && s:last_update < localtime() - 2
                                    " All SWANK output handled long ago, restore original update frequency
                                    if &updatetime == g:slimv_updatetime
                                        let &updatetime = s:save_updatetime
                                    endif
                                else
                                    " SWANK output still pending, keep higher update frequency
                                    if &updatetime != g:slimv_updatetime
                                        let s:save_updatetime = &updatetime
                                    endif
                                    let &updatetime = g:slimv_updatetime
                                endif
                            endfunction
                            
                            " Execute the given command and write its output at the end of the REPL buffer
    1              0.000001 function! SlimvCommand( cmd )
                                silent execute a:cmd
                                if &updatetime != g:slimv_updatetime
                                    let s:save_updatetime = &updatetime
                                endif
                                " Update more frequently until all swank responses processed
                                let &updatetime = g:slimv_updatetime
                                let s:last_update = -1
                            endfunction
                            
                            " Execute the given SWANK command, wait for and return the response
    1              0.000002 function! SlimvCommandGetResponse( name, cmd, timeout )
                                let s:refresh_disabled = 1
                                call SlimvCommand( a:cmd )
                                let s:swank_action = ''
                                let s:swank_result = ''
                                let starttime = localtime()
                                let cmd_timeout = a:timeout
                                if cmd_timeout == 0
                                    let cmd_timeout = 3
                                endif
                                while s:swank_action == '' && localtime()-starttime < cmd_timeout
                                    execute s:py_cmd . "swank_output( 0 )"
                                    silent execute s:py_cmd . 'swank_response("' . a:name . '")'
                                endwhile
                                let s:refresh_disabled = 0
                                return s:swank_result
                            endfunction
                            
                            " Reload the contents of the REPL buffer from the output file if changed
    1              0.000001 function! SlimvRefreshReplBuffer()
                                if s:refresh_disabled
                                    " Refresh is unwanted at the moment, probably another refresh is going on
                                    return
                                endif
                            
                                if s:repl_buf == -1
                                    " REPL buffer not loaded
                                    return
                                endif
                            
                                if s:swank_connected
                                    call SlimvSwankResponse()
                                endif
                            
                                if exists("s:input_prompt") && s:input_prompt != ''
                                    let answer = input( s:input_prompt )
                                    unlet s:input_prompt
                                    echo ""
                                    call SlimvCommand( s:py_cmd . 'swank_return("' . answer . '")' )
                                endif
                            endfunction
                            
                            " This function re-triggers the CursorHold event
                            " after refreshing the REPL buffer
    1              0.000001 function! SlimvTimer()
                                if v:count > 0
                                    " Skip refreshing if the user started a command prefixed with a count
                                    return
                                endif
                                " We don't want autocommands trigger during the quick switch to/from the REPL buffer
                                noautocmd call SlimvRefreshReplBuffer()
                                if mode() == 'i' || mode() == 'I' || mode() == 'r' || mode() == 'R'
                                    if bufname('%') != g:slimv_sldb_name && bufname('%') != g:slimv_inspect_name && bufname('%') != g:slimv_threads_name
                                        " Put '<Insert>' twice into the typeahead buffer, which should not do anything
                                        " just switch to replace/insert mode then back to insert/replace mode
                                        " But don't do this for readonly buffers
                                        call feedkeys("\<insert>\<insert>")
                                    endif
                                else
                                    " Put an incomplete 'f' command and an Esc into the typeahead buffer
                                    call feedkeys("f\e", 'n')
                                endif
                            endfunction
                            
                            " Switch refresh mode on:
                            " refresh REPL buffer on frequent Vim events
    1              0.000001 function! SlimvRefreshModeOn()
                                augroup SlimvCursorHold
                                    au!
                                    execute "au CursorHold   * :call SlimvTimer()"
                                    execute "au CursorHoldI  * :call SlimvTimer()"
                                augroup END
                            endfunction
                            
                            " Switch refresh mode off
    1              0.000001 function! SlimvRefreshModeOff()
                                augroup SlimvCursorHold
                                    au!
                                augroup END
                            endfunction
                            
                            " Called when entering REPL buffer
    1              0.000001 function! SlimvReplEnter()
                                call SlimvAddReplMenu()
                                augroup SlimvReplChanged
                                    au!
                                    execute "au FileChangedRO " . g:slimv_repl_name . " :call SlimvRefreshModeOff()"
                                augroup END
                                call SlimvRefreshModeOn()
                            endfunction
                            
                            " Called when leaving REPL buffer
    1              0.000001 function! SlimvReplLeave()
                                try
                                    " Check if REPL menu exists, then remove it
                                    aunmenu REPL
                                    execute ':unmap ' . g:slimv_leader . '\'
                                catch
                                    " REPL menu not found, we cannot remove it
                                endtry
                                if g:slimv_repl_split
                                    call SlimvRefreshModeOn()
                                else
                                    call SlimvRefreshModeOff()
                                endif
                            endfunction
                            
                            " Refresh cursor position in the REPL buffer after new lines appended
    1              0.000001 function! SlimvReplSetCursorPos( force )
                                " We do not want these autocommands to fire, the buffer switch will be temporary
                                let savemark = getpos("'`'")
                                let save_ei = &eventignore
                                set eventignore=BufEnter,BufLeave,BufWinEnter
                                let win = winnr()
                                windo call SlimvMarkBufferEnd( a:force )
                                execute win . "wincmd w"
                                let &eventignore = save_ei
                                call setpos("'`", savemark)
                            endfunction
                            
                            " View the given file in a top/bottom/left/right split window
    1              0.000002 function! s:SplitView( filename )
                                " Check if we have at least two windows used by slimv (have a window id assigned)
                                let winnr1 = 0
                                let winnr2 = 0
                                for winnr in range( 1, winnr('$') )
                                    if getwinvar( winnr, 'id' ) != ''
                                        let winnr2 = winnr1
                                        let winnr1 = winnr
                                    endif
                                endfor
                                if winnr1 > 0 && winnr2 > 0
                                    " We have already at least two windows used by slimv
                                    let winid = getwinvar( winnr(), 'id' )
                                    if bufnr("%") == s:current_buf && winid == s:current_win
                                        " Keep the current window on screen, use the other window for the new buffer
                                        if winnr1 != winnr()
                                            execute winnr1 . "wincmd w"
                                        else
                                            execute winnr2 . "wincmd w"
                                        endif
                                    endif
                                    execute "silent view! " . a:filename
                                else
                                    " Generate unique window id for the old window if not yet done
                                    call s:MakeWindowId()
                                    " No windows yet, need to split
                                    if g:slimv_repl_split == 1
                                        execute "silent topleft sview! " . a:filename
                                    elseif g:slimv_repl_split == 2
                                        execute "silent botright sview! " . a:filename
                                    elseif g:slimv_repl_split == 3
                                        execute "silent topleft vertical sview! " . a:filename
                                    elseif g:slimv_repl_split == 4
                                        execute "silent botright vertical sview! " . a:filename
                                    else
                                        execute "silent view! " . a:filename
                                    endif
                                    " Generate unique window id for the new window as well
                                    call s:MakeWindowId()
                                endif
                                stopinsert
                            endfunction
                            
                            " Open a buffer with the given name if not yet open, and switch to it
    1              0.000001 function! SlimvOpenBuffer( name )
                                let buf = bufnr( '^' . a:name . '$' )
                                if buf == -1
                                    " Create a new buffer
                                    call s:SplitView( a:name )
                                else
                                    if g:slimv_repl_split
                                        " Buffer is already created. Check if it is open in a window
                                        let win = bufwinnr( buf )
                                        if win == -1
                                            " Create windows
                                            call s:SplitView( a:name )
                                        else
                                            " Switch to the buffer's window
                                            if winnr() != win
                                                execute win . "wincmd w"
                                            endif
                                        endif
                                    else
                                        execute "buffer " . buf
                                        stopinsert
                                    endif
                                endif
                                if s:current_buf != bufnr( "%" )
                                    " Keep track of the previous buffer and window
                                    let b:previous_buf = s:current_buf
                                    let b:previous_win = s:current_win
                                endif
                                setlocal buftype=nofile
                                setlocal noswapfile
                                setlocal modifiable
                            endfunction
                            
                            " Go to the end of the screen line
    1              0.000002 function s:EndOfScreenLine()
                                if len(getline('.')) < &columns
                                    " g$ moves the cursor to the rightmost column if virtualedit=all
                                    normal! $
                                else
                                    normal! g$
                                endif
                            endfunction
                            
                            " Set special syntax rules for the REPL buffer
    1              0.000001 function! SlimvSetSyntaxRepl()
                                if SlimvGetFiletype() == 'scheme'
                                    syn cluster replListCluster contains=@schemeListCluster,lispList
                                else
                                    syn cluster replListCluster contains=@lispListCluster
                                endif
                            
                            if exists("g:lisp_rainbow") && g:lisp_rainbow != 0
                            
                                if &bg == "dark"
                                    hi def hlLevel0 ctermfg=red         guifg=red1
                                    hi def hlLevel1 ctermfg=yellow      guifg=orange1
                                    hi def hlLevel2 ctermfg=green       guifg=yellow1
                                    hi def hlLevel3 ctermfg=cyan        guifg=greenyellow
                                    hi def hlLevel4 ctermfg=magenta     guifg=green1
                                    hi def hlLevel5 ctermfg=red         guifg=springgreen1
                                    hi def hlLevel6 ctermfg=yellow      guifg=cyan1
                                    hi def hlLevel7 ctermfg=green       guifg=slateblue1
                                    hi def hlLevel8 ctermfg=cyan        guifg=magenta1
                                    hi def hlLevel9 ctermfg=magenta     guifg=purple1
                                else
                                    hi def hlLevel0 ctermfg=red         guifg=red3
                                    hi def hlLevel1 ctermfg=darkyellow  guifg=orangered3
                                    hi def hlLevel2 ctermfg=darkgreen   guifg=orange2
                                    hi def hlLevel3 ctermfg=blue        guifg=yellow3
                                    hi def hlLevel4 ctermfg=darkmagenta guifg=olivedrab4
                                    hi def hlLevel5 ctermfg=red         guifg=green4
                                    hi def hlLevel6 ctermfg=darkyellow  guifg=paleturquoise3
                                    hi def hlLevel7 ctermfg=darkgreen   guifg=deepskyblue4
                                    hi def hlLevel8 ctermfg=blue        guifg=darkslateblue
                                    hi def hlLevel9 ctermfg=darkmagenta guifg=darkviolet
                                endif
                            
                             if SlimvGetFiletype() =~ '.*\(clojure\|scheme\|racket\).*'
                            
                                syn region lispParen9 matchgroup=hlLevel9 start="`\=(" matchgroup=hlLevel9 end=")"  matchgroup=replPrompt end="^\S\+>" contains=TOP,@Spell
                                syn region lispParen0 matchgroup=hlLevel8 start="`\=(" end=")" matchgroup=replPrompt end="^\S\+>"me=s-1,re=s-1 contains=TOP,lispParen0,lispParen1,lispParen2,lispParen3,lispParen4,lispParen5,lispParen6,lispParen7,lispParen8,NoInParens
                                syn region lispParen1 matchgroup=hlLevel7 start="`\=(" end=")" matchgroup=replPrompt end="^\S\+>"me=s-1,re=s-1 contains=TOP,lispParen1,lispParen2,lispParen3,lispParen4,lispParen5,lispParen6,lispParen7,lispParen8,NoInParens
                                syn region lispParen2 matchgroup=hlLevel6 start="`\=(" end=")" matchgroup=replPrompt end="^\S\+>"me=s-1,re=s-1 contains=TOP,lispParen2,lispParen3,lispParen4,lispParen5,lispParen6,lispParen7,lispParen8,NoInParens
                                syn region lispParen3 matchgroup=hlLevel5 start="`\=(" end=")" matchgroup=replPrompt end="^\S\+>"me=s-1,re=s-1 contains=TOP,lispParen3,lispParen4,lispParen5,lispParen6,lispParen7,lispParen8,NoInParens
                                syn region lispParen4 matchgroup=hlLevel4 start="`\=(" end=")" matchgroup=replPrompt end="^\S\+>"me=s-1,re=s-1 contains=TOP,lispParen4,lispParen5,lispParen6,lispParen7,lispParen8,NoInParens
                                syn region lispParen5 matchgroup=hlLevel3 start="`\=(" end=")" matchgroup=replPrompt end="^\S\+>"me=s-1,re=s-1 contains=TOP,lispParen5,lispParen6,lispParen7,lispParen8,NoInParens
                                syn region lispParen6 matchgroup=hlLevel2 start="`\=(" end=")" matchgroup=replPrompt end="^\S\+>"me=s-1,re=s-1 contains=TOP,lispParen6,lispParen7,lispParen8,NoInParens
                                syn region lispParen7 matchgroup=hlLevel1 start="`\=(" end=")" matchgroup=replPrompt end="^\S\+>"me=s-1,re=s-1 contains=TOP,lispParen7,lispParen8,NoInParens
                                syn region lispParen8 matchgroup=hlLevel0 start="`\=(" end=")" matchgroup=replPrompt end="^\S\+>"me=s-1,re=s-1 contains=TOP,lispParen8,NoInParens
                            
                                syn region lispParen9 matchgroup=hlLevel9 start="`\=\[" matchgroup=hlLevel9 end="\]"  matchgroup=replPrompt end="^\S\+>" contains=TOP,@Spell
                                syn region lispParen0 matchgroup=hlLevel8 start="`\=\[" end="\]" matchgroup=replPrompt end="^\S\+>"me=s-1,re=s-1 contains=TOP,lispParen0,lispParen1,lispParen2,lispParen3,lispParen4,lispParen5,lispParen6,lispParen7,lispParen8,NoInParens
                                syn region lispParen1 matchgroup=hlLevel7 start="`\=\[" end="\]" matchgroup=replPrompt end="^\S\+>"me=s-1,re=s-1 contains=TOP,lispParen1,lispParen2,lispParen3,lispParen4,lispParen5,lispParen6,lispParen7,lispParen8,NoInParens
                                syn region lispParen2 matchgroup=hlLevel6 start="`\=\[" end="\]" matchgroup=replPrompt end="^\S\+>"me=s-1,re=s-1 contains=TOP,lispParen2,lispParen3,lispParen4,lispParen5,lispParen6,lispParen7,lispParen8,NoInParens
                                syn region lispParen3 matchgroup=hlLevel5 start="`\=\[" end="\]" matchgroup=replPrompt end="^\S\+>"me=s-1,re=s-1 contains=TOP,lispParen3,lispParen4,lispParen5,lispParen6,lispParen7,lispParen8,NoInParens
                                syn region lispParen4 matchgroup=hlLevel4 start="`\=\[" end="\]" matchgroup=replPrompt end="^\S\+>"me=s-1,re=s-1 contains=TOP,lispParen4,lispParen5,lispParen6,lispParen7,lispParen8,NoInParens
                                syn region lispParen5 matchgroup=hlLevel3 start="`\=\[" end="\]" matchgroup=replPrompt end="^\S\+>"me=s-1,re=s-1 contains=TOP,lispParen5,lispParen6,lispParen7,lispParen8,NoInParens
                                syn region lispParen6 matchgroup=hlLevel2 start="`\=\[" end="\]" matchgroup=replPrompt end="^\S\+>"me=s-1,re=s-1 contains=TOP,lispParen6,lispParen7,lispParen8,NoInParens
                                syn region lispParen7 matchgroup=hlLevel1 start="`\=\[" end="\]" matchgroup=replPrompt end="^\S\+>"me=s-1,re=s-1 contains=TOP,lispParen7,lispParen8,NoInParens
                                syn region lispParen8 matchgroup=hlLevel0 start="`\=\[" end="\]" matchgroup=replPrompt end="^\S\+>"me=s-1,re=s-1 contains=TOP,lispParen8,NoInParens
                            
                                syn region lispParen9 matchgroup=hlLevel9 start="`\={" matchgroup=hlLevel9 end="}"  matchgroup=replPrompt end="^\S\+>" contains=TOP,@Spell
                                syn region lispParen0 matchgroup=hlLevel8 start="`\={" end="}" matchgroup=replPrompt end="^\S\+>"me=s-1,re=s-1 contains=TOP,lispParen0,lispParen1,lispParen2,lispParen3,lispParen4,lispParen5,lispParen6,lispParen7,lispParen8,NoInParens
                                syn region lispParen1 matchgroup=hlLevel7 start="`\={" end="}" matchgroup=replPrompt end="^\S\+>"me=s-1,re=s-1 contains=TOP,lispParen1,lispParen2,lispParen3,lispParen4,lispParen5,lispParen6,lispParen7,lispParen8,NoInParens
                                syn region lispParen2 matchgroup=hlLevel6 start="`\={" end="}" matchgroup=replPrompt end="^\S\+>"me=s-1,re=s-1 contains=TOP,lispParen2,lispParen3,lispParen4,lispParen5,lispParen6,lispParen7,lispParen8,NoInParens
                                syn region lispParen3 matchgroup=hlLevel5 start="`\={" end="}" matchgroup=replPrompt end="^\S\+>"me=s-1,re=s-1 contains=TOP,lispParen3,lispParen4,lispParen5,lispParen6,lispParen7,lispParen8,NoInParens
                                syn region lispParen4 matchgroup=hlLevel4 start="`\={" end="}" matchgroup=replPrompt end="^\S\+>"me=s-1,re=s-1 contains=TOP,lispParen4,lispParen5,lispParen6,lispParen7,lispParen8,NoInParens
                                syn region lispParen5 matchgroup=hlLevel3 start="`\={" end="}" matchgroup=replPrompt end="^\S\+>"me=s-1,re=s-1 contains=TOP,lispParen5,lispParen6,lispParen7,lispParen8,NoInParens
                                syn region lispParen6 matchgroup=hlLevel2 start="`\={" end="}" matchgroup=replPrompt end="^\S\+>"me=s-1,re=s-1 contains=TOP,lispParen6,lispParen7,lispParen8,NoInParens
                                syn region lispParen7 matchgroup=hlLevel1 start="`\={" end="}" matchgroup=replPrompt end="^\S\+>"me=s-1,re=s-1 contains=TOP,lispParen7,lispParen8,NoInParens
                                syn region lispParen8 matchgroup=hlLevel0 start="`\={" end="}" matchgroup=replPrompt end="^\S\+>"me=s-1,re=s-1 contains=TOP,lispParen8,NoInParens
                            
                             else
                            
                                syn region lispParen0           matchgroup=hlLevel0 start="`\=("  skip="|.\{-}|" end=")"  matchgroup=replPrompt end="^\S\+>"              contains=@replListCluster,lispParen1,replPrompt
                                syn region lispParen1 contained matchgroup=hlLevel1 start="`\=("  skip="|.\{-}|" end=")"  matchgroup=replPrompt end="^\S\+>"me=s-1,re=s-1 contains=@replListCluster,lispParen2
                                syn region lispParen2 contained matchgroup=hlLevel2 start="`\=("  skip="|.\{-}|" end=")"  matchgroup=replPrompt end="^\S\+>"me=s-1,re=s-1 contains=@replListCluster,lispParen3
                                syn region lispParen3 contained matchgroup=hlLevel3 start="`\=("  skip="|.\{-}|" end=")"  matchgroup=replPrompt end="^\S\+>"me=s-1,re=s-1 contains=@replListCluster,lispParen4
                                syn region lispParen4 contained matchgroup=hlLevel4 start="`\=("  skip="|.\{-}|" end=")"  matchgroup=replPrompt end="^\S\+>"me=s-1,re=s-1 contains=@replListCluster,lispParen5
                                syn region lispParen5 contained matchgroup=hlLevel5 start="`\=("  skip="|.\{-}|" end=")"  matchgroup=replPrompt end="^\S\+>"me=s-1,re=s-1 contains=@replListCluster,lispParen6
                                syn region lispParen6 contained matchgroup=hlLevel6 start="`\=("  skip="|.\{-}|" end=")"  matchgroup=replPrompt end="^\S\+>"me=s-1,re=s-1 contains=@replListCluster,lispParen7
                                syn region lispParen7 contained matchgroup=hlLevel7 start="`\=("  skip="|.\{-}|" end=")"  matchgroup=replPrompt end="^\S\+>"me=s-1,re=s-1 contains=@replListCluster,lispParen8
                                syn region lispParen8 contained matchgroup=hlLevel8 start="`\=("  skip="|.\{-}|" end=")"  matchgroup=replPrompt end="^\S\+>"me=s-1,re=s-1 contains=@replListCluster,lispParen9
                                syn region lispParen9 contained matchgroup=hlLevel9 start="`\=("  skip="|.\{-}|" end=")"  matchgroup=replPrompt end="^\S\+>"me=s-1,re=s-1 contains=@replListCluster,lispParen0
                            
                             endif
                            
                            else
                            
                              if SlimvGetFiletype() !~ '.*clojure.*'
                                syn region lispList             matchgroup=Delimiter start="("    skip="|.\{-}|" end=")"  matchgroup=replPrompt end="^\S\+>" contains=@replListCluster
                                syn region lispBQList           matchgroup=PreProc   start="`("   skip="|.\{-}|" end=")"  matchgroup=replPrompt end="^\S\+>" contains=@replListCluster
                              endif
                            
                            endif
                            
                                syn match   replPrompt /^[^(]\S\+>/
                                syn match   replPrompt /^(\S\+)>/
                                hi def link replPrompt Type
                            endfunction
                            
                            " Open a new REPL buffer
    1              0.000002 function! SlimvOpenReplBuffer()
                                call SlimvOpenBuffer( g:slimv_repl_name )
                                setlocal noreadonly
                                let s:repl_buf = bufnr( "%" )
                                let b:slimv_repl_buffer = 1
                                call SlimvInitRepl()
                                if g:slimv_repl_syntax
                                    call SlimvSetSyntaxRepl()
                                else
                                    set syntax=
                                endif
                            
                                " Prompt and its line and column number in the REPL buffer
                                if !exists( 'b:repl_prompt' )
                                    let b:repl_prompt = ''
                                    let b:repl_prompt_line = 1
                                    let b:repl_prompt_col = 1
                                endif
                            
                                " Add keybindings valid only for the REPL buffer
                                inoremap <buffer> <silent>        <C-CR> <End><C-O>:call SlimvSendCommand(1)<CR><End>
                                inoremap <buffer> <silent>        <C-C>  <C-O>:call SlimvInterrupt()<CR>
                                inoremap <buffer> <silent> <expr> <C-W>  SlimvHandleCW()
                            
                                if g:slimv_repl_simple_eval
                                    inoremap <buffer> <silent>        <CR>     <C-R>=pumvisible() ? "\<lt>C-Y>"  : "\<lt>End>\<lt>C-O>:call SlimvSendCommand(0)\<lt>CR>\<lt>End>"<CR>
                                    inoremap <buffer> <silent>        <Up>     <C-R>=pumvisible() ? "\<lt>Up>"   : SlimvHandleUp()<CR>
                                    inoremap <buffer> <silent>        <Down>   <C-R>=pumvisible() ? "\<lt>Down>" : SlimvHandleDown()<CR>
                                else
                                    inoremap <buffer> <silent>        <CR>     <C-R>=pumvisible() ? "\<lt>C-Y>"  : SlimvHandleEnterRepl()<CR><C-R>=SlimvArglistOnEnter()<CR>
                                    inoremap <buffer> <silent>        <C-Up>   <C-R>=pumvisible() ? "\<lt>Up>"   : SlimvHandleUp()<CR>
                                    inoremap <buffer> <silent>        <C-Down> <C-R>=pumvisible() ? "\<lt>Down>" : SlimvHandleDown()<CR>
                                endif
                            
                                if exists( 'g:paredit_loaded' )
                                    inoremap <buffer> <silent> <expr> <BS>   PareditBackspace(1)
                                else
                                    inoremap <buffer> <silent> <expr> <BS>   SlimvHandleBS()
                                endif
                            
                                if g:slimv_keybindings == 1
                                    execute 'noremap <buffer> <silent> ' . g:slimv_leader.'.      :call SlimvSendCommand(0)<CR>'
                                    execute 'noremap <buffer> <silent> ' . g:slimv_leader.'/      :call SlimvSendCommand(1)<CR>'
                                    execute 'noremap <buffer> <silent> ' . g:slimv_leader.'<Up>   :call SlimvPreviousCommand()<CR>'
                                    execute 'noremap <buffer> <silent> ' . g:slimv_leader.'<Down> :call SlimvNextCommand()<CR>'
                                elseif g:slimv_keybindings == 2
                                    execute 'noremap <buffer> <silent> ' . g:slimv_leader.'rs     :call SlimvSendCommand(0)<CR>'
                                    execute 'noremap <buffer> <silent> ' . g:slimv_leader.'ro     :call SlimvSendCommand(1)<CR>'
                                    execute 'noremap <buffer> <silent> ' . g:slimv_leader.'rp     :call SlimvPreviousCommand()<CR>'
                                    execute 'noremap <buffer> <silent> ' . g:slimv_leader.'rn     :call SlimvNextCommand()<CR>'
                                endif
                            
                                if g:slimv_repl_wrap
                                    inoremap <buffer> <silent>        <Home> <C-O>g<Home>
                                    inoremap <buffer> <silent>        <End>  <C-O>:call <SID>EndOfScreenLine()<CR>
                                    noremap  <buffer> <silent>        <Up>   gk
                                    noremap  <buffer> <silent>        <Down> gj
                                    noremap  <buffer> <silent>        <Home> g<Home>
                                    noremap  <buffer> <silent>        <End>  :call <SID>EndOfScreenLine()<CR>
                                    noremap  <buffer> <silent>        k      gk
                                    noremap  <buffer> <silent>        j      gj
                                    noremap  <buffer> <silent>        0      g0
                                    noremap  <buffer> <silent>        $      :call <SID>EndOfScreenLine()<CR>
                                    setlocal wrap
                                endif
                            
                                hi SlimvNormal term=none cterm=none gui=none
                                hi SlimvCursor term=reverse cterm=reverse gui=reverse
                            
                                augroup SlimvReplAutoCmd
                                    au!
                                    " Add autocommands specific to the REPL buffer
                                    execute "au FileChangedShell " . g:slimv_repl_name . " :call SlimvRefreshReplBuffer()"
                                    execute "au FocusGained "      . g:slimv_repl_name . " :call SlimvRefreshReplBuffer()"
                                    execute "au BufEnter "         . g:slimv_repl_name . " :call SlimvReplEnter()"
                                    execute "au BufLeave "         . g:slimv_repl_name . " :call SlimvReplLeave()"
                                    execute "au BufWinEnter "      . g:slimv_repl_name . " :call SlimvMarkBufferEnd(1)"
                                    execute "au TabEnter *"        . " :call SlimvReplSetCursorPos(1)"
                                augroup END
                            
                                call SlimvRefreshReplBuffer()
                            endfunction
                            
                            " Clear the contents of the REPL buffer, keeping the last prompt only
    1              0.000004 function! SlimvClearReplBuffer()
                                let this_buf = bufnr( "%" )
                                if s:repl_buf == -1
                                    call SlimvError( "There is no REPL buffer." )
                                    return
                                endif
                                if this_buf != s:repl_buf
                                    let oldpos = winsaveview()
                                    execute "buf " . s:repl_buf
                                endif
                                if b:repl_prompt_line > 1
                                    execute "normal! gg0d" . (b:repl_prompt_line-1) . "GG$"
                                    let b:repl_prompt_line = 1
                                endif
                                if this_buf != s:repl_buf
                                    execute "buf " . this_buf
                                    call winrestview( oldpos )
                                endif
                            endfunction
                            
                            " Open a new Inspect buffer
    1              0.000001 function SlimvOpenInspectBuffer()
                                call SlimvOpenBuffer( g:slimv_inspect_name )
                                let b:range_start = 0
                                let b:range_end   = 0
                                let b:help = SlimvHelpInspect()
                            
                                " Add keybindings valid only for the Inspect buffer
                                noremap  <buffer> <silent>        <F1>   :call SlimvToggleHelp()<CR>
                                noremap  <buffer> <silent>        <CR>   :call SlimvHandleEnterInspect()<CR>
                                noremap  <buffer> <silent> <Backspace>   :call SlimvSendSilent(['[-1]'])<CR>
                                execute 'noremap <buffer> <silent> ' . g:slimv_leader.'q      :call SlimvQuitInspect(1)<CR>'
                            
                                if version < 703
                                    " conceal mechanism is defined since Vim 7.3
                                    syn region inspectItem   matchgroup=Ignore start="{\[\d\+\]\s*" end="\[]}"
                                    syn region inspectAction matchgroup=Ignore start="{<\d\+>\s*"   end="<>}"
                                else
                                    syn region inspectItem   matchgroup=Ignore start="{\[\d\+\]\s*" end="\[]}" concealends
                                    syn region inspectAction matchgroup=Ignore start="{<\d\+>\s*"   end="<>}" concealends
                                    setlocal conceallevel=3 concealcursor=nc
                                endif
                            
                                hi def link inspectItem   Special
                                hi def link inspectAction String
                            
                                syn match Special /^\[<<\].*$/
                                syn match Special /^\[--....--\]$/
                            endfunction
                            
                            " Open a new Threads buffer
    1              0.000001 function SlimvOpenThreadsBuffer()
                                call SlimvOpenBuffer( g:slimv_threads_name )
                                let b:help = SlimvHelpThreads()
                            
                                " Add keybindings valid only for the Threads buffer
                                "noremap  <buffer> <silent>        <CR>   :call SlimvHandleEnterThreads()<CR>
                                noremap  <buffer> <silent>        <F1>                        :call SlimvToggleHelp()<CR>
                                noremap  <buffer> <silent> <Backspace>                        :call SlimvKillThread()<CR>
                                execute 'noremap <buffer> <silent> ' . g:slimv_leader.'r      :call SlimvListThreads()<CR>'
                                execute 'noremap <buffer> <silent> ' . g:slimv_leader.'d      :call SlimvDebugThread()<CR>'
                                execute 'noremap <buffer> <silent> ' . g:slimv_leader.'k      :call SlimvKillThread()<CR>'
                                execute 'noremap <buffer> <silent> ' . g:slimv_leader.'q      :call SlimvQuitThreads()<CR>'
                            endfunction
                            
                            " Open a new SLDB buffer
    1              0.000002 function SlimvOpenSldbBuffer()
                                call SlimvOpenBuffer( g:slimv_sldb_name )
                            
                                " Add keybindings valid only for the SLDB buffer
                                noremap  <buffer> <silent>        <CR>   :call SlimvHandleEnterSldb()<CR>
                                if g:slimv_keybindings == 1
                                    execute 'noremap <buffer> <silent> ' . g:slimv_leader.'a      :call SlimvDebugAbort()<CR>'
                                    execute 'noremap <buffer> <silent> ' . g:slimv_leader.'q      :call SlimvDebugQuit()<CR>'
                                    execute 'noremap <buffer> <silent> ' . g:slimv_leader.'n      :call SlimvDebugContinue()<CR>'
                                    execute 'noremap <buffer> <silent> ' . g:slimv_leader.'N      :call SlimvDebugRestartFrame()<CR>'
                                elseif g:slimv_keybindings == 2
                                    execute 'noremap <buffer> <silent> ' . g:slimv_leader.'da     :call SlimvDebugAbort()<CR>'
                                    execute 'noremap <buffer> <silent> ' . g:slimv_leader.'dq     :call SlimvDebugQuit()<CR>'
                                    execute 'noremap <buffer> <silent> ' . g:slimv_leader.'dn     :call SlimvDebugContinue()<CR>'
                                    execute 'noremap <buffer> <silent> ' . g:slimv_leader.'dr     :call SlimvDebugRestartFrame()<CR>'
                                endif
                            
                                " Set folding parameters
                                setlocal foldmethod=marker
                                setlocal foldmarker={{{,}}}
                                setlocal foldtext=substitute(getline(v:foldstart),'{{{','','')
                                call s:SetKeyword()
                                if g:slimv_sldb_wrap
                                    setlocal wrap
                                endif
                            
                                if version < 703
                                    " conceal mechanism is defined since Vim 7.3
                                    syn match Ignore /{{{/
                                    syn match Ignore /}}}/
                                else
                                    setlocal conceallevel=3 concealcursor=nc
                                    syn match Comment /{{{/ conceal
                                    syn match Comment /}}}/ conceal
                                endif
                                syn match Type /^\s\{0,2}\d\{1,3}:/
                                syn match Type /^\s\+in "\(.*\)" \(line\|byte\) \(\d\+\)$/
                            endfunction
                            
                            " End updating an otherwise readonly buffer
    1              0.000001 function SlimvEndUpdate()
                                setlocal nomodifiable
                                setlocal nomodified
                            endfunction
                            
                            " Quit Inspector
    1              0.000002 function SlimvQuitInspect( force )
                                " Clear the contents of the Inspect buffer
                                if exists( 'b:inspect_pos' )
                                    unlet b:inspect_pos
                                endif
                                setlocal modifiable
                                silent! %d _
                                call SlimvEndUpdate()
                                if a:force
                                    call SlimvCommand( s:py_cmd . 'swank_quit_inspector()' )
                                endif
                                call SlimvRestoreFocus(1)
                            endfunction
                            
                            " Quit Threads
    1              0.000001 function SlimvQuitThreads()
                                " Clear the contents of the Threads buffer
                                setlocal modifiable
                                silent! %d _
                                call SlimvEndUpdate()
                                call SlimvRestoreFocus(1)
                            endfunction
                            
                            " Quit Sldb
    1              0.000001 function SlimvQuitSldb()
                                " Clear the contents of the Sldb buffer
                                setlocal modifiable
                                silent! %d _
                                call SlimvEndUpdate()
                                call SlimvRestoreFocus(1)
                            endfunction
                            
                            " Create help text for Inspect buffer
    1              0.000001 function SlimvHelpInspect()
                                let help = []
                                call add( help, '<F1>        : toggle this help' )
                                call add( help, '<Enter>     : open object or select action under cursor' )
                                call add( help, '<Backspace> : go back to previous object' )
                                call add( help, g:slimv_leader . 'q          : quit' )
                                return help
                            endfunction
                            
                            " Create help text for Threads buffer
    1              0.000001 function SlimvHelpThreads()
                                let help = []
                                call add( help, '<F1>        : toggle this help' )
                                call add( help, '<Backspace> : kill thread' )
                                call add( help, g:slimv_leader . 'k          : kill thread' )
                                call add( help, g:slimv_leader . 'd          : debug thread' )
                                call add( help, g:slimv_leader . 'r          : refresh' )
                                call add( help, g:slimv_leader . 'q          : quit' )
                                return help
                            endfunction
                            
                            " Write help text to current buffer at given line
    1              0.000001 function SlimvHelp( line )
                                setlocal modifiable
                                if exists( 'b:help_shown' )
                                    let help = b:help
                                else
                                    let help = ['Press <F1> for Help']
                                endif
                                let b:help_line = a:line
                                call append( b:help_line, help )
                            endfunction
                            
                            " Toggle help
    1              0.000001 function SlimvToggleHelp()
                                if exists( 'b:help_shown' )
                                    let lines = len( b:help )
                                    unlet b:help_shown
                                else
                                    let lines = 1
                                    let b:help_shown = 1
                                endif
                                setlocal modifiable
                                execute ":" . (b:help_line+1) . "," . (b:help_line+lines) . "d"
                                call SlimvHelp( b:help_line )
                                call SlimvEndUpdate()
                            endfunction
                            
                            " Open SLDB buffer and place cursor on the given frame
    1              0.000001 function SlimvGotoFrame( frame )
                                call SlimvOpenSldbBuffer()
                                let bcktrpos = search( '^Backtrace:', 'bcnw' )
                                let line = getline( '.' )
                                let item = matchstr( line, '^\s*' . a:frame .  ':' )
                                if item != '' && line('.') > bcktrpos
                                    " Already standing on the frame
                                    return
                                endif
                            
                                " Must locate the frame starting from the 'Backtrace:' string
                                call search( '^Backtrace:', 'bcw' )
                                call search( '^\s*' . a:frame .  ':', 'w' )
                            endfunction
                            
                            " Set 'iskeyword' option depending on file type
    1              0.000003 function! s:SetKeyword()
                                if SlimvGetFiletype() =~ '.*\(clojure\|scheme\|racket\).*'
                                    setlocal iskeyword+=+,-,*,/,%,<,=,>,:,$,?,!,@-@,94,~,#,\|,&
                                else
                                    setlocal iskeyword+=+,-,*,/,%,<,=,>,:,$,?,!,@-@,94,~,#,\|,&,.,{,},[,]
                                endif
                            endfunction
                            
                            " Select symbol under cursor and return it
    1              0.000001 function! SlimvSelectSymbol()
                                call s:SetKeyword()
                                let oldpos = winsaveview()
                                if col('.') > 1 && getline('.')[col('.')-1] =~ '\s'
                                    normal! h
                                endif
                                let symbol = expand('<cword>')
                                call winrestview( oldpos )
                                return symbol
                            endfunction
                            
                            " Select symbol with possible prefixes under cursor and return it
    1              0.000001 function! SlimvSelectSymbolExt()
                                let save_iskeyword = &iskeyword
                                call s:SetKeyword()
                                setlocal iskeyword+='
                                let symbol = expand('<cword>')
                                let &iskeyword = save_iskeyword
                                return symbol
                            endfunction
                            
                            " Select bottom level form the cursor is inside and copy it to register 's'
    1              0.000001 function! SlimvSelectForm( extended )
                                if SlimvGetFiletype() == 'r'
                                    silent! normal va(
                                    silent! normal "sY
                                    return 1
                                endif
                                " Search the opening '(' if we are standing on a special form prefix character
                                let c = col( '.' ) - 1
                                let firstchar = getline( '.' )[c]
                                while c < len( getline( '.' ) ) && match( "'`#", getline( '.' )[c] ) >= 0
                                    normal! l
                                    let c = c + 1
                                endwhile
                                normal! va(
                                let p1 = getpos('.')
                                normal! o
                                let p2 = getpos('.')
                                if firstchar != '(' && p1[1] == p2[1] && (p1[2] == p2[2] || p1[2] == p2[2]+1)
                                    " Empty selection and no paren found, select current word instead
                                    normal! aw
                                elseif a:extended || firstchar != '('
                                    " Handle '() or #'() etc. type special syntax forms (but stop at prompt)
                                    let c = col( '.' ) - 2
                                    while c >= 0 && match( ' \t()>', getline( '.' )[c] ) < 0
                                        normal! h
                                        let c = c - 1
                                    endwhile
                                endif
                                silent normal! "sy
                                let sel = SlimvGetSelection()
                                if sel == ''
                                    call SlimvError( "Form is empty." )
                                    return 0
                                elseif sel == '(' || sel == '[' || sel == '{'
                                    call SlimvError( "Form is unbalanced." )
                                    return 0
                                else
                                    return 1
                                endif
                            endfunction
                            
                            " Find starting '(' of a top level form
    1              0.000001 function! SlimvFindDefunStart()
                                let l = line( '.' )
                                let matchb = max( [l-200, 1] )
                                if SlimvGetFiletype() == 'r'
                                    while searchpair( '(', '', ')', 'bW', s:skip_sc, matchb ) || searchpair( '{', '', '}', 'bW', s:skip_sc, matchb ) || searchpair( '\[', '', '\]', 'bW', s:skip_sc, matchb )
                                    endwhile
                                else
                                    while searchpair( '(', '', ')', 'bW', s:skip_sc, matchb )
                                    endwhile
                                endif
                            endfunction
                            
                            " Select top level form the cursor is inside and copy it to register 's'
    1              0.000001 function! SlimvSelectDefun()
                                call SlimvFindDefunStart()
                                if SlimvGetFiletype() == 'r'
                                    " The cursor must be on the enclosing paren character
                                    silent! normal v%"sY
                                    return 1
                                else
                                    return SlimvSelectForm( 1 )
                                endif
                            endfunction
                            
                            " Return the contents of register 's'
    1              0.000001 function! SlimvGetSelection()
                                return getreg( 's' )
                            endfunction
                            
                            " Find language specific package/namespace definition backwards
                            " Set it as the current package for the next swank action
    1              0.000001 function! SlimvFindPackage()
                                if !g:slimv_package || SlimvGetFiletype() == 'scheme'
                                    return
                                endif
                                let oldpos = winsaveview()
                                let save_ic = &ignorecase
                                set ignorecase
                                if SlimvGetFiletype() =~ '.*clojure.*'
                                    let string = '\(in-ns\|ns\)'
                                else
                                    let string = '\(cl:\|common-lisp:\|\)in-package'
                                endif
                                let found = 0
                                let searching = search( '(\s*' . string . '\s', 'bcW' )
                                while searching
                                    " Search for the previos occurrence
                                    if synIDattr( synID( line('.'), col('.'), 0), 'name' ) !~ '[Ss]tring\|[Cc]omment'
                                        " It is not inside a comment or string
                                        let found = 1
                                        break
                                    endif
                                    let searching = search( '(\s*' . string . '\s', 'bW' )
                                endwhile
                                if found
                                    " Find the package name with all folds open
                                    normal! zn
                                    silent normal! w
                                    let l:package_command = expand('<cword>')
                                    silent normal! w
                                    let l:packagename_tokens = split(expand('<cWORD>'),')\|\s')
                                    normal! zN
                                    if l:packagename_tokens != []
                                        " Remove quote character from package name
                                        let s:swank_package = substitute( l:packagename_tokens[0], "'", '', '' )
                                        let s:swank_package_form = "(" . l:package_command . " " . l:packagename_tokens[0] . ")\n"
                                    else
                                        let s:swank_package = ''
                                        let s:swank_package_form = ''
                                    endif
                                endif
                                let &ignorecase = save_ic
                                call winrestview( oldpos )
                            endfunction
                            
                            " Execute the given SWANK command with current package defined
    1              0.000002 function! SlimvCommandUsePackage( cmd )
                                call SlimvFindPackage()
                                let s:refresh_disabled = 1
                                call SlimvCommand( a:cmd )
                                let s:swank_package = ''
                                let s:swank_package_form = ''
                                let s:refresh_disabled = 0
                                call SlimvRefreshReplBuffer()
                            endfunction
                            
                            " Initialize embedded Python and connect to SWANK server
    1              0.000001 function! SlimvConnectSwank()
                                if !s:python_initialized
                                    if ( s:py_cmd == 'python3 ' && ! has('python3') ) ||
                                     \ ( s:py_cmd == 'python '  && ! has('python' ) )
                                        call SlimvErrorWait( 'Vim is compiled without the Python feature or Python is not installed. Unable to run SWANK client.' )
                                        return 0
                                    endif
                                    execute s:py_cmd . 'import vim'
                                    execute s:pyfile_cmd . g:swank_path
                                    let s:python_initialized = 1
                                endif
                            
                            
                                if !s:swank_connected
                                    let s:swank_version = ''
                                    let s:lisp_version = ''
                                    if g:swank_host == ''
                                        let g:swank_host = input( 'Swank server host name: ', 'localhost' )
                                    endif
                                    execute s:py_cmd . 'swank_connect("' . g:swank_host . '", ' . g:swank_port . ', "result" )'
                                    if result != '' && ( g:swank_host == 'localhost' || g:swank_host == '127.0.0.1' )
                                        " SWANK server is not running, start server if possible
                                        let swank = SlimvSwankCommand()
                                        if swank != ''
                                            redraw
                                            echon "\rStarting SWANK server..."
                                            silent execute swank
                                            let starttime = localtime()
                                            while result != '' && localtime()-starttime < g:slimv_timeout
                                                sleep 500m
                                                execute s:py_cmd . 'swank_connect("' . g:swank_host . '", ' . g:swank_port . ', "result" )'
                                            endwhile
                                            redraw!
                                        endif
                                    endif
                                    if result != ''
                                        " Display connection error message
                                        call SlimvErrorWait( result )
                                        return 0
                                    endif
                            
                                    " Connected to SWANK server
                                    redraw
                                    echon "\rGetting SWANK connection info..."
                                    let starttime = localtime()
                                    while s:swank_version == '' && localtime()-starttime < g:slimv_timeout
                                        call SlimvSwankResponse()
                                    endwhile
                            
                                    " Require some contribs
                                    let contribs = 'swank-presentations swank-fancy-inspector swank-c-p-c swank-arglists'
                                    if SlimvGetFiletype() == 'lisp'
                                        let contribs = 'swank-asdf swank-package-fu ' . contribs
                                    endif
                                    if g:slimv_simple_compl == 0
                                        let contribs = contribs . ' swank-fuzzy'
                                    endif
                                    execute s:py_cmd . "swank_require('(" . contribs . ")')"
                                    call SlimvSwankResponse()
                                    if s:SinceVersion( '2011-12-04' )
                                        execute s:py_cmd . "swank_require('swank-repl')"
                                        call SlimvSwankResponse()
                                    endif
                                    if s:SinceVersion( '2008-12-23' )
                                        call SlimvCommandGetResponse( ':create-repl', s:py_cmd . 'swank_create_repl()', g:slimv_timeout )
                                    endif
                                    let s:swank_connected = 1
                                    redraw
                                    echon "\rConnected to SWANK server on port " . g:swank_port . "."
                                    if exists( "g:swank_block_size" ) && SlimvGetFiletype() == 'lisp'
                                        " Override SWANK connection output buffer size
                                        if s:SinceVersion( '2014-09-08' )
                                            let cmd = "(progn (setf (slot-value (swank::connection.user-output swank::*emacs-connection*) 'swank/gray::buffer)"
                                        else
                                            let cmd = "(progn (setf (slot-value (swank::connection.user-output swank::*emacs-connection*) 'swank-backend::buffer)"
                                        endif
                                        let cmd = cmd . " (make-string " . g:swank_block_size . ")) nil)"
                                        call SlimvSend( [cmd], 0, 1 )
                                    endif
                                    if exists( "*SlimvReplInit" )
                                        " Perform implementation specific REPL initialization if supplied
                                        call SlimvReplInit( s:lisp_version )
                                    endif
                                endif
                            
                                return s:swank_connected
                            endfunction
                            
                            " Send argument to Lisp server for evaluation
    1              0.000002 function! SlimvSend( args, echoing, output )
                                if ! SlimvConnectSwank()
                                    return
                                endif
                            
                                " Send the lines to the client for evaluation
                                let text = join( a:args, "\n" ) . "\n"
                            
                                let s:refresh_disabled = 1
                                let s:swank_form = text
                                if a:echoing && g:slimv_echolines != 0
                                    if g:slimv_echolines > 0
                                        let nlpos = match( s:swank_form, "\n", 0, g:slimv_echolines )
                                        if nlpos > 0
                                            " Echo only the first g:slimv_echolines number of lines
                                            let trimmed = strpart( s:swank_form, nlpos )
                                            let s:swank_form = strpart( s:swank_form, 0, nlpos )
                                            let ending = s:CloseForm( s:swank_form )
                                            if ending != 'ERROR'
                                                if substitute( trimmed, '\s\|\n', '', 'g' ) == ''
                                                    " Only whitespaces are trimmed
                                                    let s:swank_form = s:swank_form . ending . "\n"
                                                else
                                                    " Valuable characters trimmed, indicate it by printing "..."
                                                    let s:swank_form = s:swank_form . " ..." . ending . "\n"
                                                endif
                                            endif
                                        endif
                                    endif
                                    if a:output
                                        silent execute s:py_cmd . 'append_repl("s:swank_form", 1)'
                                    endif
                                    let s:swank_form = text
                                elseif a:output
                                    " Open a new line for the output
                                    silent execute s:py_cmd . " append_repl('\\n', 0)"
                                endif
                                call SlimvCommand( s:py_cmd . 'swank_input("s:swank_form")' )
                                let s:swank_package = ''
                                let s:swank_package_form = ''
                                let s:refresh_disabled = 0
                                call SlimvRefreshModeOn()
                                call SlimvRefreshReplBuffer()
                            endfunction
                            
                            " Eval arguments in Lisp REPL
    1              0.000003 function! SlimvEval( args )
                                call SlimvSend( a:args, 1, 1 )
                            endfunction
                            
                            " Send argument silently to SWANK
    1              0.000001 function! SlimvSendSilent( args )
                                call SlimvSend( a:args, 0, 0 )
                            endfunction
                            
                            " Set command line after the prompt
    1              0.000001 function! SlimvSetCommandLine( cmd )
                                let line = getline( "." )
                                if line( "." ) == s:GetPromptLine()
                                    " The prompt is in the line marked by b:repl_prompt_line
                                    let promptlen = len( b:repl_prompt )
                                else
                                    let promptlen = 0
                                endif
                                if len( line ) > promptlen
                                    let line = strpart( line, 0, promptlen )
                                endif
                            
                                if s:GetPromptLine() < line( '$' )
                                    " Delete extra lines after the prompt
                                    let c = col( '.' )
                                    execute (s:GetPromptLine()+1) . ',' . (line('$')) . 'd_'
                                    call cursor( line('.'), c )
                                endif
                            
                                let lines = split( a:cmd, '\n' )
                                if len(lines) > 0
                                    let line = line . lines[0]
                                endif
                                call setline( ".", line )
                                if len(lines) > 1
                                    call append( s:GetPromptLine(), lines[1:] )
                                endif
                                set nomodified
                            endfunction
                            
                            " Add command list to the command history
    1              0.000001 function! SlimvAddHistory( cmd )
                                if !exists( 'g:slimv_cmdhistory' )
                                    let g:slimv_cmdhistory = []
                                endif
                                let i = 0
                                let form = join( a:cmd, "\n" )
                                " Trim leading and trailing whitespaces from the command
                                let form = substitute( form, '^\s*\(.*[^ ]\)\s*', '\1', 'g' )
                                if len( form ) > 1 || len( g:slimv_cmdhistory ) == 0 || form != g:slimv_cmdhistory[-1]
                                    " Add command only if differs from the last one
                                    call add( g:slimv_cmdhistory, form )
                                endif
                                let g:slimv_cmdhistorypos = len( g:slimv_cmdhistory )
                            endfunction
                            
                            " Recall command from the command history at the marked position
    1              0.000001 function! SlimvRecallHistory( direction )
                                let searchtext = ''
                                let l = line( '.' )
                                let c = col( '.' )
                                let set_cursor_pos = 0
                                if line( '.' ) == s:GetPromptLine() && c > b:repl_prompt_col
                                    " Search for lines beginning with the text up to the cursor position
                                    let searchtext = strpart( getline('.'), b:repl_prompt_col-1, c-b:repl_prompt_col )
                                    let searchtext = substitute( searchtext, '^\s*$', '', 'g' )
                                    let searchtext = substitute( searchtext, '^\s*\(.*[^ ]\)', '\1', 'g' )
                                endif
                                let historypos = g:slimv_cmdhistorypos
                                let g:slimv_cmdhistorypos = g:slimv_cmdhistorypos + a:direction
                                while g:slimv_cmdhistorypos >= 0 && g:slimv_cmdhistorypos < len( g:slimv_cmdhistory )
                                    let cmd = g:slimv_cmdhistory[g:slimv_cmdhistorypos]
                                    if len(cmd) >= len(searchtext) && strpart(cmd, 0, len(searchtext)) == searchtext
                                        call SlimvSetCommandLine( g:slimv_cmdhistory[g:slimv_cmdhistorypos] )
                                        return
                                    endif
                                    let g:slimv_cmdhistorypos = g:slimv_cmdhistorypos + a:direction
                                endwhile
                                if searchtext == ''
                                    call SlimvSetCommandLine( "" )
                                else
                                    let g:slimv_cmdhistorypos = historypos
                                endif
                            endfunction
                            
                            " Return missing parens, double quotes, etc to properly close form
    1              0.000002 function! s:CloseForm( form )
                                let end = ''
                                let i = 0
                                while i < len( a:form )
                                    if a:form[i] == '"'
                                        " Inside a string
                                        let end = '"' . end
                                        let i += 1
                                        while i < len( a:form )
                                            if a:form[i] == '\'
                                                " Ignore next character
                                                let i += 2
                                            elseif a:form[i] == '"'
                                                let end = end[1:]
                                                break
                                            else
                                                let i += 1
                                            endif
                                        endwhile
                                    elseif a:form[i] == ';'
                                        " Inside a comment
                                        let end = "\n" . end
                                        let cend = match(a:form, "\n", i)
                                        if cend == -1
                                            break
                                        endif
                                        let i = cend
                                        let end = end[1:]
                                    else
                                        " We are outside of strings and comments, now we shall count parens
                                        if a:form[i] == '('
                                            let end = ')' . end
                                        elseif a:form[i] == '[' && SlimvGetFiletype() =~ '.*\(clojure\|scheme\|racket\).*'
                                            let end = ']' . end
                                        elseif a:form[i] == '{' && SlimvGetFiletype() =~ '.*\(clojure\|scheme\|racket\).*'
                                            let end = '}' . end
                                        elseif a:form[i] == ')' || ((a:form[i] == ']' || a:form[i] == '}') && SlimvGetFiletype() =~ '.*\(clojure\|scheme\|racket\).*')
                                            if len( end ) == 0 || end[0] != a:form[i]
                                                " Oops, too many closing parens or invalid closing paren
                                                return 'ERROR'
                                            endif
                                            let end = end[1:]
                                        endif
                                    endif
                                    let i += 1
                                endwhile
                                return end
                            endfunction
                            
                            " Some multi-byte characters screw up the built-in lispindent()
                            " This function is a wrapper that tries to fix it
                            " TODO: implement custom indent procedure and omit lispindent()
    1              0.000001 function SlimvLispindent( lnum )
                                set lisp
                                if SlimvGetFiletype() =~ '.*clojure.*' && exists( '*GetClojureIndent' ) && line('.') == a:lnum
                                    let li = GetClojureIndent()
                                else
                                    let li = lispindent( a:lnum )
                                endif
                                set nolisp
                                let backline = max([a:lnum-g:slimv_indent_maxlines, 1])
                                let oldpos = getpos( '.' )
                                call cursor( oldpos[1], 1 )
                                " Find containing form
                                let [lhead, chead] = searchpairpos( '(', '', ')', 'bW', s:skip_sc, backline )
                                if lhead == 0
                                    " No containing form, lispindent() is OK
                                    call cursor( oldpos[1], oldpos[2] )
                                    return li
                                endif
                                " Find outer form
                                let [lparent, cparent] = searchpairpos( '(', '', ')', 'bW', s:skip_sc, backline )
                                call cursor( oldpos[1], oldpos[2] )
                                if lparent == 0 || lhead != lparent
                                    " No outer form or starting above inner form, lispindent() is OK
                                    return li
                                endif
                                " Count extra bytes before the function header
                                let header = strpart( getline( lparent ), 0 )
                                let total_extra = 0
                                let extra = 0
                                let c = 0
                                while a:lnum > 0 && c < chead-1
                                    let bytes = byteidx( header, c+1 ) - byteidx( header, c )
                                    if bytes > 1
                                        let total_extra = total_extra + bytes - 1
                                        if c >= cparent && extra < 10
                                            " Extra bytes in the outer function header
                                            let extra = extra + bytes - 1
                                        endif
                                    endif
                                    let c = c + 1
                                endwhile
                                if total_extra == 0  
                                    " No multi-byte character, lispindent() is OK
                                    return li
                                endif
                                " In some cases ending spaces add up to lispindent() if there are multi-byte characters
                                let ending_sp = len( matchstr( getline( lparent ), ' *$' ) )
                                " Determine how wrong lispindent() is based on the number of extra bytes
                                " These values were determined empirically
                                if lparent == a:lnum - 1
                                    " Function header is in the previous line
                                    if extra == 0 && total_extra > 1
                                        let ending_sp = ending_sp + 1
                                    endif
                                    return li + [0, 1, 0, -3, -3, -3, -5, -5, -7, -7, -8][extra] - ending_sp
                                else
                                    " Function header is in an upper line
                                    if extra == 0 || total_extra == extra
                                        let ending_sp = 0
                                    endif
                                    return li + [0, 1, 0, -2, -2, -3, -3, -3, -3, -3, -3][extra] - ending_sp
                                endif
                            endfunction
                            
                            " Return Lisp source code indentation at the given line
                            " Does not keep the cursor position
    1              0.000001 function! SlimvIndentUnsafe( lnum )
                                if &autoindent == 0 || a:lnum <= 1
                                    " Start of the file
                                    return 0
                                endif
                                let pnum = prevnonblank(a:lnum - 1)
                                if pnum == 0
                                    " Hit the start of the file, use zero indent.
                                    return 0
                                endif
                                let oldpos = getpos( '.' )
                                let linenum = a:lnum
                            
                                " Handle multi-line string
                                let plen = len( getline( pnum ) )
                                if synIDattr( synID( pnum, plen, 0), 'name' ) =~ '[Ss]tring' && getline(pnum)[plen-1] != '"'
                                    " Previous non-blank line ends with an unclosed string, so this is a multi-line string
                                    let [l, c] = searchpairpos( '"', '', '"', 'bnW', s:skip_q )
                                    if l == pnum && c > 0
                                        " Indent to the opening double quote (if found)
                                        return c
                                    else
                                        return SlimvLispindent( linenum )
                                    endif
                                endif
                                if synIDattr( synID( pnum, 1, 0), 'name' ) =~ '[Ss]tring' && getline(pnum)[0] != '"'
                                    " Previous non-blank line is the last line of a multi-line string
                                    call cursor( pnum, 1 )
                                    " First find the end of the multi-line string (omit \" characters)
                                    let [lend, cend] = searchpos( '[^\\]"', 'nW' )
                                    if lend > 0 && strpart(getline(lend), cend+1) =~ '(\|)\|\[\|\]\|{\|}'
                                        " Structural change after the string, no special handling
                                    else
                                        " Find the start of the multi-line string (omit \" characters)
                                        let [l, c] = searchpairpos( '"', '', '"', 'bnW', s:skip_q )
                                        if l > 0 && strpart(getline(l), 0, c-1) =~ '^\s*$'
                                            " Nothing else before the string: indent to the opening "
                                            return c - 1
                                        endif
                                        if l > 0
                                            " Pretend that we are really after the first line of the multi-line string
                                            let pnum = l
                                            let linenum = l + 1
                                        endif
                                    endif
                                    call cursor( oldpos[1], oldpos[2] )
                                endif
                            
                                " Handle special indentation style for flet, labels, etc.
                                " When searching for containing forms, don't go back
                                " more than g:slimv_indent_maxlines lines.
                                let backline = max([pnum-g:slimv_indent_maxlines, 1])
                                let indent_keylists = g:slimv_indent_keylists
                            
                                " Check if the previous line actually ends with a multi-line subform
                                let parent = pnum
                                let [l, c] = searchpos( ')', 'bW' )
                                if l == pnum
                                    let [l, c] = searchpairpos( '(', '', ')', 'bW', s:skip_sc, backline )
                                    if l > 0
                                        " Make sure it is not a top level form and the containing form starts in the same line
                                        let [l2, c2] = searchpairpos( '(', '', ')', 'bW', s:skip_sc, backline )
                                        if l2 == l
                                            " Remember the first line of the multi-line form
                                            let parent = l
                                        endif
                                    endif
                                endif
                            
                                " Find beginning of the innermost containing form
                                call cursor( oldpos[1], 1 )
                                let [l, c] = searchpairpos( '(', '', ')', 'bW', s:skip_sc, backline )
                                if l > 0
                                    if SlimvGetFiletype() =~ '.*\(clojure\|scheme\|racket\).*'
                                        " Is this a clojure form with [] binding list?
                                        call cursor( oldpos[1], oldpos[2] )
                                        let [lb, cb] = searchpairpos( '\[', '', '\]', 'bW', s:skip_sc, backline )
                                        if lb >= l && (lb > l || cb > c)
                                            return cb
                                        endif
                                        " Is this a multi-arity function definition?
                                        let line = strpart( getline(l), c-1 )
                                        if match( line, '(\s*\[' ) >= 0
                                            return c + 1
                                        endif
                                    endif
                                    " Is this a form with special indentation?
                                    let line = strpart( getline(l), c-1 )
                                    if match( line, '\c^(\s*\('.s:spec_indent.'\)\>' ) >= 0
                                        " Search for the binding list and jump to its end
                                        if search( '(' ) > 0
                                            call searchpair( '(', '', ')', '', s:skip_sc )
                                            if line('.') == pnum
                                                " We are indenting the first line after the end of the binding list
                                                return c + 1
                                            endif
                                        endif
                                    elseif l == pnum
                                        " If the containing form starts above this line then find the
                                        " second outer containing form (possible start of the binding list)
                                        let [l2, c2] = searchpairpos( '(', '', ')', 'bW', s:skip_sc, backline )
                                        if l2 > 0
                                            let line2 = strpart( getline(l2), c2-1 )
                                            if match( line2, '\c^(\s*\('.s:spec_param.'\)\>' ) >= 0
                                                if search( '(' ) > 0
                                                    if line('.') == l && col('.') == c
                                                        " This is the parameter list of a special form
                                                        return c
                                                    endif
                                                endif
                                            endif
                                            if SlimvGetFiletype() !~ '.*clojure.*'
                                                if l2 == l && match( line2, '\c^(\s*\('.s:binding_form.'\)\>' ) >= 0
                                                    " Is this a lisp form with binding list?
                                                    return c
                                                endif
                                                if match( line2, '\c^(\s*cond\>' ) >= 0 && match( line, '\c^(\s*t\>' ) >= 0
                                                    " Is this the 't' case for a 'cond' form?
                                                    return c
                                                endif
                                                if match( line2, '\c^(\s*defpackage\>' ) >= 0
                                                    let indent_keylists = 0
                                                endif
                                            endif
                                            " Go one level higher and check if we reached a special form
                                            let [l3, c3] = searchpairpos( '(', '', ')', 'bW', s:skip_sc, backline )
                                            if l3 > 0
                                                " Is this a form with special indentation?
                                                let line3 = strpart( getline(l3), c3-1 )
                                                if match( line3, '\c^(\s*\('.s:spec_indent.'\)\>' ) >= 0
                                                    " This is the first body-line of a binding
                                                    return c + 1
                                                endif
                                                if match( line3, '\c^(\s*defsystem\>' ) >= 0
                                                    let indent_keylists = 0
                                                endif
                                                " Finally go to the topmost level to check for some forms with special keyword indenting
                                                let [l4, c4] = searchpairpos( '(', '', ')', 'brW', s:skip_sc, backline )
                                                if l4 > 0
                                                    let line4 = strpart( getline(l4), c4-1 )
                                                    if match( line4, '\c^(\s*defsystem\>' ) >= 0
                                                        let indent_keylists = 0
                                                    endif
                                                endif
                                            endif
                                        endif
                                    endif
                                endif
                            
                                " Restore all cursor movements
                                call cursor( oldpos[1], oldpos[2] )
                            
                                " Check if the current form started in the previous nonblank line
                                if l == parent
                                    " Found opening paren in the previous line
                                    let line = getline(l)
                                    let form = strpart( line, c )
                                    " Determine the length of the function part up to the 1st argument
                                    let funclen = matchend( form, '\s*\S*\s*' ) + 1
                                    " Contract strings, remove comments
                                    let form = substitute( form, '".\{-}[^\\]"', '""', 'g' )
                                    let form = substitute( form, ';.*$', '', 'g' )
                                    " Contract subforms by replacing them with a single character
                                    let f = ''
                                    while form != f
                                        let f = form
                                        let form = substitute( form, '([^()]*)',     '0', 'g' )
                                        let form = substitute( form, '([^()]*$',     '0', 'g' )
                                        let form = substitute( form, '\[[^\[\]]*\]', '0', 'g' )
                                        let form = substitute( form, '\[[^\[\]]*$',  '0', 'g' )
                                        let form = substitute( form, '{[^{}]*}',     '0', 'g' )
                                        let form = substitute( form, '{[^{}]*$',     '0', 'g' )
                                    endwhile
                                    " Find out the function name
                                    let func = matchstr( form, '\<\k*\>' )
                                    " If it's a keyword, keep the indentation straight
                                    if indent_keylists && strpart(func, 0, 1) == ':'
                                        if form =~ '^:\S*\s\+\S'
                                            " This keyword has an associated value in the same line
                                            return c
                                        else
                                            " The keyword stands alone in its line with no associated value
                                            return c + 1
                                        endif
                                    endif
                                    " Fix indentation issues not handled by the default lisp.vim
                                    if SlimvGetFiletype() =~ '.*clojure.*'
                                        if match( func, 'defn$' ) >= 0
                                            return c + 1
                                        endif
                                    elseif SlimvGetFiletype() =~ '.*\(scheme\|racket\).*'
                                        if match( func, 'syntax-rules$' ) >= 0
                                            return c + 1
                                        endif
                                    else
                                        if match( func, 'defgeneric$' ) >= 0 || match( func, 'defsystem$' ) >= 0 || match( func, 'aif$' ) >= 0
                                            return c + 1
                                        endif
                                    endif
                                    if match( func, 'if$' ) >= 0 || match( func, 'do$' ) >= 0
                                        return c + funclen - 1
                                    endif
                                    " Remove package specification
                                    let func = substitute(func, '^.*:', '', '')
                                    if func != '' && s:swank_connected
                                        " Look how many arguments are on the same line
                                        " If an argument is actually a multi-line subform, then replace it with a single character
                                        let form = substitute( form, "([^()]*$", '0', 'g' )
                                        let form = substitute( form, "[()\\[\\]{}#'`,]", '', 'g' )
                                        let args_here = len( split( form ) ) - 1
                                        " Get swank indent info
                                        let s:indent = ''
                                        silent execute s:py_cmd . 'get_indent_info("' . func . '")'
                                        if s:indent != '' && s:indent == args_here
                                            " The next one is an &body argument, so indent by 2 spaces from the opening '('
                                            return c + 1
                                        endif
                                        let llen = len( line )
                                        if synIDattr( synID( l, llen, 0), 'name' ) =~ '[Ss]tring' && line[llen-1] != '"'
                                            " Parent line ends with a multi-line string
                                            " lispindent() fails to handle it correctly
                                            if s:indent == '' && args_here > 0
                                                " No &body argument, ignore lispindent() and indent to the 1st argument
                                                return c + funclen - 1
                                            endif
                                        endif
                                    endif
                                endif
                            
                                " Use default Lisp indenting
                                let li = SlimvLispindent(linenum)
                                let line = strpart( getline(linenum-1), li-1 )
                                let gap = matchend( line, '^(\s\+\S' )
                                if gap >= 0
                                    " Align to the gap between the opening paren and the first atom
                                    return li + gap - 2
                                endif
                                return li
                            endfunction 
                            
                            " Indentation routine, keeps original cursor position
    1              0.000004 function! SlimvIndent( lnum )
                                let oldpos = getpos( '.' )
                                let indent = SlimvIndentUnsafe( a:lnum )
                                call cursor( oldpos[1], oldpos[2] )
                                return indent
                            endfunction
                            
                            " Convert indent value to spaces or a mix of tabs and spaces
                            " depending on the value of 'expandtab'
    1              0.000003 function! s:MakeIndent( indent )
                                if &expandtab
                                    return repeat( ' ', a:indent )
                                else
                                    return repeat( "\<Tab>", a:indent / &tabstop ) . repeat( ' ', a:indent % &tabstop )
                                endif
                            endfunction
                            
                            " Send command line to REPL buffer
                            " Arguments: close = add missing closing parens
    1              0.000002 function! SlimvSendCommand( close )
                                call SlimvRefreshModeOn()
                                let lastline = s:GetPromptLine()
                                let lastcol  = b:repl_prompt_col
                                if lastline > 0
                                    if line( "." ) >= lastline
                                        " Trim the prompt from the beginning of the command line
                                        " The user might have overwritten some parts of the prompt
                                        let cmdline = getline( lastline )
                                        let c = 0
                                        while c < lastcol - 1 && cmdline[c] == b:repl_prompt[c]
                                            let c = c + 1
                                        endwhile
                                        let cmd = [ strpart( getline( lastline ), c ) ]
                            
                                        " Build a possible multi-line command
                                        let l = lastline + 1
                                        while l <= line("$")
                                            call add( cmd, strpart( getline( l ), 0) )
                                            let l = l + 1
                                        endwhile
                            
                                        " Count the number of opening and closing braces
                                        let end = s:CloseForm( join( cmd, "\n" ) )
                                        if end == 'ERROR'
                                            " Too many closing parens
                                            call SlimvErrorWait( "Too many or invalid closing parens found." )
                                            return
                                        endif
                                        let echoing = 0
                                        if a:close && end != ''
                                            " Close form if necessary and evaluate it
                                            let cmd[len(cmd)-1] = cmd[len(cmd)-1] . end
                                            let end = ''
                                            let echoing = 1
                                        endif
                                        if end == ''
                                            " Expression finished, let's evaluate it
                                            " but first add it to the history
                                            call SlimvAddHistory( cmd )
                                            " Evaluate, but echo only when form is actually closed here
                                            call SlimvSend( cmd, echoing, 1 )
                                        else
                                            " Expression is not finished yet, indent properly and wait for completion
                                            " Indentation works only if lisp indentation is switched on
                                            call SlimvArglist()
                                            let l = line('.') + 1
                                            call append( '.', '' )
                                            call setline( l, s:MakeIndent( SlimvIndent(l) ) )
                                            normal! j$
                                        endif
                                    endif
                                else
                                    silent execute s:py_cmd . " append_repl('Slimv error: previous EOF mark not found, re-enter last form:\\n', 0)"
                                endif
                            endfunction
                            
                            " Close current top level form by adding the missing parens
    1              0.000002 function! SlimvCloseForm()
                                let l2 = line( '.' )
                                call SlimvFindDefunStart()
                                let l1 = line( '.' )
                                let form = []
                                let l = l1
                                while l <= l2
                                    call add( form, getline( l ) )
                                    let l = l + 1
                                endwhile
                                let end = s:CloseForm( join( form, "\n" ) )
                                if end == 'ERROR'
                                    " Too many closing parens
                                    call SlimvErrorWait( "Too many or invalid closing parens found." )
                                elseif end != ''
                                    " Add missing parens
                                    if end[0] == "\n"
                                        call append( l2, end[1:] )
                                    else
                                        call setline( l2, getline( l2 ) . end )
                                    endif
                                endif
                                normal! %
                            endfunction
                            
                            " Handle insert mode 'Enter' keypress
    1              0.000001 function! SlimvHandleEnter()
                                let s:arglist_line = line('.')
                                let s:arglist_col = col('.')
                                if pumvisible()
                                    " Pressing <CR> in a pop up selects entry.
                                    return "\<C-Y>"
                                else
                                    if exists( 'g:paredit_mode' ) && g:paredit_mode && g:paredit_electric_return
                                        " Apply electric return
                                        return PareditEnter()
                                    else
                                        " No electric return handling, just enter a newline
                                        return "\<CR>"
                                    endif
                                endif
                            endfunction
                            
                            " Display arglist after pressing Enter
    1              0.000001 function! SlimvArglistOnEnter()
                                let retval = ""
                                if s:arglist_line > 0
                                    if col('.') > len(getline('.'))
                                        " Stay at the end of line
                                        let retval = "\<End>"
                                    endif
                                    let l = line('.')
                                    if getline(l) == ''
                                        " Add spaces to make the correct indentation
                                        call setline( l, s:MakeIndent( SlimvIndent(l) ) )
                                        normal! $
                                    endif
                                    call SlimvArglist( s:arglist_line, s:arglist_col )
                                endif
                                let s:arglist_line = 0
                                let s:arglist_col = 0
                            
                                " This function is called from <C-R>= mappings, return additional keypress
                                return retval
                            endfunction
                            
                            " Handle insert mode 'Tab' keypress by doing completion or indentation
    1              0.000001 function! SlimvHandleTab()
                                if pumvisible()
                                    " Completions menu is active, go to next match
                                    return "\<C-N>"
                                endif
                                let c = col('.')
                                if c > 1 && getline('.')[c-2] =~ '\k'
                                    " At the end of a keyword, bring up completions
                                    return "\<C-X>\<C-O>"
                                endif
                                let indent = SlimvIndent(line('.'))
                                if c-1 < indent && getline('.') !~ '\S\+'
                                    " We are left from the autoindent position, do an autoindent
                                    call setline( line('.'), s:MakeIndent( indent ) )
                                    return "\<End>"
                                endif
                                " No keyword to complete, no need for autoindent, just enter a <Tab>
                                return "\<Tab>"
                            endfunction
                            
                            " Handle insert mode 'Backspace' keypress in the REPL buffer
    1              0.000001 function! SlimvHandleBS()
                                if line( "." ) == s:GetPromptLine() && col( "." ) <= b:repl_prompt_col
                                    " No BS allowed before the previous EOF mark
                                    return ""
                                else
                                    return "\<BS>"
                                endif
                            endfunction
                            
                            " Handle insert mode Ctrl-W keypress in the REPL buffer
    1              0.000001 function! SlimvHandleCW()
                                if line( "." ) == s:GetPromptLine()
                                    let trim_prompt = substitute( b:repl_prompt, '\s\+$', '', 'g' )
                                    let promptlen = len( trim_prompt )
                                    if col( "." ) > promptlen
                                        let after_prompt = strpart( getline("."), promptlen-1, col(".")-promptlen )
                                    else
                                        let after_prompt = ''
                                    endif
                                    let word = matchstr( after_prompt, '^.*\s\S' )
                                    if len( word ) == 0
                                        " No word found after prompt, C-W not allowed
                                        return ""
                                    endif
                                endif
                                return "\<C-W>"
                            endfunction
                            
                            " Recall previous command from command history
    1              0.000002 function! s:PreviousCommand()
                                if exists( 'g:slimv_cmdhistory' ) && g:slimv_cmdhistorypos > 0
                                    call SlimvRecallHistory( -1 )
                                endif
                            endfunction
                            
                            " Recall next command from command history
    1              0.000002 function! s:NextCommand()
                                if exists( 'g:slimv_cmdhistory' ) && g:slimv_cmdhistorypos < len( g:slimv_cmdhistory )
                                    call SlimvRecallHistory( 1 )
                                else
                                    call SlimvSetCommandLine( "" )
                                endif
                            endfunction
                            
                            " Handle insert mode 'Up' keypress in the REPL buffer
    1              0.000001 function! SlimvHandleUp()
                                let save_ve = &virtualedit
                                set virtualedit=onemore
                                if line( "." ) >= s:GetPromptLine()
                                    call s:PreviousCommand()
                                else
                                    normal! gk
                                endif
                                let &virtualedit=save_ve
                                return ''
                            endfunction
                            
                            " Handle insert mode 'Down' keypress in the REPL buffer
    1              0.000001 function! SlimvHandleDown()
                                let save_ve = &virtualedit
                                set virtualedit=onemore
                                if line( "." ) >= s:GetPromptLine()
                                    call s:NextCommand()
                                else
                                    normal! gj
                                endif
                                let &virtualedit=save_ve
                                return ''
                            endfunction
                            
                            " Make a fold at the cursor point in the current buffer
    1              0.000001 function SlimvMakeFold()
                                setlocal modifiable
                                normal! o    }}}kA {{{0
                                setlocal nomodifiable
                            endfunction
                            
                            " Handle insert mode 'Enter' keypress in the REPL buffer
    1              0.000001 function! SlimvHandleEnterRepl()
                                " Trim the prompt from the beginning of the command line
                                " The user might have overwritten some parts of the prompt
                                let lastline = s:GetPromptLine()
                                let lastcol  = b:repl_prompt_col
                                let cmdline = getline( lastline )
                                let c = 0
                                while c < lastcol - 1 && cmdline[c] == b:repl_prompt[c]
                                    let c = c + 1
                                endwhile
                            
                                " Copy command line up to the cursor position
                                if line(".") == lastline
                                    let cmd = [ strpart( cmdline, c, col(".") - c - 1 ) ]
                                else
                                    let cmd = [ strpart( cmdline, c ) ]
                                endif
                            
                                " Build a possible multi-line command up to the cursor line/position
                                let l = lastline + 1
                                while l <= line(".")
                                    if line(".") == l
                                        call add( cmd, strpart( getline( l ), 0, col(".") - 1) )
                                    else
                                        call add( cmd, strpart( getline( l ), 0) )
                                    endif
                                    let l = l + 1
                                endwhile
                            
                                " Count the number of opening and closing braces in the command before the cursor
                                let end = s:CloseForm( join( cmd, "\n" ) )
                                if end != 'ERROR' && end != ''
                                    " Command part before cursor is unbalanced, insert newline
                                    let s:arglist_line = line('.')
                                    let s:arglist_col = col('.')
                                    if pumvisible()
                                        " Pressing <CR> in a pop up selects entry.
                                        return "\<C-Y>"
                                    else
                                        if exists( 'g:paredit_mode' ) && g:paredit_mode && g:paredit_electric_return && lastline > 0 && line( "." ) >= lastline
                                            " Apply electric return
                                            return PareditEnter()
                                        else
                                            " No electric return handling, just enter a newline
                                            return "\<CR>"
                                        endif
                                    endif
                                else
                                    " Send current command line for evaluation
                                    if &virtualedit != 'all'
                                        call cursor( 0, 99999 )
                                    endif
                                    call SlimvSendCommand(0)
                                endif
                                return ''
                            endfunction
                            
                            " Handle normal mode 'Enter' keypress in the SLDB buffer
    1              0.000001 function! SlimvHandleEnterSldb()
                                let line = getline('.')
                                if s:sldb_level >= 0
                                    " Check if Enter was pressed in a section printed by the SWANK debugger
                                    " The source specification is within a fold, so it has to be tested first
                                    let mlist = matchlist( line, '^\s\+in "\=\(.*\)"\= \(line\|byte\) \(\d\+\)$' )
                                    if len(mlist)
                                        if g:slimv_repl_split
                                            " Switch back to other window
                                            execute "wincmd p"
                                        endif
                                        " Jump to the file at the specified position
                                        if mlist[2] == 'line'
                                            exec ":edit +" . mlist[3] . " " . mlist[1]
                                        else
                                            exec ":edit +" . mlist[3] . "go " . mlist[1]
                                        endif
                                        return
                                    endif
                                    if foldlevel('.')
                                        " With a fold just toggle visibility
                                        normal za
                                        return
                                    endif
                                    let item = matchstr( line, s:frame_def )
                                    if item != ''
                                        let item = substitute( item, '\s\|:', '', 'g' )
                                        if search( '^Backtrace:', 'bnW' ) > 0
                                            " Display item-th frame
                                            call SlimvMakeFold()
                                            silent execute s:py_cmd . 'swank_frame_locals("' . item . '")'
                                            if SlimvGetFiletype() != 'scheme' && g:slimv_impl != 'clisp'
                                                " Not implemented for CLISP or scheme
                                                silent execute s:py_cmd . 'swank_frame_source_loc("' . item . '")'
                                            endif
                                            if SlimvGetFiletype() == 'lisp' && g:slimv_impl != 'clisp' && g:slimv_impl != 'allegro'
                                                " Not implemented for CLISP or other lisp dialects
                                                silent execute s:py_cmd . 'swank_frame_call("' . item . '")'
                                            endif
                                            call SlimvRefreshReplBuffer()
                                            return
                                        endif
                                        if search( '^Restarts:', 'bnW' ) > 0
                                            " Apply item-th restart
                                            call SlimvQuitSldb()
                                            silent execute s:py_cmd . 'swank_invoke_restart("' . s:sldb_level . '", "' . item . '")'
                                            call SlimvRefreshReplBuffer()
                                            return
                                        endif
                                    endif
                                endif
                            
                                " No special treatment, perform the original function
                                execute "normal! \<CR>"
                            endfunction
                            
                            " Restore Inspector cursor position if the referenced title has already been visited
    1              0.000002 function SlimvSetInspectPos( title )
                                if exists( 'b:inspect_pos' ) && has_key( b:inspect_pos, a:title )
                                    call winrestview( b:inspect_pos[a:title] )
                                else
                                    normal! gg0
                                endif
                            endfunction
                            
                            " Handle normal mode 'Enter' keypress in the Inspector buffer
    1              0.000001 function! SlimvHandleEnterInspect()
                                let line = getline('.')
                                if line[0:9] == 'Inspecting'
                                    " Reload inspected item
                                    call SlimvSendSilent( ['[0]'] )
                                    return
                                endif
                            
                                " Find the closest [dd] or <dd> token to the left of the cursor
                                let [l, c] = searchpos( '{\[\d\+\]', 'bncW' )
                                let [l2, c2] = searchpos( '{<\d\+>', 'bncW' )
                                if l < line('.') || (l2 == line('.') && c2 > c)
                                    let l = l2
                                    let c = c2
                                endif
                            
                                if l < line('.')
                                    " No preceding token found, find the closest [dd] or <dd> to the right
                                    let [l, c] = searchpos( '{\[\d\+\]', 'ncW' )
                                    let [l2, c2] = searchpos( '{<\d\+>', 'ncW' )
                                    if l == 0 || l > line('.') || (l2 == line('.') && c2 < c)
                                        let l = l2
                                        let c = c2
                                    endif
                                endif
                            
                                if l == line( '.' )
                                    " Keep the relevant part of the line
                                    let line = strpart( line, c )
                                endif
                            
                                if exists( 'b:inspect_title' ) && b:inspect_title != ''
                                    " Save cursor position in case we'll return to this page later on
                                    if !exists( 'b:inspect_pos' )
                                        let b:inspect_pos = {}
                                    endif
                            	let b:inspect_pos[b:inspect_title] = winsaveview()
                                endif
                            
                                if line[0] == '['
                                    if line =~ '^\[--more--\]$'
                                        " More data follows, fetch next part
                                        call SlimvCommand( s:py_cmd . 'swank_inspector_range()' )
                                        call SlimvRefreshReplBuffer()
                                        return
                                    elseif line =~ '^\[--all---\]$'
                                        " More data follows, fetch all parts
                                        echon "\rFetching all entries, please wait..."
                                        let b:inspect_more = -1
                                        call SlimvCommand( s:py_cmd . 'swank_inspector_range()' )
                                        call SlimvRefreshReplBuffer()
                                        let starttime = localtime()
                                        while b:inspect_more < 0 && localtime()-starttime < g:slimv_timeout
                                            " Wait for the first swank_inspector_range() call to finish
                                            call SlimvRefreshReplBuffer()
                                        endwhile
                                        let starttime = localtime()
                                        while b:inspect_more > 0 && localtime()-starttime < g:slimv_timeout
                                            " There are more parts to fetch (1 entry is usually 4 parts)
                                            echon "\rFetching all entries, please wait [" . (b:inspect_more / 4) . "]"
                                            call SlimvCommand( s:py_cmd . 'swank_inspector_range()' )
                                            call SlimvRefreshReplBuffer()
                                            if getchar(1)
                                                " User is impatient, stop fetching
                                                break
                                            endif
                                        endwhile
                                        if b:inspect_more > 0
                                            echon "\rFetch exhausted. Select [--all---] to resume."
                                        else
                                            echon "\rSuccessfully fetched all entries."
                                        endif
                                        return
                                    elseif line[0:3] == '[<<]'
                                        " Pop back up in the inspector
                                        let item = '-1'
                                    else
                                        " Inspect n-th part
                                        let item = matchstr( line, '\d\+' )
                                        if item != ''
                                            " Add item name to the object path
                                            let entry = matchstr(line, '\[\d\+\]\s*\zs.\{-}\ze\s*\[\]}')
                                            if entry == ''
                                                let entry = matchstr(line, '\[\d\+\]\s*\zs.*')
                                            endif
                                            if entry == ''
                                                let entry = 'Unknown object'
                                            endif
                                            if len( entry ) > 40
                                                " Crop if too long
                                                let entry = strpart( entry, 0, 37 ) . '...'
                                            endif
                                            let s:inspect_path = s:inspect_path + [entry]
                                        endif
                                    endif
                                    if item != ''
                                        call SlimvSendSilent( ['[' . item . ']'] )
                                        return
                                    endif
                                endif
                            
                                if line[0] == '<'
                                    " Inspector n-th action
                                    let item = matchstr( line, '\d\+' )
                                    if item != ''
                                        call SlimvSendSilent( ['<' . item . '>'] )
                                        return
                                    endif
                                endif
                            
                                " No special treatment, perform the original function
                                execute "normal! \<CR>"
                            endfunction
                            
                            " Go to command line and recall previous command from command history
    1              0.000001 function! SlimvPreviousCommand()
                                let save_ve = &virtualedit
                                set virtualedit=onemore
                                call SlimvEndOfReplBuffer(0)
                                if line( "." ) >= s:GetPromptLine()
                                    call s:PreviousCommand()
                                endif
                                let &virtualedit=save_ve
                            endfunction
                            
                            " Go to command line and recall next command from command history
    1              0.000001 function! SlimvNextCommand()
                                let save_ve = &virtualedit
                                set virtualedit=onemore
                                call SlimvEndOfReplBuffer(0)
                                if line( "." ) >= s:GetPromptLine()
                                    call s:NextCommand()
                                endif
                                let &virtualedit=save_ve
                            endfunction
                            
                            " Handle interrupt (Ctrl-C) keypress in the REPL buffer
    1              0.000001 function! SlimvInterrupt()
                                call SlimvCommand( s:py_cmd . 'swank_interrupt()' )
                                call SlimvRefreshReplBuffer()
                            endfunction
                            
                            " Select a specific restart in debugger
    1              0.000002 function! SlimvDebugCommand( name, cmd )
                                if SlimvConnectSwank()
                                    if s:sldb_level >= 0
                                        if bufname('%') != g:slimv_sldb_name
                                            call SlimvOpenSldbBuffer()
                                        endif
                                        call SlimvCommand( s:py_cmd . '' . a:cmd . '()' )
                                        call SlimvRefreshReplBuffer()
                                        if s:sldb_level < 0
                                            " Swank exited the debugger
                                            if bufname('%') != g:slimv_sldb_name
                                                call SlimvOpenSldbBuffer()
                                            endif
                                            call SlimvQuitSldb()
                                        else
                                            echomsg 'Debugger re-activated by the SWANK server.'
                                        endif
                                    else
                                        call SlimvError( "Debugger is not activated." )
                                    endif
                                endif
                            endfunction
                            
                            " Various debugger restarts
    1              0.000001 function! SlimvDebugAbort()
                                call SlimvDebugCommand( ":sldb-abort", "swank_invoke_abort" )
                            endfunction
                            
    1              0.000001 function! SlimvDebugQuit()
                                call SlimvDebugCommand( ":throw-to-toplevel", "swank_throw_toplevel" )
                            endfunction
                            
    1              0.000001 function! SlimvDebugContinue()
                                call SlimvDebugCommand( ":sldb-continue", "swank_invoke_continue" )
                            endfunction
                            
                            " Restart execution of the frame with the same arguments
    1              0.000002 function! SlimvDebugRestartFrame()
                                let frame = s:DebugFrame()
                                if frame != ''
                                    call SlimvCommand( s:py_cmd . 'swank_restart_frame("' . frame . '")' )
                                    call SlimvRefreshReplBuffer()
                                endif
                            endfunction
                            
                            " List current Lisp threads
    1              0.000001 function! SlimvListThreads()
                                if SlimvConnectSwank()
                                    call SlimvCommand( s:py_cmd . 'swank_list_threads()' )
                                    call SlimvRefreshReplBuffer()
                                endif
                            endfunction
                            
                            " Kill thread(s) selected from the Thread List
    1              0.000001 function! SlimvKillThread() range
                                if SlimvConnectSwank()
                                    if a:firstline == a:lastline
                                        let line = getline('.')
                                        let item = matchstr( line, '\d\+' )
                                        if bufname('%') != g:slimv_threads_name
                                            " We are not in the Threads buffer, not sure which thread to kill
                                            let item = input( 'Thread to kill: ', item )
                                        endif
                                        if item != ''
                                            call SlimvCommand( s:py_cmd . 'swank_kill_thread(' . item . ')' )
                                            call SlimvRefreshReplBuffer()
                                        endif
                                        echomsg 'Thread ' . item . ' is killed.'
                                    else
                                        for line in getline(a:firstline, a:lastline)
                                            let item = matchstr( line, '\d\+' )
                                            if item != ''
                                                call SlimvCommand( s:py_cmd . 'swank_kill_thread(' . item . ')' )
                                            endif
                                        endfor
                                        call SlimvRefreshReplBuffer()
                                    endif
                                    call SlimvListThreads()
                                endif
                            endfunction
                            
                            " Debug thread selected from the Thread List
    1              0.000001 function! SlimvDebugThread()
                                if SlimvConnectSwank()
                                    let line = getline('.')
                                    let item = matchstr( line, '\d\+' )
                                    let item = input( 'Thread to debug: ', item )
                                    if item != ''
                                        call SlimvCommand( s:py_cmd . 'swank_debug_thread(' . item . ')' )
                                        call SlimvRefreshReplBuffer()
                                    endif
                                endif
                            endfunction
                            
    1              0.000001 function! SlimvRFunction()
                                " search backwards for the alphanums before a '('
                                let l = line('.')
                                let c = col('.') - 1
                                let line = (getline('.'))[0:c]
                                let list = matchlist(line, '\([a-zA-Z0-9_.]\+\)\s*(')
                                if !len(list)
                                    return ""
                                endif
                                let valid = filter(reverse(list), 'v:val != ""')
                                return valid[0]
                            endfunction
                            
                            " Display function argument list
                            " Optional argument is the number of characters typed after the keyword
    1              0.000001 function! SlimvArglist( ... )
                                let retval = ''
                                let save_ve = &virtualedit
                                set virtualedit=all
                                if a:0
                                    " Symbol position supplied
                                    let l = a:1
                                    let c = a:2 - 1
                                    let line = getline(l)
                                else
                                    " Check symbol at cursor position
                                    let l = line('.')
                                    let line = getline(l)
                                    let c = col('.') - 1
                                    if c >= len(line)
                                        " Stay at the end of line
                                        let c = len(line) - 1
                                        let retval = "\<End>"
                                    endif
                                    if line[c-1] == ' '
                                        " Is this the space we have just inserted in a mapping?
                                        let c = c - 1
                                    endif
                                endif
                                call s:SetKeyword()
                                if s:swank_connected && !s:read_string_mode && c > 0 && line[c-1] =~ '\k\|)\|\]\|}\|"'
                                    " Display only if entering the first space after a keyword
                                    let arg = ''
                                    if SlimvGetFiletype() == 'r'
                                        let arg = SlimvRFunction()
                                    else
                                        let matchb = max( [l-200, 1] )
                                        let [l0, c0] = searchpairpos( '(', '', ')', 'nbW', s:skip_sc, matchb )
                                        if l0 > 0
                                            " Found opening paren, let's find out the function name
                                            while arg == '' && l0 <= l
                                                let funcline = substitute( getline(l0), ';.*$', '', 'g' )
                                                let arg = matchstr( funcline, '\<\k*\>', c0 )
                                                let l0 = l0 + 1
                                                let c0 = 0
                                            endwhile
                                        endif
                                    endif
                            
                                    if arg != ''
                                        " Ask function argument list from SWANK
                                        call SlimvFindPackage()
                                        let msg = SlimvCommandGetResponse( ':operator-arglist', s:py_cmd . 'swank_op_arglist("' . arg . '")', 0 )
                                        if msg != ''
                                            " Print argument list in status line with newlines removed.
                                            " Disable showmode until the next ESC to prevent
                                            " immeditate overwriting by the "-- INSERT --" text.
                                            set noshowmode
                                            let msg = substitute( msg, "\n", "", "g" )
                                            redraw
                                            if SlimvGetFiletype() == 'r'
                                                call SlimvShortEcho( arg . '(' . msg . ')' )
                                            elseif match( msg, "\\V" . arg ) != 1 " Use \V ('very nomagic') for exact string match instead of regex 
                                                " Function name is not received from REPL
                                                call SlimvShortEcho( "(" . arg . ' ' . msg[1:] )
                                            else
                                                call SlimvShortEcho( msg )
                                            endif
                                        endif
                                    endif
                                endif
                            
                                " This function is also called from <C-R>= mappings, return additional keypress
                                let &virtualedit=save_ve
                                return retval
                            endfunction
                            
                            " Start and connect swank server
    1              0.000001 function! SlimvConnectServer()
                                if s:swank_connected
                                    execute s:py_cmd . "swank_disconnect()"
                                    let s:swank_connected = 0
                            	" Give swank server some time for disconnecting
                                    sleep 500m
                                endif 
                                if SlimvConnectSwank()
                                    let repl_win = bufwinnr( s:repl_buf )
                                    if s:repl_buf == -1 || ( g:slimv_repl_split && repl_win == -1 )
                                        call SlimvOpenReplBuffer()
                                    endif
                                endif
                            endfunction
                            
                            " Get the last region (visual block)
    1              0.000002 function! SlimvGetRegion(first, last)
                                let oldpos = winsaveview()
                                if a:first < a:last || ( a:first == line( "'<" ) && a:last == line( "'>" ) )
                                    let lines = getline( a:first, a:last )
                                else
                                    " No range was selected, select current paragraph
                                    normal! vap
                                    execute "normal! \<Esc>"
                                    call winrestview( oldpos ) 
                                    let lines = getline( "'<", "'>" )
                                    if lines == [] || lines == ['']
                                        call SlimvError( "No range selected." )
                                        return []
                                    endif
                                endif
                                let firstcol = col( "'<" ) - 1
                                let lastcol  = col( "'>" ) - 2
                                if lastcol >= 0
                                    let lines[len(lines)-1] = lines[len(lines)-1][ : lastcol]
                                else
                                    let lines[len(lines)-1] = ''
                                endif
                                let lines[0] = lines[0][firstcol : ]
                            
                                " Find and set package/namespace definition preceding the region
                                call SlimvFindPackage()
                                call winrestview( oldpos ) 
                                return lines
                            endfunction
                            
                            " Eval buffer lines in the given range
    1              0.000002 function! SlimvEvalRegion() range
                                if v:register == '"' || v:register == '+'
                                    let lines = SlimvGetRegion(a:firstline, a:lastline)
                                else
                                    " Register was passed, so eval register contents instead
                                    let reg = getreg( v:register )
                                    let ending = ""
                                    if SlimvGetFiletype() != 'r'
                                        let ending = s:CloseForm( reg )
                                        if ending == 'ERROR'
                                            call SlimvError( 'Too many or invalid closing parens in register "' . v:register )
                                            return
                                        endif
                                    endif
                                    let lines = [reg . ending]
                                endif
                                if lines != []
                                    if SlimvGetFiletype() == 'scheme'
                                        " Swank-scheme requires us to pass a single s-expression
                                        " so embed buffer lines in a (begin ...) block
                                        let lines = ['(begin'] + lines + [')']
                                    endif
                                    call SlimvEval( lines )
                                endif
                            endfunction
                            
                            " Eval contents of the 's' register, optionally store it in another register
                            " Also optionally append a test form for quick testing (not stored in 'outreg')
                            " If the test form contains '%1' then it 'wraps' the selection around the '%1'
    1              0.000002 function! SlimvEvalSelection( outreg, testform )
                                let sel = SlimvGetSelection()
                                if a:outreg != '"' && a:outreg != '+'
                                    " Register was passed, so store current selection in register
                                    call setreg( a:outreg, s:swank_package_form . sel)
                                endif
                                let lines = [sel]
                                if a:testform != ''
                                    if match( a:testform, '%1' ) >= 0
                                        " We need to wrap the selection in the testform
                                        if match( sel, "\n" ) < 0
                                            " The selection is a single line, keep the wrapped form in one line
                                            let sel = substitute( a:testform, '%1', sel, 'g' )
                                            let lines = [sel]
                                        else
                                            " The selection is multiple lines, wrap it by adding new lines
                                            let lines = [strpart( a:testform, 0, match( a:testform, '%1' ) ),
                                            \            sel,
                                            \            strpart( a:testform, matchend( a:testform, '%1' ) )]
                                        endif
                                    else
                                        " Append optional test form at the tail
                                        let lines = lines + [a:testform]
                                    endif
                                endif
                                if exists( 'b:slimv_repl_buffer' )
                                    " If this is the REPL buffer then go to EOF
                                    call s:EndOfBuffer()
                                endif
                                call SlimvEval( lines )
                            endfunction
                            
                            " Eval Lisp form.
                            " Form given in the template is passed to Lisp without modification.
    1              0.000001 function! SlimvEvalForm( template )
                                let lines = [a:template]
                                call SlimvEval( lines )
                            endfunction
                            
                            " Eval Lisp form, with the given parameter substituted in the template.
                            " %1 string is substituted with par1
    1              0.000002 function! SlimvEvalForm1( template, par1 )
                                let p1 = escape( a:par1, '&' )
                                let temp1 = substitute( a:template, '%1', p1, 'g' )
                                let lines = [temp1]
                                call SlimvEval( lines )
                            endfunction
                            
                            " Eval Lisp form, with the given parameters substituted in the template.
                            " %1 string is substituted with par1
                            " %2 string is substituted with par2
    1              0.000002 function! SlimvEvalForm2( template, par1, par2 )
                                let p1 = escape( a:par1, '&' )
                                let p2 = escape( a:par2, '&' )
                                let temp1 = substitute( a:template, '%1', p1, 'g' )
                                let temp2 = substitute( temp1,      '%2', p2, 'g' )
                                let lines = [temp2]
                                call SlimvEval( lines )
                            endfunction
                            
                            
                            " =====================================================================
                            "  Special functions
                            " =====================================================================
                            
                            " Evaluate and test top level form at the cursor pos
    1              0.000001 function! SlimvEvalTestDefun( testform )
                                let outreg = v:register
                                let oldpos = winsaveview()
                                if !SlimvSelectDefun()
                                    return
                                endif
                                call SlimvFindPackage()
                                call winrestview( oldpos ) 
                                call SlimvEvalSelection( outreg, a:testform )
                            endfunction
                            
                            " Evaluate top level form at the cursor pos
    1              0.000001 function! SlimvEvalDefun()
                                call SlimvEvalTestDefun( '' )
                            endfunction
                            
                            " Evaluate the whole buffer
    1              0.000001 function! SlimvEvalBuffer()
                                if exists( 'b:slimv_repl_buffer' )
                                    call SlimvError( "Cannot evaluate the REPL buffer." )
                                    return
                                endif
                                let first_line = 1
                                if getline( first_line )[0] == '#'
                                    " skip shebang line
                                    let first_line += 1
                                endif
                                let lines = getline( first_line, '$' )
                                if SlimvGetFiletype() == 'scheme'
                                    " Swank-scheme requires us to pass a single s-expression
                                    " so embed buffer lines in a (begin ...) block
                                    let lines = ['(begin'] + lines + [')']
                                endif
                                call SlimvEval( lines )
                            endfunction
                            
                            " Return frame number if we are in the Backtrace section of the debugger
    1              0.000002 function! s:DebugFrame()
                                if s:swank_connected && s:sldb_level >= 0
                                    " Check if we are in SLDB
                                    let sldb_buf = bufnr( '^' . g:slimv_sldb_name . '$' )
                                    if sldb_buf != -1 && sldb_buf == bufnr( "%" )
                                        let bcktrpos = search( '^Backtrace:', 'bcnw' )
                                        let framepos = line( '.' )
                                        if matchstr( getline('.'), s:frame_def ) == ''
                                            let framepos = search( s:frame_def, 'bcnw' )
                                        endif
                                        if framepos > 0 && bcktrpos > 0 && framepos > bcktrpos
                                            let line = getline( framepos )
                                            let item = matchstr( line, s:frame_def )
                                            if item != ''
                                                return substitute( item, '\s\|:', '', 'g' )
                                            endif
                                        endif
                                    endif
                                endif
                                return ''
                            endfunction
                            
                            " Evaluate and test current s-expression at the cursor pos
    1              0.000001 function! SlimvEvalTestExp( testform )
                                let outreg = v:register
                                let oldpos = winsaveview()
                                if !SlimvSelectForm( 1 )
                                    return
                                endif
                                call SlimvFindPackage()
                                call winrestview( oldpos ) 
                                call SlimvEvalSelection( outreg, a:testform )
                            endfunction
                            
                            " Evaluate current s-expression at the cursor pos
    1              0.000001 function! SlimvEvalExp()
                                call SlimvEvalTestExp( '' )
                            endfunction
                            
                            " Evaluate expression entered interactively
    1              0.000001 function! SlimvInteractiveEval()
                                let frame = s:DebugFrame()
                                if frame != ''
                                    " We are in the debugger, eval expression in the frame the cursor stands on
                                    let e = input( 'Eval in frame ' . frame . ': ' )
                                    if e != ''
                                        let result = SlimvCommandGetResponse( ':eval-string-in-frame', s:py_cmd . 'swank_eval_in_frame("' . e . '", ' . frame . ')', 0 )
                                        if result != ''
                                            redraw
                                            echo result
                                        endif
                                    endif
                                else
                                    let e = input( 'Eval: ' )
                                    if e != ''
                                        call SlimvEval([e])
                                    endif
                                endif
                            endfunction
                            
                            " Undefine function
    1              0.000001 function! SlimvUndefineFunction()
                                if s:swank_connected
                                    call SlimvCommand( s:py_cmd . 'swank_undefine_function("' . SlimvSelectSymbol() . '")' )
                                    call SlimvRefreshReplBuffer()
                                endif
                            endfunction
                            
                            " ---------------------------------------------------------------------
                            
                            " Macroexpand-1 the current top level form
    1              0.000001 function! SlimvMacroexpand()
                                if SlimvConnectSwank()
                                    if !SlimvSelectForm( 0 )
                                        return
                                    endif
                                    let s:swank_form = SlimvGetSelection()
                                    if exists( 'b:slimv_repl_buffer' )
                                        " If this is the REPL buffer then go to EOF
                                        call s:EndOfBuffer()
                                    endif
                                    call SlimvCommandUsePackage( s:py_cmd . 'swank_macroexpand("s:swank_form")' )
                                endif
                            endfunction
                            
                            " Macroexpand the current top level form
    1              0.000001 function! SlimvMacroexpandAll()
                                if SlimvConnectSwank()
                                    if !SlimvSelectForm( 0 )
                                        return
                                    endif
                                    let s:swank_form = SlimvGetSelection()
                                    if exists( 'b:slimv_repl_buffer' )
                                        " If this is the REPL buffer then go to EOF
                                        call s:EndOfBuffer()
                                    endif
                                    call SlimvCommandUsePackage( s:py_cmd . 'swank_macroexpand_all("s:swank_form")' )
                                endif
                            endfunction
                            
                            " Toggle debugger break on exceptions
                            " Only for ritz-swank 0.4.0 and above
    1              0.000001 function! SlimvBreakOnException()
                                if SlimvGetFiletype() =~ '.*clojure.*' && s:SinceVersion( '2010-11-13' )
                                    " swank-clojure is abandoned at protocol version 20100404, so it must be ritz-swank
                                    if SlimvConnectSwank()
                                        let s:break_on_exception = ! s:break_on_exception
                                        call SlimvCommand( s:py_cmd . 'swank_break_on_exception(' . s:break_on_exception . ')' )
                                        call SlimvRefreshReplBuffer()
                                        echomsg 'Break On Exception ' . (s:break_on_exception ? 'enabled.' : 'disabled.')
                                    endif
                                else
                                    call SlimvError( "This function is implemented only for ritz-swank." )
                                endif
                            endfunction
                            
                            " Set a breakpoint on the beginning of a function
    1              0.000001 function! SlimvBreak()
                                if SlimvConnectSwank()
                                    let s = input( 'Set breakpoint: ', SlimvSelectSymbol() )
                                    if s != ''
                                        call SlimvCommandUsePackage( s:py_cmd . 'swank_set_break("' . s . '")' )
                                        redraw!
                                    endif
                                endif
                            endfunction
                            
                            " Switch trace on for the selected function (toggle for swank)
    1              0.000001 function! SlimvTrace()
                                if SlimvGetFiletype() == 'scheme'
                                    call SlimvError( "Tracing is not supported by swank-scheme." )
                                    return
                                endif
                                if SlimvConnectSwank()
                                    let s = input( '(Un)trace: ', SlimvSelectSymbol() )
                                    if s != ''
                                        call SlimvCommandUsePackage( s:py_cmd . 'swank_toggle_trace("' . s . '")' )
                                        redraw!
                                    endif
                                endif
                            endfunction
                            
                            " Switch trace off for the selected function (or all functions for swank)
    1              0.000001 function! SlimvUntrace()
                                if SlimvGetFiletype() == 'scheme'
                                    call SlimvError( "Tracing is not supported by swank-scheme." )
                                    return
                                endif
                                if SlimvConnectSwank()
                                    let s:refresh_disabled = 1
                                    call SlimvCommand( s:py_cmd . 'swank_untrace_all()' )
                                    let s:refresh_disabled = 0
                                    call SlimvRefreshReplBuffer()
                                endif
                            endfunction
                            
                            " Disassemble the selected function
    1              0.000001 function! SlimvDisassemble()
                                let symbol = SlimvSelectSymbol()
                                if SlimvConnectSwank()
                                    let s = input( 'Disassemble: ', symbol )
                                    if s != ''
                                        call SlimvCommandUsePackage( s:py_cmd . 'swank_disassemble("' . s . '")' )
                                    endif
                                endif
                            endfunction
                            
                            " Inspect symbol under cursor
    1              0.000001 function! SlimvInspect()
                                if !SlimvConnectSwank()
                                    return
                                endif
                                let s:inspect_path = []
                                let frame = s:DebugFrame()
                                if frame != ''
                                    " Inspect selected for a frame in the debugger's Backtrace section
                                    let line = getline( '.' )
                                    if matchstr( line, s:frame_def ) != ''
                                        " This is the base frame line in form '  1: xxxxx'
                                        let sym = ''
                                    elseif matchstr( line, '^\s\+in "\(.*\)" \(line\|byte\)' ) != ''
                                        " This is the source location line
                                        let sym = ''
                                    elseif matchstr( line, '^\s\+No source line information' ) != ''
                                        " This is the no source location line
                                        let sym = ''
                                    elseif matchstr( line, '^\s\+Locals:' ) != ''
                                        " This is the 'Locals' line
                                        let sym = ''
                                    else
                                        let sym = SlimvSelectSymbolExt()
                                    endif
                                    let s = input( 'Inspect in frame ' . frame . ' (evaluated): ', sym )
                                    if s != ''
                                        let s:inspect_path = [s]
                                        call SlimvCommand( s:py_cmd . 'swank_inspect_in_frame("' . s . '", ' . frame . ')' )
                                        call SlimvRefreshReplBuffer()
                                    endif
                                else
                                    let s = input( 'Inspect: ', SlimvSelectSymbolExt() )
                                    if s != ''
                                        let s:inspect_path = [s]
                                        call SlimvCommandUsePackage( s:py_cmd . 'swank_inspect("' . s . '")' )
                                    endif
                                endif
                            endfunction
                            
                            " Cross reference: who calls
    1              0.000002 function! SlimvXrefBase( text, cmd )
                                if SlimvConnectSwank()
                                    let s = input( a:text, SlimvSelectSymbol() )
                                    if s != ''
                                        call SlimvCommandUsePackage( s:py_cmd . 'swank_xref("' . s . '", "' . a:cmd . '")' )
                                    endif
                                endif
                            endfunction
                            
                            " Cross reference: who calls
    1              0.000001 function! SlimvXrefCalls()
                                call SlimvXrefBase( 'Who calls: ', ':calls' )
                            endfunction
                            
                            " Cross reference: who references
    1              0.000001 function! SlimvXrefReferences()
                                call SlimvXrefBase( 'Who references: ', ':references' )
                            endfunction
                            
                            " Cross reference: who sets
    1              0.000001 function! SlimvXrefSets()
                                call SlimvXrefBase( 'Who sets: ', ':sets' )
                            endfunction
                            
                            " Cross reference: who binds
    1              0.000001 function! SlimvXrefBinds()
                                call SlimvXrefBase( 'Who binds: ', ':binds' )
                            endfunction
                            
                            " Cross reference: who macroexpands
    1              0.000001 function! SlimvXrefMacroexpands()
                                call SlimvXrefBase( 'Who macroexpands: ', ':macroexpands' )
                            endfunction
                            
                            " Cross reference: who specializes
    1              0.000001 function! SlimvXrefSpecializes()
                                call SlimvXrefBase( 'Who specializes: ', ':specializes' )
                            endfunction
                            
                            " Cross reference: list callers
    1              0.000001 function! SlimvXrefCallers()
                                call SlimvXrefBase( 'List callers: ', ':callers' )
                            endfunction
                            
                            " Cross reference: list callees
    1              0.000001 function! SlimvXrefCallees()
                                call SlimvXrefBase( 'List callees: ', ':callees' )
                            endfunction
                            
                            " ---------------------------------------------------------------------
                            
                            " Switch or toggle profiling on for the selected function
    1              0.000001 function! SlimvProfile()
                                if SlimvConnectSwank()
                                    let s = input( '(Un)profile: ', SlimvSelectSymbol() )
                                    if s != ''
                                        call SlimvCommandUsePackage( s:py_cmd . 'swank_toggle_profile("' . s . '")' )
                                        redraw!
                                    endif
                                endif
                            endfunction
                            
                            " Switch profiling on based on substring
    1              0.000001 function! SlimvProfileSubstring()
                                if SlimvConnectSwank()
                                    let s = input( 'Profile by matching substring: ', SlimvSelectSymbol() )
                                    if s != ''
                                        let p = input( 'Package (RET for all packages): ' )
                                        call SlimvCommandUsePackage( s:py_cmd . 'swank_profile_substring("' . s . '","' . p . '")' )
                                        redraw!
                                    endif
                                endif
                            endfunction
                            
                            " Switch profiling completely off
    1              0.000001 function! SlimvUnprofileAll()
                                if SlimvConnectSwank()
                                    call SlimvCommandUsePackage( s:py_cmd . 'swank_unprofile_all()' )
                                endif
                            endfunction
                            
                            " Display list of profiled functions
    1              0.000001 function! SlimvShowProfiled()
                                if SlimvConnectSwank()
                                    call SlimvCommandUsePackage( s:py_cmd . 'swank_profiled_functions()' )
                                endif
                            endfunction
                            
                            " Report profiling results
    1              0.000001 function! SlimvProfileReport()
                                if SlimvConnectSwank()
                                    call SlimvCommandUsePackage( s:py_cmd . 'swank_profile_report()' )
                                endif
                            endfunction
                            
                            " Reset profiling counters
    1              0.000001 function! SlimvProfileReset()
                                if SlimvConnectSwank()
                                    call SlimvCommandUsePackage( s:py_cmd . 'swank_profile_reset()' )
                                endif
                            endfunction
                            
                            " ---------------------------------------------------------------------
                            
                            " Compile the current top-level form
    1              0.000002 function! SlimvCompileDefun()
                                let oldpos = winsaveview()
                                if !SlimvSelectDefun()
                                    call winrestview( oldpos ) 
                                    return
                                endif
                                if SlimvConnectSwank()
                                    let s:swank_form = SlimvGetSelection()
                                    call SlimvCommandUsePackage( s:py_cmd . 'swank_compile_string("s:swank_form")' )
                                endif
                                call winrestview( oldpos )
                            endfunction
                            
                            " Compile and load whole file
    1              0.000001 function! SlimvCompileLoadFile()
                                if exists( 'b:slimv_repl_buffer' )
                                    call SlimvError( "Cannot compile the REPL buffer." )
                                    return
                                endif
                                let filename = fnamemodify( bufname(''), ':p' )
                                let filename = substitute( filename, '\\', '/', 'g' )
                                if &modified
                                    let answer = SlimvErrorAsk( '', "Save file before compiling [Y/n]?" )
                                    if answer[0] != 'n' && answer[0] != 'N'
                                        write
                                    endif
                                endif
                                if SlimvConnectSwank()
                                    let s:compiled_file = ''
                                    call SlimvCommandUsePackage( s:py_cmd . 'swank_compile_file("' . filename . '")' )
                                    let starttime = localtime()
                                    while s:compiled_file == '' && localtime()-starttime < g:slimv_timeout
                                        call SlimvSwankResponse()
                                    endwhile
                                    if s:compiled_file != ''
                                        let s:compiled_file = substitute( s:compiled_file, '\\', '/', 'g' )
                                        call SlimvCommandUsePackage( s:py_cmd . 'swank_load_file("' . s:compiled_file . '")' )
                                        let s:compiled_file = ''
                                    endif
                                endif
                            endfunction
                            
                            " Compile whole file
    1              0.000001 function! SlimvCompileFile()
                                if exists( 'b:slimv_repl_buffer' )
                                    call SlimvError( "Cannot compile the REPL buffer." )
                                    return
                                endif
                                let filename = fnamemodify( bufname(''), ':p' )
                                let filename = substitute( filename, '\\', '/', 'g' )
                                if &modified
                                    let answer = SlimvErrorAsk( '', "Save file before compiling [Y/n]?" )
                                    if answer[0] != 'n' && answer[0] != 'N'
                                        write
                                    endif
                                endif
                                if SlimvConnectSwank()
                                    call SlimvCommandUsePackage( s:py_cmd . 'swank_compile_file("' . filename . '")' )
                                endif
                            endfunction
                            
                            " Compile buffer lines in the given range
    1              0.000001 function! SlimvCompileRegion() range
                                if v:register == '"' || v:register == '+'
                                    let lines = SlimvGetRegion(a:firstline, a:lastline)
                                else
                                    " Register was passed, so compile register contents instead
                                    let reg = getreg( v:register )
                                    let ending = s:CloseForm( reg )
                                    if ending == 'ERROR'
                                        call SlimvError( 'Too many or invalid closing parens in register "' . v:register )
                                        return
                                    endif
                                    let lines = [reg . ending]
                                endif
                                if lines == []
                                    return
                                endif
                                let region = join( lines, "\n" )
                                if SlimvConnectSwank()
                                    let s:swank_form = region
                                    call SlimvCommandUsePackage( s:py_cmd . 'swank_compile_string("s:swank_form")' )
                                endif
                            endfunction
                            
                            " ---------------------------------------------------------------------
                            
                            " Describe the selected symbol
    1              0.000001 function! SlimvDescribeSymbol()
                                if SlimvConnectSwank()
                                    let symbol = SlimvSelectSymbol()
                                    if symbol == ''
                                        call SlimvError( "No symbol under cursor." )
                                        return
                                    endif
                                    call SlimvCommandUsePackage( s:py_cmd . 'swank_describe_symbol("' . symbol . '")' )
                                endif
                            endfunction
                            
                            " Display symbol description in balloonexpr
    1              0.000001 function! SlimvDescribe(arg)
                                let arg=a:arg
                                if a:arg == ''
                                    let arg = expand('<cword>')
                                endif
                                " We don't want to try connecting here ... the error message would just 
                                " confuse the balloon logic
                                if !s:swank_connected || s:read_string_mode
                                    return ''
                                endif
                                call SlimvFindPackage()
                                let arglist = SlimvCommandGetResponse( ':operator-arglist', s:py_cmd . 'swank_op_arglist("' . arg . '")', 0 )
                                if arglist == ''
                                    " Not able to fetch arglist, assuming function is not defined
                                    " Skip calling describe, otherwise SWANK goes into the debugger
                                    return ''
                                endif
                                let msg = SlimvCommandGetResponse( ':describe-function', s:py_cmd . 'swank_describe_function("' . arg . '")', 0 )
                                if msg == ''
                                    " No describe info, display arglist
                                    if match( arglist, arg ) != 1
                                        " Function name is not received from REPL
                                        return "(" . arg . ' ' . arglist[1:]
                                    else
                                        return arglist
                                    endif
                                else
                                    return substitute(msg,'^\n*','','')
                                endif
                            endfunction
                            
                            " Apropos of the selected symbol
    1              0.000001 function! SlimvApropos()
                                call SlimvEvalForm1( g:slimv_template_apropos, SlimvSelectSymbol() )
                            endfunction
                            
                            " Generate tags file using ctags
    1              0.000001 function! SlimvGenerateTags()
                                if exists( 'g:slimv_ctags' ) && g:slimv_ctags != ''
                                    execute 'silent !' . g:slimv_ctags
                                else
                                    call SlimvError( "Copy ctags to the Vim path or define g:slimv_ctags." )
                                endif
                            endfunction
                            
                            " ---------------------------------------------------------------------
                            
                            " Find word in the CLHS symbol database, with exact or partial match.
                            " Return either the first symbol found with the associated URL,
                            " or the list of all symbols found without the associated URL.
    1              0.000003 function! SlimvFindSymbol( word, exact, all, db, root, init )
                                if a:word == ''
                                    return []
                                endif
                                if !a:all && a:init != []
                                    " Found something already at a previous db lookup, no need to search this db
                                    return a:init
                                endif
                                let lst = a:init
                                let i = 0
                                let w = tolower( a:word )
                                if a:exact
                                    while i < len( a:db )
                                        " Try to find an exact match
                                        if a:db[i][0] == w
                                            " No reason to check a:all here
                                            return [a:db[i][0], a:root . a:db[i][1]]
                                        endif
                                        let i = i + 1
                                    endwhile
                                else
                                    while i < len( a:db )
                                        " Try to find the symbol starting with the given word
                                        let w2 = escape( w, '~' )
                                        if match( a:db[i][0], w2 ) == 0
                                            if a:all
                                                call add( lst, a:db[i][0] )
                                            else
                                                return [a:db[i][0], a:root . a:db[i][1]]
                                            endif
                                        endif
                                        let i = i + 1
                                    endwhile
                                endif
                            
                                " Return whatever found so far
                                return lst
                            endfunction
                            
                            " Lookup word in Common Lisp Hyperspec
    1              0.000002 function! SlimvLookup( word )
                                " First try an exact match
                                let w = a:word
                                let symbol = []
                                while symbol == []
                                    let symbol = SlimvHyperspecLookup( w, 1, 0 )
                                    if symbol == []
                                        " Symbol not found, try a match on beginning of symbol name
                                        let symbol = SlimvHyperspecLookup( w, 0, 0 )
                                        if symbol == []
                                            " We are out of luck, can't find anything
                                            let msg = 'Symbol ' . w . ' not found. Hyperspec lookup word: '
                                            let val = ''
                                        else
                                            let msg = 'Hyperspec lookup word: '
                                            let val = symbol[0]
                                        endif
                                        " Ask user if this is that he/she meant
                                        let w = input( msg, val )
                                        if w == ''
                                            " OK, user does not want to continue
                                            return
                                        endif
                                        let symbol = []
                                    endif
                                endwhile
                                if symbol != [] && len(symbol) > 1
                                    " Symbol found, open HS page in browser
                                    if match( symbol[1], ':' ) < 0 && exists( 'g:slimv_hs_root' )
                                        let page = g:slimv_hs_root . symbol[1]
                                    else
                                        " URL is already a fully qualified address
                                        let page = symbol[1]
                                    endif
                                    if exists( "g:slimv_browser_cmd" )
                                        " We have an given command to start the browser
                                        if !exists( "g:slimv_browser_cmd_suffix" )
                                            " Fork the browser by default
                                            let g:slimv_browser_cmd_suffix = '&'
                                        endif
                                        silent execute '! ' . g:slimv_browser_cmd . ' ' . page . ' ' . g:slimv_browser_cmd_suffix
                                    else
                                        if g:slimv_windows
                                            " Run the program associated with the .html extension
                                            silent execute '! start ' . page
                                        else
                                            " On Linux it's not easy to determine the default browser
                                            if executable( 'xdg-open' )
                                                silent execute '! xdg-open ' . page . ' &'
                                            else
                                                " xdg-open not installed, ask help from Python webbrowser package
                                                let pycmd = "import webbrowser; webbrowser.open('" . page . "')"
                                                silent execute '! python -c "' . pycmd . '"'
                                            endif
                                        endif
                                    endif
                                    " This is needed especially when using text browsers
                                    redraw!
                                endif
                            endfunction
                            
                            " Lookup current symbol in the Common Lisp Hyperspec
    1              0.000001 function! SlimvHyperspec()
                                call SlimvLookup( SlimvSelectSymbol() )
                            endfunction
                            
                            " Complete symbol name starting with 'base'
    1              0.000001 function! SlimvComplete( base )
                                " Find all symbols starting with "a:base"
                                if a:base == ''
                                    return []
                                endif
                                if s:swank_connected && !s:read_string_mode
                                    " Save current buffer and window in case a swank command causes a buffer change
                                    let buf = bufnr( "%" )
                                    if winnr('$') < 2
                                        let win = 0
                                    else
                                        let win = winnr()
                                    endif
                            
                                    call SlimvFindPackage()
                                    if g:slimv_simple_compl
                                        let msg = SlimvCommandGetResponse( ':simple-completions', s:py_cmd . 'swank_completions("' . a:base . '")', 0 )
                                    else
                                        let msg = SlimvCommandGetResponse( ':fuzzy-completions', s:py_cmd . 'swank_fuzzy_completions("' . a:base . '")', 0 )
                                    endif
                            
                                    " Restore window and buffer, because it is not allowed to change buffer here
                                    if win > 0 && winnr() != win
                                        execute win . "wincmd w"
                                        let msg = ''
                                    endif
                                    if bufnr( "%" ) != buf
                                        execute "buf " . buf
                                        let msg = ''
                                    endif
                            
                                    if msg != ''
                                        " We have a completion list from SWANK
                                        let res = split( msg, '\n' )
                                        return res
                                    endif
                                endif
                            
                                " No completion yet, try to fetch it from the Hyperspec database
                                let res = []
                                let symbol = SlimvHyperspecLookup( a:base, 0, 1 )
                                if symbol == []
                                    return []
                                endif
                                call sort( symbol )
                                for m in symbol
                                    if m =~ '^' . a:base
                                        call add( res, m )
                                    endif
                                endfor
                                return res
                            endfunction
                            
                            " Complete function that uses the Hyperspec database
    1              0.000002 function! SlimvOmniComplete( findstart, base )
                                if a:findstart
                                    " Locate the start of the symbol name
                                    call s:SetKeyword()
                                    let upto = strpart( getline( '.' ), 0, col( '.' ) - 1)
                                    return match(upto, '\k\+$')
                                else
                                    return SlimvComplete( a:base )
                                endif
                            endfunction
                            
                            " Define complete function only if none is defined yet
    1              0.000005 if &omnifunc == ''
                                set omnifunc=SlimvOmniComplete
                            endif
                            
                            " Complete function for user-defined commands
    1              0.000002 function! SlimvCommandComplete( arglead, cmdline, cursorpos )
                                " Locate the start of the symbol name
                                call s:SetKeyword()
                                let upto = strpart( a:cmdline, 0, a:cursorpos )
                                let base = matchstr(upto, '\k\+$')
                                let ext  = matchstr(upto, '\S*\k\+$')
                                let compl = SlimvComplete( base )
                                if len(compl) > 0 && base != ext
                                    " Command completion replaces whole word between spaces, so we
                                    " need to add any prefix present in front of the keyword, like '('
                                    let prefix = strpart( ext, 0, len(ext) - len(base) )
                                    let i = 0
                                    while i < len(compl)
                                        let compl[i] = prefix . compl[i]
                                        let i = i + 1
                                    endwhile
                                endif
                                return compl
                            endfunction
                            
                            " Create a tags file containing the definitions
                            " of the given symbol, then perform a tag lookup
    1              0.000002 function! SlimvFindDefinitionsForEmacs( symbol )
                                if g:slimv_tags_file == ''
                                    let msg = ''
                                else
                                    let msg = SlimvCommandGetResponse( ':find-definitions-for-emacs', s:py_cmd . 'swank_find_definitions_for_emacs("' . a:symbol . '")', 0 )
                                endif
                                try
                                    if msg != ''
                                        exec ":tjump " . msg
                                    else
                                        exec ":tjump " . a:symbol
                                    endif
                                catch
                                    call SlimvError( "\r" . v:exception )
                                endtry
                            endfunction
                            
                            " Lookup definition(s) of the symbol under cursor
    1              0.000001 function! SlimvFindDefinitions()
                                if SlimvConnectSwank()
                                    let symbol = SlimvSelectSymbol()
                                    if symbol == ''
                                        call SlimvError( "No symbol under cursor." )
                                        return
                                    endif
                                    call SlimvFindPackage()
                                    call SlimvFindDefinitionsForEmacs( symbol )
                                endif
                            endfunction
                            
                            " Lookup definition(s) of symbol entered in prompt
    1              0.000001 function! SlimvFindDefinitionsPrompt()
                                if SlimvConnectSwank()
                                    let symbol = input( 'Find Definitions For: ', SlimvSelectSymbol() )
                                    echon "\r"
                                    call SlimvFindDefinitionsForEmacs( symbol )
                                endif
                            endfunction
                            
                            " Set current package
    1              0.000001 function! SlimvSetPackage()
                                if SlimvConnectSwank()
                                    call SlimvFindPackage()
                                    let pkg = input( 'Package: ', s:swank_package )
                                    if pkg != ''
                                        let s:refresh_disabled = 1
                                        call SlimvCommand( s:py_cmd . 'swank_set_package("' . pkg . '")' )
                                        let s:refresh_disabled = 0
                                        call SlimvRefreshReplBuffer()
                                    endif
                                endif
                            endfunction
                            
                            " Close lisp process running the swank server
                            " and quit REPL buffer
    1              0.000001 function! SlimvQuitRepl()
                                if s:swank_connected
                                    call SlimvCommand( s:py_cmd . 'swank_quit_lisp()' )
                                    let s:swank_connected = 0
                                    let buf = bufnr( '^' . g:slimv_repl_name . '$' )
                                    if buf != -1
                                        if g:slimv_repl_split
                                            " REPL buffer exists, check if it is open in a window
                                            let win = bufwinnr( buf )
                                            if win != -1
                                                " Switch to the REPL window and close it
                                                if winnr() != win
                                                    execute win . "wincmd w"
                                                endif
                                                execute "wincmd c"
                                            endif
                                        endif
                                        execute "bd " . buf
                                    endif
                                endif
                            endfunction
                            
                            " =====================================================================
                            "  Slimv keybindings
                            " =====================================================================
                            
                            " <Leader> timeouts in 1000 msec by default, if this is too short,
                            " then increase 'timeoutlen'
                            
                            " Map keyboard keyset dependant shortcut to command and also add it to menu
    1              0.000003 function! s:MenuMap( name, shortcut1, shortcut2, command )
                                if g:slimv_keybindings == 1
                                    " Short (one-key) keybinding set
                                    let shortcut = a:shortcut1
                                elseif g:slimv_keybindings == 2
                                    " Easy to remember (two-key) keybinding set
                                    let shortcut = a:shortcut2
                                else
                                    " No bindings
                                    let shortcut = ''
                                endif
                            
                                if shortcut != ''
                                    execute "noremap <silent> " . shortcut . " " . a:command
                                    if a:name != '' && g:slimv_menu == 1
                                        silent execute "amenu " . a:name . "<Tab>" . shortcut . " " . a:command
                                    endif
                                elseif a:name != '' && g:slimv_menu == 1
                                    silent execute "amenu " . a:name . " " . a:command
                                endif
                            endfunction
                            
                            " Initialize buffer by adding buffer specific mappings
    1              0.000001 function! SlimvInitBuffer()
                                " Map space to display function argument list in status line
                                if SlimvGetFiletype() == 'r'
                                    inoremap <silent> <buffer> (          (<C-R>=SlimvArglist()<CR>
                                else
                                    if !exists("g:slimv_unmap_space") || g:slimv_unmap_space == 0
                                        inoremap <silent> <buffer> <Space>    <Space><C-R>=SlimvArglist()<CR>
                                    endif
                                    if !exists("g:slimv_unmap_cr") || g:slimv_unmap_cr == 0
                                        inoremap <silent> <buffer> <CR>       <C-R>=pumvisible() ?  "\<lt>C-Y>" : SlimvHandleEnter()<CR><C-R>=SlimvArglistOnEnter()<CR>
                                    endif
                                endif
                                "noremap  <silent> <buffer> <C-C>      :call SlimvInterrupt()<CR>
                                augroup SlimvInsertLeave
                                    au!
                                    au InsertEnter * :let s:save_showmode=&showmode
                                    au InsertLeave * :let &showmode=s:save_showmode
                                augroup END
                                inoremap <silent> <buffer> <C-X>0     <C-O>:call SlimvCloseForm()<CR>
                                if !exists("g:slimv_unmap_tab") || g:slimv_unmap_tab == 0
                                    inoremap <silent> <buffer> <Tab>      <C-R>=SlimvHandleTab()<CR>
                                endif
                                inoremap <silent> <buffer> <S-Tab>    <C-R>=pumvisible() ? "\<lt>C-P>" : "\<lt>S-Tab>"<CR>
                                if g:slimv_tags_file != ''
                                    nnoremap <silent> <buffer> <C-]>      :call SlimvFindDefinitions()<CR>
                                endif
                            
                                " Setup balloonexp to display symbol description
                                if g:slimv_balloon && has( 'balloon_eval' )
                                    "setlocal balloondelay=100
                                    setlocal ballooneval
                                    setlocal balloonexpr=SlimvDescribe(v:beval_text)
                                endif
                                " This is needed for safe switching of modified buffers
                                set hidden
                                call s:MakeWindowId()
                            endfunction
                            
                            " Edit commands
    1   0.000106   0.000026 call s:MenuMap( 'Slim&v.Edi&t.Close-&Form',                     g:slimv_leader.')',  g:slimv_leader.'tc',  ':<C-U>call SlimvCloseForm()<CR>' )
    1   0.000050   0.000007 call s:MenuMap( 'Slim&v.Edi&t.&Complete-Symbol<Tab>Tab',        '',                  '',                   '<Ins><C-X><C-O>' )
    1   0.000050   0.000007 call s:MenuMap( 'Slim&v.Edi&t.Find-&Definitions\.\.\.',         g:slimv_leader.'j',  g:slimv_leader.'fd', ':call SlimvFindDefinitionsPrompt()<CR>' )
                            
    1              0.000003 if exists( 'g:paredit_loaded' )
    1   0.000050   0.000006 call s:MenuMap( 'Slim&v.Edi&t.&Paredit-Toggle',                 g:slimv_leader.'(',  g:slimv_leader.'(t',  ':<C-U>call PareditToggle()<CR>' )
    1   0.000032   0.000005 call s:MenuMap( 'Slim&v.Edi&t.-PareditSep-',                    '',                  '',                   ':' )
                            
    1              0.000001 if g:paredit_shortmaps
                            call s:MenuMap( 'Slim&v.Edi&t.Paredit-&Wrap<Tab>'                             .'W',  '',  '',              ':<C-U>call PareditWrap("(",")")<CR>' )
                            call s:MenuMap( 'Slim&v.Edi&t.Paredit-Spli&ce<Tab>'                           .'S',  '',  '',              ':<C-U>call PareditSplice()<CR>' )
                            call s:MenuMap( 'Slim&v.Edi&t.Paredit-&Split<Tab>'                            .'O',  '',  '',              ':<C-U>call PareditSplit()<CR>' )
                            call s:MenuMap( 'Slim&v.Edi&t.Paredit-&Join<Tab>'                             .'J',  '',  '',              ':<C-U>call PareditJoin()<CR>' )
                            call s:MenuMap( 'Slim&v.Edi&t.Paredit-Ra&ise<Tab>'             .g:slimv_leader.'I',  '',  '',              ':<C-U>call PareditRaise()<CR>' )
                            call s:MenuMap( 'Slim&v.Edi&t.Paredit-Move&Left<Tab>'                         .'<',  '',  '',              ':<C-U>call PareditMoveLeft()<CR>' )
                            call s:MenuMap( 'Slim&v.Edi&t.Paredit-Move&Right<Tab>'                        .'>',  '',  '',              ':<C-U>call PareditMoveRight()<CR>' )
                            else
    1   0.000035   0.000006 call s:MenuMap( 'Slim&v.Edi&t.Paredit-&Wrap<Tab>'              .g:slimv_leader.'W',  '',  '',              ':<C-U>call PareditWrap("(",")")<CR>' )
    1   0.000036   0.000006 call s:MenuMap( 'Slim&v.Edi&t.Paredit-Spli&ce<Tab>'            .g:slimv_leader.'S',  '',  '',              ':<C-U>call PareditSplice()<CR>' )
    1   0.000036   0.000005 call s:MenuMap( 'Slim&v.Edi&t.Paredit-&Split<Tab>'             .g:slimv_leader.'O',  '',  '',              ':<C-U>call PareditSplit()<CR>' )
    1   0.000036   0.000005 call s:MenuMap( 'Slim&v.Edi&t.Paredit-&Join<Tab>'              .g:slimv_leader.'J',  '',  '',              ':<C-U>call PareditJoin()<CR>' )
    1   0.000034   0.000005 call s:MenuMap( 'Slim&v.Edi&t.Paredit-Ra&ise<Tab>'             .g:slimv_leader.'I',  '',  '',              ':<C-U>call PareditRaise()<CR>' )
    1   0.000035   0.000007 call s:MenuMap( 'Slim&v.Edi&t.Paredit-Move&Left<Tab>'          .g:slimv_leader.'<',  '',  '',              ':<C-U>call PareditMoveLeft()<CR>' )
    1   0.000033   0.000005 call s:MenuMap( 'Slim&v.Edi&t.Paredit-Move&Right<Tab>'         .g:slimv_leader.'>',  '',  '',              ':<C-U>call PareditMoveRight()<CR>' )
    1              0.000001 endif "g:paredit_shortmaps
    1              0.000001 endif "g:paredit_loaded
                            
                            " Evaluation commands
    1   0.000048   0.000006 call s:MenuMap( 'Slim&v.&Evaluation.Eval-&Defun',               g:slimv_leader.'d',  g:slimv_leader.'ed',  ':<C-U>call SlimvEvalDefun()<CR>' )
    1   0.000057   0.000006 call s:MenuMap( 'Slim&v.&Evaluation.Eval-Current-&Exp',         g:slimv_leader.'e',  g:slimv_leader.'ee',  ':<C-U>call SlimvEvalExp()<CR>' )
    1   0.000084   0.000008 call s:MenuMap( 'Slim&v.&Evaluation.Eval-&Region',              g:slimv_leader.'r',  g:slimv_leader.'er',  ':call SlimvEvalRegion()<CR>' )
    1   0.000083   0.000023 call s:MenuMap( 'Slim&v.&Evaluation.Eval-&Buffer',              g:slimv_leader.'b',  g:slimv_leader.'eb',  ':<C-U>call SlimvEvalBuffer()<CR>' )
    1   0.000058   0.000009 call s:MenuMap( 'Slim&v.&Evaluation.Interacti&ve-Eval\.\.\.',   g:slimv_leader.'v',  g:slimv_leader.'ei',  ':call SlimvInteractiveEval()<CR>' )
    1   0.000054   0.000008 call s:MenuMap( 'Slim&v.&Evaluation.&Undefine-Function',        g:slimv_leader.'u',  g:slimv_leader.'eu',  ':call SlimvUndefineFunction()<CR>' )
                            
                            " Debug commands
    1   0.000047   0.000007 call s:MenuMap( 'Slim&v.De&bugging.Macroexpand-&1',             g:slimv_leader.'1',  g:slimv_leader.'m1',  ':<C-U>call SlimvMacroexpand()<CR>' )
    1   0.000047   0.000006 call s:MenuMap( 'Slim&v.De&bugging.&Macroexpand-All',           g:slimv_leader.'m',  g:slimv_leader.'ma',  ':<C-U>call SlimvMacroexpandAll()<CR>' )
    1   0.000054   0.000006 call s:MenuMap( 'Slim&v.De&bugging.Toggle-&Trace\.\.\.',        g:slimv_leader.'t',  g:slimv_leader.'dt',  ':call SlimvTrace()<CR>' )
    1   0.000044   0.000006 call s:MenuMap( 'Slim&v.De&bugging.U&ntrace-All',               g:slimv_leader.'T',  g:slimv_leader.'du',  ':call SlimvUntrace()<CR>' )
    1   0.000046   0.000006 call s:MenuMap( 'Slim&v.De&bugging.Set-&Breakpoint',            g:slimv_leader.'B',  g:slimv_leader.'db',  ':call SlimvBreak()<CR>' )
    1   0.000047   0.000008 call s:MenuMap( 'Slim&v.De&bugging.Break-on-&Exception',        g:slimv_leader.'E',  g:slimv_leader.'de',  ':call SlimvBreakOnException()<CR>' )
    1   0.000046   0.000006 call s:MenuMap( 'Slim&v.De&bugging.Disassemb&le\.\.\.',         g:slimv_leader.'l',  g:slimv_leader.'dd',  ':call SlimvDisassemble()<CR>' )
    1   0.000045   0.000006 call s:MenuMap( 'Slim&v.De&bugging.&Inspect\.\.\.',             g:slimv_leader.'i',  g:slimv_leader.'di',  ':call SlimvInspect()<CR>' )
    1   0.000033   0.000004 call s:MenuMap( 'Slim&v.De&bugging.-SldbSep-',                  '',                  '',                   ':' )
    1   0.000049   0.000006 call s:MenuMap( 'Slim&v.De&bugging.&Abort',                     g:slimv_leader.'a',  g:slimv_leader.'da',  ':call SlimvDebugAbort()<CR>' )
    1   0.000046   0.000006 call s:MenuMap( 'Slim&v.De&bugging.&Quit-to-Toplevel',          g:slimv_leader.'q',  g:slimv_leader.'dq',  ':call SlimvDebugQuit()<CR>' )
    1   0.000045   0.000006 call s:MenuMap( 'Slim&v.De&bugging.&Continue',                  g:slimv_leader.'n',  g:slimv_leader.'dc',  ':call SlimvDebugContinue()<CR>' )
    1   0.000045   0.000006 call s:MenuMap( 'Slim&v.De&bugging.&Restart-Frame',             g:slimv_leader.'N',  g:slimv_leader.'dr',  ':call SlimvDebugRestartFrame()<CR>' )
    1   0.000032   0.000004 call s:MenuMap( 'Slim&v.De&bugging.-ThreadSep-',                '',                  '',                   ':' )
    1   0.000045   0.000006 call s:MenuMap( 'Slim&v.De&bugging.List-T&hreads',              g:slimv_leader.'H',  g:slimv_leader.'dl',  ':call SlimvListThreads()<CR>' )
    1   0.000044   0.000006 call s:MenuMap( 'Slim&v.De&bugging.&Kill-Thread\.\.\.',         g:slimv_leader.'K',  g:slimv_leader.'dk',  ':call SlimvKillThread()<CR>' )
    1   0.000048   0.000006 call s:MenuMap( 'Slim&v.De&bugging.&Debug-Thread\.\.\.',        g:slimv_leader.'G',  g:slimv_leader.'dT',  ':call SlimvDebugThread()<CR>' )
                            
                            " Compile commands
    1   0.000046   0.000006 call s:MenuMap( 'Slim&v.&Compilation.Compile-&Defun',           g:slimv_leader.'D',  g:slimv_leader.'cd',  ':<C-U>call SlimvCompileDefun()<CR>' )
    1   0.000046   0.000006 call s:MenuMap( 'Slim&v.&Compilation.Compile-&Load-File',       g:slimv_leader.'L',  g:slimv_leader.'cl',  ':<C-U>call SlimvCompileLoadFile()<CR>' )
    1   0.000044   0.000006 call s:MenuMap( 'Slim&v.&Compilation.Compile-&File',            g:slimv_leader.'F',  g:slimv_leader.'cf',  ':<C-U>call SlimvCompileFile()<CR>' )
    1   0.000046   0.000007 call s:MenuMap( 'Slim&v.&Compilation.Compile-&Region',          g:slimv_leader.'R',  g:slimv_leader.'cr',  ':call SlimvCompileRegion()<CR>' )
                            
                            " Xref commands
    1   0.000045   0.000006 call s:MenuMap( 'Slim&v.&Xref.Who-&Calls',                      g:slimv_leader.'xc', g:slimv_leader.'xc',  ':call SlimvXrefCalls()<CR>' )
    1   0.000044   0.000006 call s:MenuMap( 'Slim&v.&Xref.Who-&References',                 g:slimv_leader.'xr', g:slimv_leader.'xr',  ':call SlimvXrefReferences()<CR>' )
    1   0.000046   0.000005 call s:MenuMap( 'Slim&v.&Xref.Who-&Sets',                       g:slimv_leader.'xs', g:slimv_leader.'xs',  ':call SlimvXrefSets()<CR>' )
    1   0.000044   0.000005 call s:MenuMap( 'Slim&v.&Xref.Who-&Binds',                      g:slimv_leader.'xb', g:slimv_leader.'xb',  ':call SlimvXrefBinds()<CR>' )
    1   0.000045   0.000006 call s:MenuMap( 'Slim&v.&Xref.Who-&Macroexpands',               g:slimv_leader.'xm', g:slimv_leader.'xm',  ':call SlimvXrefMacroexpands()<CR>' )
    1   0.000048   0.000009 call s:MenuMap( 'Slim&v.&Xref.Who-S&pecializes',                g:slimv_leader.'xp', g:slimv_leader.'xp',  ':call SlimvXrefSpecializes()<CR>' )
    1   0.000044   0.000006 call s:MenuMap( 'Slim&v.&Xref.&List-Callers',                   g:slimv_leader.'xl', g:slimv_leader.'xl',  ':call SlimvXrefCallers()<CR>' )
    1   0.000044   0.000006 call s:MenuMap( 'Slim&v.&Xref.List-Call&ees',                   g:slimv_leader.'xe', g:slimv_leader.'xe',  ':call SlimvXrefCallees()<CR>' )
                            
                            " Profile commands
    1   0.000048   0.000006 call s:MenuMap( 'Slim&v.&Profiling.Toggle-&Profile\.\.\.',      g:slimv_leader.'p',  g:slimv_leader.'pp',  ':<C-U>call SlimvProfile()<CR>' )
    1   0.000047   0.000006 call s:MenuMap( 'Slim&v.&Profiling.Profile-&By-Substring\.\.\.',g:slimv_leader.'P',  g:slimv_leader.'pb',  ':<C-U>call SlimvProfileSubstring()<CR>' )
    1   0.000045   0.000006 call s:MenuMap( 'Slim&v.&Profiling.Unprofile-&All',             g:slimv_leader.'U',  g:slimv_leader.'pa',  ':<C-U>call SlimvUnprofileAll()<CR>' )
    1   0.000045   0.000006 call s:MenuMap( 'Slim&v.&Profiling.&Show-Profiled',             g:slimv_leader.'?',  g:slimv_leader.'ps',  ':<C-U>call SlimvShowProfiled()<CR>' )
    1   0.000031   0.000004 call s:MenuMap( 'Slim&v.&Profiling.-ProfilingSep-',             '',                  '',                   ':' )
    1   0.000047   0.000007 call s:MenuMap( 'Slim&v.&Profiling.Profile-Rep&ort',            g:slimv_leader.'o',  g:slimv_leader.'pr',  ':<C-U>call SlimvProfileReport()<CR>' )
    1   0.000048   0.000006 call s:MenuMap( 'Slim&v.&Profiling.Profile-&Reset',             g:slimv_leader.'X',  g:slimv_leader.'px',  ':<C-U>call SlimvProfileReset()<CR>' )
                            
                            " Documentation commands
    1   0.000046   0.000006 call s:MenuMap( 'Slim&v.&Documentation.Describe-&Symbol',       g:slimv_leader.'s',  g:slimv_leader.'ds',  ':call SlimvDescribeSymbol()<CR>' )
    1   0.000044   0.000006 call s:MenuMap( 'Slim&v.&Documentation.&Apropos',               g:slimv_leader.'A',  g:slimv_leader.'dp',  ':call SlimvApropos()<CR>' )
    1   0.000044   0.000006 call s:MenuMap( 'Slim&v.&Documentation.&Hyperspec',             g:slimv_leader.'h',  g:slimv_leader.'dh',  ':call SlimvHyperspec()<CR>' )
    1   0.000044   0.000006 call s:MenuMap( 'Slim&v.&Documentation.Generate-&Tags',         g:slimv_leader.']',  g:slimv_leader.'dg',  ':call SlimvGenerateTags()<CR>' )
                            
                            " REPL commands
    1   0.000045   0.000006 call s:MenuMap( 'Slim&v.&Repl.&Connect-Server',                 g:slimv_leader.'c',  g:slimv_leader.'rc',  ':call SlimvConnectServer()<CR>' )
    1   0.000032   0.000005 call s:MenuMap( '',                                             g:slimv_leader.'g',  g:slimv_leader.'rp',  ':call SlimvSetPackage()<CR>' )
    1   0.000046   0.000006 call s:MenuMap( 'Slim&v.&Repl.Interrup&t-Lisp-Process',         g:slimv_leader.'y',  g:slimv_leader.'ri',  ':call SlimvInterrupt()<CR>' )
    1   0.000044   0.000006 call s:MenuMap( 'Slim&v.&Repl.Clear-&REPL',                     g:slimv_leader.'-',  g:slimv_leader.'-',   ':call SlimvClearReplBuffer()<CR>' )
    1   0.000044   0.000006 call s:MenuMap( 'Slim&v.&Repl.&Quit-REPL',                      g:slimv_leader.'Q',  g:slimv_leader.'rq',  ':call SlimvQuitRepl()<CR>' )
                            
                            
                            " =====================================================================
                            "  Slimv menu
                            " =====================================================================
                            
    1              0.000001 if g:slimv_menu == 1
                                " Works only if 'wildcharm' is <Tab>
    1              0.000002     if &wildcharm == 0
    1              0.000011         set wildcharm=<Tab>
    1              0.000001     endif
    1              0.000001     if &wildcharm != 0
    1              0.000012         execute ':map ' . g:slimv_leader.', :emenu Slimv.' . nr2char( &wildcharm )
    1              0.000001     endif
    1              0.000001 endif
                            
                            " Add REPL menu. This menu exist only for the REPL buffer.
    1              0.000002 function! SlimvAddReplMenu()
                                if &wildcharm != 0
                                    execute ':map ' . g:slimv_leader.'\ :emenu REPL.' . nr2char( &wildcharm )
                                endif
                            
                                amenu &REPL.Send-&Input                            :call SlimvSendCommand(0)<CR>
                                amenu &REPL.Cl&ose-Send-Input                      :call SlimvSendCommand(1)<CR>
                                amenu &REPL.Set-Packa&ge                           :call SlimvSetPackage()<CR>
                                amenu &REPL.Interrup&t-Lisp-Process                <Esc>:<C-U>call SlimvInterrupt()<CR>
                                amenu &REPL.-REPLSep-                              :
                                amenu &REPL.&Previous-Input                        :call SlimvPreviousCommand()<CR>
                                amenu &REPL.&Next-Input                            :call SlimvNextCommand()<CR>
                                amenu &REPL.Clear-&REPL                            :call SlimvClearReplBuffer()<CR>
                            endfunction
                            
                            " =====================================================================
                            "  Slimv commands
                            " =====================================================================
                            
    1              0.000015 command! -complete=customlist,SlimvCommandComplete -nargs=* Lisp call SlimvEval([<q-args>])
    1              0.000005 command! -complete=customlist,SlimvCommandComplete -nargs=* Eval call SlimvEval([<q-args>])
                            
                            " Switch on syntax highlighting
    1              0.000004 if !exists("g:syntax_on")
                                syntax on
                            endif
                            

SCRIPT  /usr/local/Cellar/neovim/0.2.0_1/share/nvim/runtime/autoload/provider/python3.vim
Sourced 1 time
Total time:   0.000218
 Self time:   0.000092

count  total (s)   self (s)
                            " The Python3 provider uses a Python3 host to emulate an environment for running
                            " python3 plugins. :help provider
                            "
                            " Associating the plugin with the Python3 host is the first step because
                            " plugins will be passed as command-line arguments
                            
    1              0.000007 if exists('g:loaded_python3_provider')
                              finish
                            endif
    1              0.000003 let g:loaded_python3_provider = 1
                            
    1   0.000029   0.000013 let [s:prog, s:err] = provider#pythonx#Detect(3)
                            
    1              0.000004 function! provider#python3#Prog()
                              return s:prog
                            endfunction
                            
    1              0.000003 function! provider#python3#Error()
                              return s:err
                            endfunction
                            
    1              0.000002 if s:prog == ''
                              " Detection failed
                              finish
                            endif
                            
                            " The Python3 provider plugin will run in a separate instance of the Python3
                            " host.
    1   0.000029   0.000010 call remote#host#RegisterClone('legacy-python3-provider', 'python3')
    1   0.000100   0.000009 call remote#host#RegisterPlugin('legacy-python3-provider', 'script_host.py', [])
                            
    1              0.000003 function! provider#python3#Call(method, args)
                              if s:err != ''
                                return
                              endif
                              if !exists('s:host')
                                let s:rpcrequest = function('rpcrequest')
                            
                                " Ensure that we can load the Python3 host before bootstrapping
                                try
                                  let s:host = remote#host#Require('legacy-python3-provider')
                                catch
                                  let s:err = v:exception
                                  echohl WarningMsg
                                  echomsg v:exception
                                  echohl None
                                  return
                                endtry
                              endif
                              return call(s:rpcrequest, insert(insert(a:args, 'python_'.a:method), s:host))
                            endfunction

SCRIPT  /usr/local/Cellar/neovim/0.2.0_1/share/nvim/runtime/ftplugin/lisp.vim
Sourced 1 time
Total time:   0.000017
 Self time:   0.000017

count  total (s)   self (s)
                            " Vim filetype plugin
                            " Language:      Lisp
                            " Maintainer:    Sergey Khorev <sergey.khorev@gmail.com>
                            " URL:		 http://sites.google.com/site/khorser/opensource/vim
                            " Original author:    Dorai Sitaram <ds26@gte.com>
                            " Original URL:		 http://www.ccs.neu.edu/~dorai/vimplugins/vimplugins.html
                            " Last Change:   Oct 23, 2013
                            
                            " Only do this when not done yet for this buffer
    1              0.000008 if exists("b:did_ftplugin")
    1              0.000002   finish

SCRIPT  /usr/local/Cellar/neovim/0.2.0_1/share/nvim/runtime/ftplugin/clojure.vim
Sourced 3 times
Total time:   0.000044
 Self time:   0.000044

count  total (s)   self (s)
                            " Vim filetype plugin file
                            " Language:     Clojure
                            " Author:       Meikel Brandmeyer <mb@kotka.de>
                            "
                            " Maintainer:   Sung Pae <self@sungpae.com>
                            " URL:          https://github.com/guns/vim-clojure-static
                            " License:      Same as Vim
                            " Last Change:  18 July 2016
                            
    3              0.000019 if exists("b:did_ftplugin")
    3              0.000005 	finish

SCRIPT  /Users/kenji/.vim/plugged/vim-clojure-static/indent/clojure.vim
Sourced 3 times
Total time:   0.001519
 Self time:   0.001519

count  total (s)   self (s)
                            " Vim indent file
                            " Language:     Clojure
                            " Author:       Meikel Brandmeyer <mb@kotka.de>
                            " URL:          http://kotka.de/projects/clojure/vimclojure.html
                            "
                            " Maintainer:   Sung Pae <self@sungpae.com>
                            " URL:          https://github.com/guns/vim-clojure-static
                            " License:      Same as Vim
                            " Last Change:  %%RELEASE_DATE%%
                            
    3              0.000020 if exists("b:did_indent")
                            	finish
                            endif
    3              0.000008 let b:did_indent = 1
                            
    3              0.000017 let s:save_cpo = &cpo
    3              0.000022 set cpo&vim
                            
    3              0.000009 let b:undo_indent = 'setlocal autoindent< smartindent< expandtab< softtabstop< shiftwidth< indentexpr< indentkeys<'
                            
    3              0.000023 setlocal noautoindent nosmartindent
    3              0.000020 setlocal softtabstop=2 shiftwidth=2 expandtab
    3              0.000009 setlocal indentkeys=!,o,O
                            
    3              0.000010 if exists("*searchpairpos")
                            
    3              0.000007 	if !exists('g:clojure_maxlines')
    1              0.000002 		let g:clojure_maxlines = 100
    1              0.000001 	endif
                            
    3              0.000006 	if !exists('g:clojure_fuzzy_indent')
    1              0.000002 		let g:clojure_fuzzy_indent = 1
    1              0.000001 	endif
                            
    3              0.000011 	if !exists('g:clojure_fuzzy_indent_patterns')
                            		let g:clojure_fuzzy_indent_patterns = ['^with', '^def', '^let']
                            	endif
                            
    3              0.000008 	if !exists('g:clojure_fuzzy_indent_blacklist')
    1              0.000003 		let g:clojure_fuzzy_indent_blacklist = ['-fn$', '\v^with-%(meta|out-str|loading-context)$']
    1              0.000002 	endif
                            
    3              0.000008 	if !exists('g:clojure_special_indent_words')
                            		let g:clojure_special_indent_words = 'deftype,defrecord,reify,proxy,extend-type,extend-protocol,letfn'
                            	endif
                            
    3              0.000007 	if !exists('g:clojure_align_multiline_strings')
    1              0.000002 		let g:clojure_align_multiline_strings = 0
    1              0.000001 	endif
                            
    3              0.000007 	if !exists('g:clojure_align_subforms')
                            		let g:clojure_align_subforms = 0
                            	endif
                            
    3              0.000008 	function! s:syn_id_name()
                            		return synIDattr(synID(line("."), col("."), 0), "name")
                            	endfunction
                            
    3              0.000004 	function! s:ignored_region()
                            		return s:syn_id_name() =~? '\vstring|regex|comment|character'
                            	endfunction
                            
    3              0.000004 	function! s:current_char()
                            		return getline('.')[col('.')-1]
                            	endfunction
                            
    3              0.000003 	function! s:current_word()
                            		return getline('.')[col('.')-1 : searchpos('\v>', 'n', line('.'))[1]-2]
                            	endfunction
                            
    3              0.000004 	function! s:is_paren()
                            		return s:current_char() =~# '\v[\(\)\[\]\{\}]' && !s:ignored_region()
                            	endfunction
                            
                            	" Returns 1 if string matches a pattern in 'patterns', which may be a
                            	" list of patterns, or a comma-delimited string of implicitly anchored
                            	" patterns.
    3              0.000005 	function! s:match_one(patterns, string)
                            		let list = type(a:patterns) == type([])
                            		           \ ? a:patterns
                            		           \ : map(split(a:patterns, ','), '"^" . v:val . "$"')
                            		for pat in list
                            			if a:string =~# pat | return 1 | endif
                            		endfor
                            	endfunction
                            
    3              0.000006 	function! s:match_pairs(open, close, stopat)
                            		" Stop only on vector and map [ resp. {. Ignore the ones in strings and
                            		" comments.
                            		if a:stopat == 0 && g:clojure_maxlines > 0
                            			let stopat = max([line(".") - g:clojure_maxlines, 0])
                            		else
                            			let stopat = a:stopat
                            		endif
                            
                            		let pos = searchpairpos(a:open, '', a:close, 'bWn', "!s:is_paren()", stopat)
                            		return [pos[0], col(pos)]
                            	endfunction
                            
    3              0.000005 	function! s:clojure_check_for_string_worker()
                            		" Check whether there is the last character of the previous line is
                            		" highlighted as a string. If so, we check whether it's a ". In this
                            		" case we have to check also the previous character. The " might be the
                            		" closing one. In case the we are still in the string, we search for the
                            		" opening ". If this is not found we take the indent of the line.
                            		let nb = prevnonblank(v:lnum - 1)
                            
                            		if nb == 0
                            			return -1
                            		endif
                            
                            		call cursor(nb, 0)
                            		call cursor(0, col("$") - 1)
                            		if s:syn_id_name() !~? "string"
                            			return -1
                            		endif
                            
                            		" This will not work for a " in the first column...
                            		if s:current_char() == '"'
                            			call cursor(0, col("$") - 2)
                            			if s:syn_id_name() !~? "string"
                            				return -1
                            			endif
                            			if s:current_char() != '\'
                            				return -1
                            			endif
                            			call cursor(0, col("$") - 1)
                            		endif
                            
                            		let p = searchpos('\(^\|[^\\]\)\zs"', 'bW')
                            
                            		if p != [0, 0]
                            			return p[1] - 1
                            		endif
                            
                            		return indent(".")
                            	endfunction
                            
    3              0.000006 	function! s:check_for_string()
                            		let pos = getpos('.')
                            		try
                            			let val = s:clojure_check_for_string_worker()
                            		finally
                            			call setpos('.', pos)
                            		endtry
                            		return val
                            	endfunction
                            
    3              0.000005 	function! s:strip_namespace_and_macro_chars(word)
                            		return substitute(a:word, "\\v%(.*/|[#'`~@^,]*)(.*)", '\1', '')
                            	endfunction
                            
    3              0.000048 	function! s:clojure_is_method_special_case_worker(position)
                            		" Find the next enclosing form.
                            		call search('\S', 'Wb')
                            
                            		" Special case: we are at a '(('.
                            		if s:current_char() == '('
                            			return 0
                            		endif
                            		call cursor(a:position)
                            
                            		let next_paren = s:match_pairs('(', ')', 0)
                            
                            		" Special case: we are now at toplevel.
                            		if next_paren == [0, 0]
                            			return 0
                            		endif
                            		call cursor(next_paren)
                            
                            		call search('\S', 'W')
                            		let w = s:strip_namespace_and_macro_chars(s:current_word())
                            		if g:clojure_special_indent_words =~# '\V\<' . w . '\>'
                            			return 1
                            		endif
                            
                            		return 0
                            	endfunction
                            
    3              0.000009 	function! s:is_method_special_case(position)
                            		let pos = getpos('.')
                            		try
                            			let val = s:clojure_is_method_special_case_worker(a:position)
                            		finally
                            			call setpos('.', pos)
                            		endtry
                            		return val
                            	endfunction
                            
                            	" Check if form is a reader conditional, that is, it is prefixed by #?
                            	" or @#?
    3              0.000006 	function! s:is_reader_conditional_special_case(position)
                            		if getline(a:position[0])[a:position[1] - 3 : a:position[1] - 2] == "#?"
                            			return 1
                            		endif
                            
                            		return 0
                            	endfunction
                            
                            	" Returns 1 for opening brackets, -1 for _anything else_.
    3              0.000006 	function! s:bracket_type(char)
                            		return stridx('([{', a:char) > -1 ? 1 : -1
                            	endfunction
                            
                            	" Returns: [opening-bracket-lnum, indent]
    3              0.000004 	function! s:clojure_indent_pos()
                            		" Get rid of special case.
                            		if line(".") == 1
                            			return [0, 0]
                            		endif
                            
                            		" We have to apply some heuristics here to figure out, whether to use
                            		" normal lisp indenting or not.
                            		let i = s:check_for_string()
                            		if i > -1
                            			return [0, i + !!g:clojure_align_multiline_strings]
                            		endif
                            
                            		call cursor(0, 1)
                            
                            		" Find the next enclosing [ or {. We can limit the second search
                            		" to the line, where the [ was found. If no [ was there this is
                            		" zero and we search for an enclosing {.
                            		let paren = s:match_pairs('(', ')', 0)
                            		let bracket = s:match_pairs('\[', '\]', paren[0])
                            		let curly = s:match_pairs('{', '}', bracket[0])
                            
                            		" In case the curly brace is on a line later then the [ or - in
                            		" case they are on the same line - in a higher column, we take the
                            		" curly indent.
                            		if curly[0] > bracket[0] || curly[1] > bracket[1]
                            			if curly[0] > paren[0] || curly[1] > paren[1]
                            				return curly
                            			endif
                            		endif
                            
                            		" If the curly was not chosen, we take the bracket indent - if
                            		" there was one.
                            		if bracket[0] > paren[0] || bracket[1] > paren[1]
                            			return bracket
                            		endif
                            
                            		" There are neither { nor [ nor (, ie. we are at the toplevel.
                            		if paren == [0, 0]
                            			return paren
                            		endif
                            
                            		" Now we have to reimplement lispindent. This is surprisingly easy, as
                            		" soon as one has access to syntax items.
                            		"
                            		" - Check whether we are in a special position after a word in
                            		"   g:clojure_special_indent_words. These are special cases.
                            		" - Get the next keyword after the (.
                            		" - If its first character is also a (, we have another sexp and align
                            		"   one column to the right of the unmatched (.
                            		" - In case it is in lispwords, we indent the next line to the column of
                            		"   the ( + sw.
                            		" - If not, we check whether it is last word in the line. In that case
                            		"   we again use ( + sw for indent.
                            		" - In any other case we use the column of the end of the word + 2.
                            		call cursor(paren)
                            
                            		if s:is_method_special_case(paren)
                            			return [paren[0], paren[1] + &shiftwidth - 1]
                            		endif
                            
                            		if s:is_reader_conditional_special_case(paren)
                            			return paren
                            		endif
                            
                            		" In case we are at the last character, we use the paren position.
                            		if col("$") - 1 == paren[1]
                            			return paren
                            		endif
                            
                            		" In case after the paren is a whitespace, we search for the next word.
                            		call cursor(0, col('.') + 1)
                            		if s:current_char() == ' '
                            			call search('\v\S', 'W')
                            		endif
                            
                            		" If we moved to another line, there is no word after the (. We
                            		" use the ( position for indent.
                            		if line(".") > paren[0]
                            			return paren
                            		endif
                            
                            		" We still have to check, whether the keyword starts with a (, [ or {.
                            		" In that case we use the ( position for indent.
                            		let w = s:current_word()
                            		if s:bracket_type(w[0]) == 1
                            			return paren
                            		endif
                            
                            		" Test words without namespace qualifiers and leading reader macro
                            		" metacharacters.
                            		"
                            		" e.g. clojure.core/defn and #'defn should both indent like defn.
                            		let ww = s:strip_namespace_and_macro_chars(w)
                            
                            		if &lispwords =~# '\V\<' . ww . '\>'
                            			return [paren[0], paren[1] + &shiftwidth - 1]
                            		endif
                            
                            		if g:clojure_fuzzy_indent
                            			\ && !s:match_one(g:clojure_fuzzy_indent_blacklist, ww)
                            			\ && s:match_one(g:clojure_fuzzy_indent_patterns, ww)
                            			return [paren[0], paren[1] + &shiftwidth - 1]
                            		endif
                            
                            		call search('\v\_s', 'cW')
                            		call search('\v\S', 'W')
                            		if paren[0] < line(".")
                            			return [paren[0], paren[1] + (g:clojure_align_subforms ? 0 : &shiftwidth - 1)]
                            		endif
                            
                            		call search('\v\S', 'bW')
                            		return [line('.'), col('.') + 1]
                            	endfunction
                            
    3              0.000007 	function! GetClojureIndent()
                            		let lnum = line('.')
                            		let orig_lnum = lnum
                            		let orig_col = col('.')
                            		let [opening_lnum, indent] = s:clojure_indent_pos()
                            
                            		" Account for multibyte characters
                            		if opening_lnum > 0
                            			let indent -= indent - virtcol([opening_lnum, indent])
                            		endif
                            
                            		" Return if there are no previous lines to inherit from
                            		if opening_lnum < 1 || opening_lnum >= lnum - 1
                            			call cursor(orig_lnum, orig_col)
                            			return indent
                            		endif
                            
                            		let bracket_count = 0
                            
                            		" Take the indent of the first previous non-white line that is
                            		" at the same sexp level. cf. src/misc1.c:get_lisp_indent()
                            		while 1
                            			let lnum = prevnonblank(lnum - 1)
                            			let col = 1
                            
                            			if lnum <= opening_lnum
                            				break
                            			endif
                            
                            			call cursor(lnum, col)
                            
                            			" Handle bracket counting edge case
                            			if s:is_paren()
                            				let bracket_count += s:bracket_type(s:current_char())
                            			endif
                            
                            			while 1
                            				if search('\v[(\[{}\])]', '', lnum) < 1
                            					break
                            				elseif !s:ignored_region()
                            					let bracket_count += s:bracket_type(s:current_char())
                            				endif
                            			endwhile
                            
                            			if bracket_count == 0
                            				" Check if this is part of a multiline string
                            				call cursor(lnum, 1)
                            				if s:syn_id_name() !~? '\vstring|regex'
                            					call cursor(orig_lnum, orig_col)
                            					return indent(lnum)
                            				endif
                            			endif
                            		endwhile
                            
                            		call cursor(orig_lnum, orig_col)
                            		return indent
                            	endfunction
                            
    3              0.000017 	setlocal indentexpr=GetClojureIndent()
                            
    3              0.000003 else
                            
                            	" In case we have searchpairpos not available we fall back to
                            	" normal lisp indenting.
                            	setlocal indentexpr=
                            	setlocal lisp
                            	let b:undo_indent .= '| setlocal lisp<'
                            
                            endif
                            
    3              0.000022 let &cpo = s:save_cpo
    3              0.000006 unlet! s:save_cpo
                            
                            " vim:sts=8:sw=8:ts=8:noet

SCRIPT  /Users/kenji/.vim/plugged/slimv/indent/clojure.vim
Sourced 3 times
Total time:   0.000051
 Self time:   0.000051

count  total (s)   self (s)
                            " clojure.vim:
                            "               Clojure indent plugin for Slimv
                            " Version:      0.9.14
                            " Last Change:  05 Apr 2017
                            " Maintainer:   Tamas Kovacs <kovisoft at gmail dot com>
                            " License:      This file is placed in the public domain.
                            "               No warranty, express or implied.
                            "               *** ***   Use At-Your-Own-Risk!   *** ***
                            "
                            " =====================================================================
                            "
                            "  Load Once:
    3              0.000021 if exists("b:did_indent") || exists("b:slimv_did_indent") || exists("g:slimv_disable_clojure")
    3              0.000004    finish

SCRIPT  /usr/local/Cellar/neovim/0.2.0_1/share/nvim/runtime/indent/clojure.vim
Sourced 3 times
Total time:   0.000043
 Self time:   0.000043

count  total (s)   self (s)
                            " Vim indent file
                            " Language:     Clojure
                            " Author:       Meikel Brandmeyer <mb@kotka.de>
                            " URL:          http://kotka.de/projects/clojure/vimclojure.html
                            "
                            " Maintainer:   Sung Pae <self@sungpae.com>
                            " URL:          https://github.com/guns/vim-clojure-static
                            " License:      Same as Vim
                            " Last Change:  18 July 2016
                            
    3              0.000016 if exists("b:did_indent")
    3              0.000004 	finish

SCRIPT  /Users/kenji/.vim/plugged/vim-classpath/autoload/classpath.vim
Sourced 1 time
Total time:   0.000141
 Self time:   0.000141

count  total (s)   self (s)
                            " autoload/classpath.vim
                            " Maintainer:   Tim Pope <http://tpo.pe>
                            
    1              0.000007 if exists("g:autoloaded_classpath")
                              finish
                            endif
    1              0.000003 let g:autoloaded_classpath = 1
                            
    1              0.000003 if !exists('g:classpath_cache')
                              let g:classpath_cache = '~/.cache/vim/classpath'
                            endif
                            
    1              0.000014 if !isdirectory(expand(g:classpath_cache))
                              call mkdir(expand(g:classpath_cache), 'p')
                            endif
                            
    1              0.000003 function! classpath#separator() abort
                             return has('win32') ? ';' : ':'
                            endfunction
                            
    1              0.000002 function! classpath#file_separator() abort
                             return exists('shellslash') && !&shellslash ? '\' : '/'
                            endfunction
                            
    1              0.000002 function! classpath#split(cp) abort
                              return split(a:cp, classpath#separator())
                            endfunction
                            
    1              0.000002 function! classpath#to_vim(cp) abort
                              let path = []
                              for elem in classpath#split(a:cp)
                                let path += [elem ==# '.' ? '' : elem]
                              endfor
                              if a:cp =~# '\(^\|:\)\.$'
                                let path += ['']
                              endif
                              return join(map(path, 'escape(v:val, ", ")'), ',')
                            endfunction
                            
    1              0.000002 function! classpath#from_vim(path) abort
                              if a:path =~# '^,\=$'
                                return '.'
                              endif
                              let path = []
                              for elem in split(substitute(a:path, ',$', '', ''), ',')
                                if elem ==# ''
                                  let path += ['.']
                                else
                                  let path += split(glob(substitute(elem, '\\\ze[\\ ,]', '', 'g'), 1), "\n")
                                endif
                              endfor
                              return join(path, classpath#separator())
                            endfunction
                            
    1              0.000002 function! classpath#detect(...) abort
                              let sep = classpath#file_separator()
                            
                              let buffer = a:0 ? a:1 : '%'
                              let default = $CLASSPATH ==# '' ? ',' : classpath#to_vim($CLASSPATH)
                              let root = getbufvar(buffer, 'java_root')
                              if root ==# ''
                                let root = simplify(fnamemodify(bufname(buffer), ':p:s?[\/]$??'))
                              endif
                            
                              if !isdirectory(fnamemodify(root, ':h'))
                                return default
                              endif
                            
                              let previous = ""
                              while root !=# previous
                                if filereadable(root . '/project.clj') && join(readfile(root . '/project.clj', '', 50), "\n") =~# '(\s*defproject'
                                  let file = 'project.clj'
                                  let cmd = 'lein classpath'
                                  let pattern = "[^\n]*\\ze\n*$"
                                  let default = join(map(['test', 'src', 'dev-resources', 'resources', 'target'.sep.'classes'], 'escape(root . sep . v:val, ", ")'), ',')
                                  let base = ''
                                  break
                                endif
                                if filereadable(root . '/pom.xml')
                                  let file = 'pom.xml'
                                  let cmd = 'mvn dependency:build-classpath'
                                  let pattern = '\%(^\|classpath:\n\)\zs[^[].\{-\}\ze\n'
                                  let base = ''
                                  for line in filter(readfile(root . '/pom.xml'), 'v:val =~# "<directory>.*</directory>"')
                                    let base .= escape(root.sep.matchstr(line, '<directory>\zs.*\ze</directory>'), ', ').','
                                  endfor
                                  if empty(base)
                                    let base = escape(root.sep.'src'.sep.'*'.sep.'*', ', ') . ','
                                  endif
                                  let default = base . default
                                  break
                                endif
                                let previous = root
                                let root = fnamemodify(root, ':h')
                              endwhile
                            
                              if !exists('cmd') || !executable(matchstr(cmd, '^\S\+'))
                                if a:0 > 1 && a:2 ==# 'keep'
                                  return ''
                                else
                                  return default
                                endif
                              endif
                            
                              let cache = expand(g:classpath_cache . '/') . substitute(root, '[:\/]', '%', 'g')
                              let disk = getftime(root . sep . file)
                            
                              if getftime(cache) >= disk
                                return join(readfile(cache), classpath#separator())
                              else
                                try
                                  if &verbose
                                    echomsg 'Determining class path with '.cmd.' ...'
                                  endif
                                  let cd = exists('*haslocaldir') && haslocaldir() ? 'lcd ' : 'cd '
                                  let dir = getcwd()
                                  try
                                    execute cd . fnameescape(root)
                                    let out = system(cmd)
                                  finally
                                    execute cd . fnameescape(dir)
                                  endtry
                                catch /^Vim:Interrupt/
                                  return default
                                endtry
                                let match = matchstr(out, pattern)
                                if !v:shell_error && exists('out') && out !=# ''
                                  let path = base . classpath#to_vim(match)
                                else
                                  echohl WarningMSG
                                  echomsg "Couldn't determine class path."
                                  echohl NONE
                                  echo out
                                  let path = default
                                endif
                                call writefile([path], cache)
                                return path
                              endif
                            endfunction
                            
    1              0.000002 function! classpath#java_cmd(...)
                              let path = classpath#from_vim(a:0 ? a:1 : &path)
                              return (exists('$JAVA_CMD') ? $JAVA_CMD : 'java') . ' -cp '.shellescape(path)
                            endfunction
                            
                            " vim:set et sw=2:

SCRIPT  /Users/kenji/.vim/plugged/vim-clojure-highlight/autoload/vim_clojure_highlight.vim
Sourced 1 time
Total time:   0.000042
 Self time:   0.000042

count  total (s)   self (s)
                            " vim-clojure-highlight
                            
    1              0.000006 function! s:session_exists()
                            	return exists('g:fireplace_nrepl_sessions') && len(g:fireplace_nrepl_sessions)
                            endfunction
                            
    1              0.000002 function! s:require()
                            	if fireplace#evalparse("(find-ns 'vim-clojure-highlight)") ==# ''
                            		let buf = join(readfile(globpath(&runtimepath, 'autoload/vim_clojure_highlight.clj')), "\n")
                            		call fireplace#session_eval('(do ' . buf . ')')
                            	endif
                            endfunction
                            
                            " Pass zero explicitly to prevent highlighting local vars
    1              0.000003 function! vim_clojure_highlight#syntax_match_references(...)
                            	if !s:session_exists() | return | endif
                            
                            	try
                            		call s:require()
                            
                            		let ns = "'" . fireplace#ns()
                            		let opts = (a:0 > 0 && !a:1) ? ' :local-vars false' : ''
                            
                            		execute fireplace#evalparse("(vim-clojure-highlight/ns-syntax-command " . ns . opts . ")")
                            		let &syntax = &syntax
                            	catch /./
                            	endtry
                            endfunction
                            
                            " vim:noet:sw=8:ts=8

SCRIPT  /Users/kenji/.vim/plugged/vim-airline/autoload/airline/async.vim
Sourced 1 time
Total time:   0.001268
 Self time:   0.001268

count  total (s)   self (s)
                            " MIT License. Copyright (c) 2013-2017 C.Brabandt
                            " vim: et ts=2 sts=2 sw=2
                            
    1              0.000013 let s:untracked_jobs = {}
    1              0.000004 let s:mq_jobs        = {}
    1              0.000003 let s:po_jobs        = {}
                            
                            " Generic functions handling on exit event of the various async functions
    1              0.000007 function! s:untracked_output(dict, buf)
                              if a:buf =~? ('^'. a:dict.cfg['untracked_mark'])
                                let a:dict.cfg.untracked[a:dict.file] = get(g:, 'airline#extensions#branch#notexists', g:airline_symbols.notexists)
                              else
                                let a:dict.cfg.untracked[a:dict.file] = ''
                              endif
                            endfunction
                            
                            " also called from branch extension (for non-async vims)
    1              0.000008 function! airline#async#mq_output(buf, file)
                              let buf=a:buf
                              if !empty(a:buf)
                                if a:buf =~# 'no patches applied' ||
                                  \ a:buf =~# "unknown command 'qtop'" ||
                                  \ a:buf =~# "abort"
                                  let buf = ''
                                elseif exists("b:mq") && b:mq isnot# buf
                                  " make sure, statusline is updated
                                  unlet! b:airline_head
                                endif
                                let b:mq = buf
                              endif
                              if has_key(s:mq_jobs, a:file)
                                call remove(s:mq_jobs, a:file)
                              endif
                            endfunction
                            
    1              0.000006 function! s:po_output(buf, file)
                              if !empty(a:buf)
                                let b:airline_po_stats = printf("[%s]", a:buf)
                              else
                                let b:airline_po_stats = ''
                              endif
                              if has_key(s:po_jobs, a:file)
                                call remove(s:po_jobs, a:file)
                              endif
                            endfunction
                            
    1              0.000003 function! s:valid_dir(dir)
                              if empty(a:dir) || !isdirectory(a:dir)
                                return getcwd()
                              endif
                              return a:dir
                            endfunction
                            
    1              0.000008 if v:version >= 800 && has("job")
                              " Vim 8.0 with Job feature
                            
                              function! s:on_stdout(channel, msg) dict abort
                                let self.buf .= a:msg
                              endfunction
                            
                              function! s:on_exit_mq(channel) dict abort
                                call airline#async#mq_output(self.buf, self.file)
                              endfunction
                            
                              function! s:on_exit_untracked(channel) dict abort
                                call s:untracked_output(self, self.buf)
                                if has_key(s:untracked_jobs, self.file)
                                  call remove(s:untracked_jobs, self.file)
                                endif
                              endfunction
                            
                              function! s:on_exit_po(channel) dict abort
                                call s:po_output(self.buf, self.file)
                                call airline#extensions#po#shorten()
                              endfunction
                            
                              function! airline#async#get_mq_async(cmd, file)
                                if g:airline#init#is_windows && &shell =~ 'cmd'
                                  let cmd = a:cmd
                                else
                                  let cmd = ['sh', '-c', a:cmd]
                                endif
                            
                                let options = {'cmd': a:cmd, 'buf': '', 'file': a:file}
                                if has_key(s:mq_jobs, a:file)
                                  if job_status(get(s:mq_jobs, a:file)) == 'run'
                                    return
                                  elseif has_key(s:mq_jobs, a:file)
                                    call remove(s:mq_jobs, a:file)
                                  endif
                                endif
                                let id = job_start(cmd, {
                                      \ 'err_io':   'out',
                                      \ 'out_cb':   function('s:on_stdout', options),
                                      \ 'close_cb': function('s:on_exit_mq', options)})
                                let s:mq_jobs[a:file] = id
                              endfunction
                            
                              function! airline#async#get_msgfmt_stat(cmd, file)
                                if g:airline#init#is_windows || !executable('msgfmt')
                                  " no msgfmt on windows?
                                  return
                                else
                                  let cmd = ['sh', '-c', a:cmd. shellescape(a:file)]
                                endif
                            
                                let options = {'buf': '', 'file': a:file}
                                if has_key(s:po_jobs, a:file)
                                  if job_status(get(s:po_jobs, a:file)) == 'run'
                                    return
                                  elseif has_key(s:po_jobs, a:file)
                                    call remove(s:po_jobs, a:file)
                                  endif
                                endif
                                let id = job_start(cmd, {
                                      \ 'err_io':   'out',
                                      \ 'out_cb':   function('s:on_stdout', options),
                                      \ 'close_cb': function('s:on_exit_po', options)})
                                let s:po_jobs[a:file] = id
                              endfunction
                            
                              function airline#async#vim_vcs_untracked(config, file)
                                if g:airline#init#is_windows && &shell =~ 'cmd'
                                  let cmd = a:config['cmd'] . shellescape(a:file)
                                else
                                  let cmd = ['sh', '-c', a:config['cmd'] . shellescape(a:file)]
                                endif
                            
                                let options = {'cfg': a:config, 'buf': '', 'file': a:file}
                                if has_key(s:untracked_jobs, a:file)
                                  if job_status(get(s:untracked_jobs, a:file)) == 'run'
                                    return
                                  elseif has_key(s:untracked_jobs, a:file)
                                    call remove(s:untracked_jobs, a:file)
                                  endif
                                endif
                                let id = job_start(cmd, {
                                      \ 'err_io':   'out',
                                      \ 'out_cb':   function('s:on_stdout', options),
                                      \ 'close_cb': function('s:on_exit_untracked', options)})
                                let s:untracked_jobs[a:file] = id
                              endfunction
                            
                            elseif has("nvim")
                              " NVim specific functions
                            
    1              0.000006   function! s:nvim_output_handler(job_id, data, event) dict
                                if a:event == 'stdout' || a:event == 'stderr'
                                  let self.buf .=  join(a:data)
                                endif
                              endfunction
                            
    1              0.000003   function! s:nvim_untracked_job_handler(job_id, data, event) dict
                                if a:event == 'exit'
                                  call s:untracked_output(self, self.buf)
                                  if has_key(s:untracked_jobs, self.file)
                                    call remove(s:untracked_jobs, self.file)
                                  endif
                                endif
                              endfunction
                            
    1              0.000002   function! s:nvim_mq_job_handler(job_id, data, event) dict
                                if a:event == 'exit'
                                  call airline#async#mq_output(self.buf, self.file)
                                endif
                              endfunction
                            
    1              0.000002   function! s:nvim_po_job_handler(job_id, data, event) dict
                                if a:event == 'exit'
                                  call s:po_output(self.buf, self.file)
                                  call airline#extensions#po#shorten()
                                endif
                              endfunction
                            
    1              0.000005   function! airline#async#nvim_get_mq_async(cmd, file)
                                let config = {
                                \ 'buf': '',
                                \ 'file': a:file,
                                \ 'cwd': s:valid_dir(fnamemodify(a:file, ':p:h')),
                                \ 'on_stdout': function('s:nvim_output_handler'),
                                \ 'on_stderr': function('s:nvim_output_handler'),
                                \ 'on_exit': function('s:nvim_mq_job_handler')
                                \ }
                                if g:airline#init#is_windows && &shell =~ 'cmd'
                                  let cmd = a:cmd
                                else
                                  let cmd = ['sh', '-c', a:cmd]
                                endif
                            
                                if has_key(s:mq_jobs, a:file)
                                  call remove(s:mq_jobs, a:file)
                                endif
                                let id = jobstart(cmd, config)
                                let s:mq_jobs[a:file] = id
                              endfunction
                            
    1              0.000003   function! airline#async#nvim_get_msgfmt_stat(cmd, file)
                                let config = {
                                \ 'buf': '',
                                \ 'file': a:file,
                                \ 'cwd': s:valid_dir(fnamemodify(a:file, ':p:h')),
                                \ 'on_stdout': function('s:nvim_output_handler'),
                                \ 'on_stderr': function('s:nvim_output_handler'),
                                \ 'on_exit': function('s:nvim_po_job_handler')
                                \ }
                                if g:airline#init#is_windows && &shell =~ 'cmd'
                                  " no msgfmt on windows?
                                  return
                                else
                                  let cmd = ['sh', '-c', a:cmd. shellescape(a:file)]
                                endif
                            
                                if has_key(s:po_jobs, a:file)
                                  call remove(s:po_jobs, a:file)
                                endif
                                let id = jobstart(cmd, config)
                                let s:po_jobs[a:file] = id
                              endfunction
                            
    1              0.000002 endif
                            
                            " Should work in either Vim pre 8 or Nvim
    1              0.000003 function! airline#async#nvim_vcs_untracked(cfg, file, vcs)
                              let cmd = a:cfg.cmd . shellescape(a:file)
                              let id = -1
                              let config = {
                              \ 'buf': '',
                              \ 'vcs': a:vcs,
                              \ 'cfg': a:cfg,
                              \ 'file': a:file,
                              \ 'cwd': s:valid_dir(fnamemodify(a:file, ':p:h'))
                              \ }
                              if has("nvim")
                                call extend(config, {
                                \ 'on_stdout': function('s:nvim_output_handler'),
                                \ 'on_exit': function('s:nvim_untracked_job_handler')})
                                if has_key(s:untracked_jobs, config.file)
                                  " still running
                                  return
                                endif
                                let id = jobstart(cmd, config)
                                let s:untracked_jobs[a:file] = id
                              endif
                              " vim without job feature or nvim jobstart failed
                              if id < 1
                                let output=system(cmd)
                                call s:untracked_output(config, output)
                                call airline#extensions#branch#update_untracked_config(a:file, a:vcs)
                              endif
                            endfunction

FUNCTION  <SNR>50_savetofile()
Called 1 time
Total time:   0.017240
 Self time:   0.000016

count  total (s)   self (s)
    1   0.017239   0.000015 	cal ctrlp#utils#writecache(a:mrufs, s:cadir, s:cafile)

FUNCTION  airline#extensions#quickfix#inactive_qf_window()
Called 6 times
Total time:   0.000078
 Self time:   0.000078

count  total (s)   self (s)
    6              0.000052   if getbufvar(a:2.bufnr, '&filetype') is# 'qf' && !empty(airline#util#getwinvar(a:2.winnr, 'quickfix_title', ''))
                                call setwinvar(a:2.winnr, 'airline_section_c', '[%{get(w:, "quickfix_title", "")}] %f %m')
                              endif

FUNCTION  airline#extensions#neomake#get_errors()
Called 6 times
Total time:   0.000296
 Self time:   0.000090

count  total (s)   self (s)
    6   0.000250   0.000044   let counts = s:get_counts()
    6              0.000025   let errors = get(counts, 'E', 0)
    6              0.000015   return errors ? s:error_symbol.errors : ''

FUNCTION  <SNR>147_set_up_go_to_file()
Called 2 times
Total time:   0.002602
 Self time:   0.000201

count  total (s)   self (s)
    2              0.000009   if expand('%:e') ==# 'cljs'
                                setlocal suffixesadd=.cljs,.cljc,.cljx,.clj,.java
                              else
    2              0.000011     setlocal suffixesadd=.clj,.cljc,.cljx,.cljs,.java
    2              0.000002   endif
                            
    2              0.000030   cmap <buffer><script><expr> <Plug><cfile> substitute(fireplace#cfile(),'^$',"\022\006",'')
    2              0.000021   cmap <buffer><script><expr> <Plug><cpath> <SID>Find('','')
    2              0.000009   if get(g:, 'fireplace_no_maps') | return | endif
    2   0.000084   0.000014   call s:map('c', '<C-R><C-F>', '<Plug><cfile>')
    2   0.000078   0.000012   call s:map('c', '<C-R><C-P>', '<Plug><cpath>')
    2   0.002003   0.000020   call s:map('n', 'gf',         '<Plug>FireplaceEditFile',    '<unique>')
    2   0.000155   0.000029   call s:map('n', '<C-W>f',     '<Plug>FireplaceSplitFile',   '<unique>')
    2   0.000096   0.000016   call s:map('n', '<C-W><C-F>', '<Plug>FireplaceSplitFile',   '<unique>')
    2   0.000092   0.000016   call s:map('n', '<C-W>gf',    '<Plug>FireplaceTabeditFile', '<unique>')

FUNCTION  4()
Called 1 time
Total time:   0.000039
 Self time:   0.000031

count  total (s)   self (s)
    1              0.000002     let prependCWD = 0
    1   0.000014   0.000006     if nerdtree#runningWindows()
                                    let prependCWD = a:str !~# '^.:\(\\\|\/\)' && a:str !~# '^\(\\\\\|\/\/\)'
                                else
    1              0.000006         let prependCWD = a:str !~# '^/'
    1              0.000001     endif
                            
    1              0.000003     let toReturn = a:str
    1              0.000002     if prependCWD
                                    let toReturn = getcwd() . s:Path.Slash() . a:str
                                endif
                            
    1              0.000002     return toReturn

FUNCTION  <SNR>130_get_accented_line()
Called 58 times
Total time:   0.003548
 Self time:   0.003548

count  total (s)   self (s)
   58              0.000097   if a:self._context.active
   38              0.000068     let contents = []
   38              0.000352     let content_parts = split(a:contents, '__accent')
   92              0.000170     for cpart in content_parts
   54              0.000632       let accent = matchstr(cpart, '_\zs[^#]*\ze')
   54              0.000167       call add(contents, cpart)
   54              0.000086     endfor
   38              0.000182     let line = join(contents, a:group)
   38              0.000308     let line = substitute(line, '__restore__', a:group, 'g')
   38              0.000037   else
   20              0.000347     let line = substitute(a:contents, '%#__accent[^#]*#', '', 'g')
   20              0.000151     let line = substitute(line, '%#__restore__#', '', 'g')
   20              0.000018   endif
   58              0.000076   return line

FUNCTION  remote#host#Require()
Called 1 time
Total time:   0.000021
 Self time:   0.000021

count  total (s)   self (s)
    1              0.000003   if !has_key(s:hosts, a:name)
                                throw 'No host named "'.a:name.'" is registered'
                              endif
    1              0.000004   let host = s:hosts[a:name]
    1              0.000002   if !host.channel && !host.initialized
                                let host_info = { 'name': a:name, 'orig_name': get(host, 'orig_name', a:name) }
                                let host.channel = call(host.factory, [host_info])
                                let host.initialized = 1
                              endif
    1              0.000001   return host.channel

FUNCTION  airline#extensions#netrw#apply()
Called 6 times
Total time:   0.000136
 Self time:   0.000136

count  total (s)   self (s)
    6              0.000022   if &ft == 'netrw'
                                let spc = g:airline_symbols.space
                            
                                call a:1.add_section('airline_a', spc.'netrw'.spc)
                                if exists('*airline#extensions#branch#get_head')
                                  call a:1.add_section('airline_b', spc.'%{airline#extensions#branch#get_head()}'.spc)
                                endif
                                call a:1.add_section('airline_c', spc.'%f'.spc)
                                call a:1.split()
                                call a:1.add_section('airline_y', spc.'%{airline#extensions#netrw#sortstring()}'.spc)
                                return 1
                              endif

FUNCTION  classpath#split()
Called 1 time
Total time:   0.000045
 Self time:   0.000038

count  total (s)   self (s)
    1   0.000044   0.000037   return split(a:cp, classpath#separator())

FUNCTION  airline#extensions#unite#apply()
Called 6 times
Total time:   0.000116
 Self time:   0.000116

count  total (s)   self (s)
    6              0.000033   if &ft == 'unite'
                                call a:1.add_section('airline_a', ' Unite ')
                                call a:1.add_section('airline_b', ' %{get(unite#get_context(), "buffer_name", "")} ')
                                call a:1.add_section('airline_c', ' %{unite#get_status_string()} ')
                                call a:1.split()
                                call a:1.add_section('airline_y', ' %{get(unite#get_context(), "real_buffer_name", "")} ')
                                return 1
                              endif

FUNCTION  <SNR>102_Highlight_Matching_Pair()
Called 8 times
Total time:   0.001964
 Self time:   0.001964

count  total (s)   self (s)
                              " Remove any previous match.
    8              0.000031   if exists('w:paren_hl_on') && w:paren_hl_on
                                silent! call matchdelete(3)
                                let w:paren_hl_on = 0
                              endif
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
    8              0.000037   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
                              endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
    8              0.000028   let c_lnum = line('.')
    8              0.000024   let c_col = col('.')
    8              0.000013   let before = 0
                            
    8              0.000027   let text = getline(c_lnum)
    8              0.000136   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
    8              0.000022   if empty(matches)
                                let [c_before, c] = ['', '']
                              else
    8              0.000039     let [c_before, c] = matches[1:2]
    8              0.000007   endif
    8              0.000141   let plist = split(&matchpairs, '.\zs[:,]')
    8              0.000033   let i = index(plist, c)
    8              0.000013   if i < 0
                                " not found, in Insert mode try character before the cursor
    7              0.000021     if c_col > 1 && (mode() == 'i' || mode() == 'R')
                                  let before = strlen(c_before)
                                  let c = c_before
                                  let i = index(plist, c)
                                endif
    7              0.000009     if i < 0
                                  " not found, nothing to do
    7              0.000009       return
                                endif
                              endif
                            
                              " Figure out the arguments for searchpairpos().
    1              0.000002   if i % 2 == 0
    1              0.000002     let s_flags = 'nW'
    1              0.000003     let c2 = plist[i + 1]
    1              0.000001   else
                                let s_flags = 'nbW'
                                let c2 = c
                                let c = plist[i - 1]
                              endif
    1              0.000002   if c == '['
                                let c = '\['
                                let c2 = '\]'
                              endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
    1              0.000002   if before > 0
                                let has_getcurpos = exists("*getcurpos")
                                if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
                                  let save_cursor = getcurpos()
                                else
                                  let save_cursor = winsaveview()
                                endif
                                call cursor(c_lnum, c_col - before)
                              endif
                            
                              " Build an expression that detects whether the current cursor position is in
                              " certain syntax types (string, comment, etc.), for use as searchpairpos()'s
                              " skip argument.
                              " We match "escape" for special items, such as lispEscapeSpecial.
    1              0.000006   let s_skip = '!empty(filter(map(synstack(line("."), col(".")), ''synIDattr(v:val, "name")''), ' . '''v:val =~? "string\\|character\\|singlequote\\|escape\\|comment"''))'
                              " If executing the expression determines that the cursor is currently in
                              " one of the syntax types, then we want searchpairpos() to find the pair
                              " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                              " outside of the syntax types and s_skip should keep its value so we skip any
                              " matching pair inside the syntax types.
    1              0.000515   execute 'if' s_skip '| let s_skip = 0 | endif'
                            
                              " Limit the search to lines visible in the window.
    1              0.000005   let stoplinebottom = line('w$')
    1              0.000004   let stoplinetop = line('w0')
    1              0.000002   if i % 2 == 0
    1              0.000003     let stopline = stoplinebottom
    1              0.000001   else
                                let stopline = stoplinetop
                              endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
    1              0.000004   if mode() == 'i' || mode() == 'R'
                                let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
                              else
    1              0.000005     let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
    1              0.000001   endif
    1              0.000002   try
    1              0.000426     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
    1              0.000003   catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
                              endtry
                            
    1              0.000002   if before > 0
                                if has_getcurpos
                                  call setpos('.', save_cursor)
                                else
                                  call winrestview(save_cursor)
                                endif
                              endif
                            
                              " If a match is found setup match highlighting.
    1              0.000004   if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
    1              0.000004     if exists('*matchaddpos')
    1              0.000019       call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
    1              0.000001     else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
                                endif
    1              0.000006     let w:paren_hl_on = 1
    1              0.000001   endif

FUNCTION  <SNR>78_startup_load_bookmarks()
Called 1 time
Total time:   0.000267
 Self time:   0.000032

count  total (s)   self (s)
    1   0.000236   0.000022   call BookmarkLoad(s:bookmark_save_file(a:file), 1, 1)
    1   0.000029   0.000009   call s:add_missing_signs(a:file)

FUNCTION  <SNR>51_init()
Called 6 times
Total time:   0.000022
 Self time:   0.000022

count  total (s)   self (s)
    6              0.000010   if s:airline_initialized
    6              0.000006     return
                              endif
                              let s:airline_initialized = 1
                            
                              call airline#extensions#load()
                              call airline#init#sections()
                            
                              let s:theme_in_vimrc = exists('g:airline_theme')
                              if s:theme_in_vimrc
                                try
                                  let palette = g:airline#themes#{g:airline_theme}#palette
                                catch
                                  echom 'Could not resolve airline theme "' . g:airline_theme . '". Themes have been migrated to github.com/vim-airline/vim-airline-themes.'
                                  let g:airline_theme = 'dark'
                                endtry
                                silent call airline#switch_theme(g:airline_theme)
                              else
                                let g:airline_theme = 'dark'
                                silent call s:on_colorscheme_changed()
                              endif
                            
                              silent doautocmd User AirlineAfterInit

FUNCTION  <SNR>21_shellslash()
Called 10 times
Total time:   0.000155
 Self time:   0.000087

count  total (s)   self (s)
   10   0.000105   0.000037   if s:winshell()
                                return s:gsub(a:path,'\\','/')
                              else
   10              0.000012     return a:path
                              endif

FUNCTION  <SNR>19_LoadFTPlugin()
Called 3 times
Total time:   0.048391
 Self time:   0.006982

count  total (s)   self (s)
    3              0.000018     if exists("b:undo_ftplugin")
    2              0.000122       exe b:undo_ftplugin
    2              0.000004       unlet! b:undo_ftplugin b:did_ftplugin
    2              0.000002     endif
                            
    3              0.000018     let s = expand("<amatch>")
    3              0.000007     if s != ""
    3              0.000034       if &cpo =~# "S" && exists("b:did_ftplugin")
                            	" In compatible mode options are reset to the global values, need to
                            	" set the local values also when a plugin was already used.
                            	unlet b:did_ftplugin
                                  endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "aaa" and then "bbb".
    6              0.000035       for name in split(s, '\.')
    3   0.048054   0.006645 	exe 'runtime! ftplugin/' . name . '.vim ftplugin/' . name . '_*.vim ftplugin/' . name . '/*.vim'
    3              0.000009       endfor
    3              0.000003     endif

FUNCTION  classpath#to_vim()
Called 1 time
Total time:   0.000719
 Self time:   0.000674

count  total (s)   self (s)
    1              0.000003   let path = []
   46   0.000104   0.000059   for elem in classpath#split(a:cp)
   45              0.000111     let path += [elem ==# '.' ? '' : elem]
   45              0.000028   endfor
    1              0.000279   if a:cp =~# '\(^\|:\)\.$'
                                let path += ['']
                              endif
    1              0.000178   return join(map(path, 'escape(v:val, ", ")'), ',')

FUNCTION  airline#check_mode()
Called 14 times
Total time:   0.051426
 Self time:   0.002123

count  total (s)   self (s)
   14              0.000070   if !exists("s:airline_run")
                                let s:airline_run = 0
                              endif
   14              0.000053   let s:airline_run += 1
                            
   14              0.000053   let context = s:contexts[a:winnr]
                            
   14              0.000058   if get(w:, 'airline_active', 1)
   12              0.000046     let l:m = mode()
   12              0.000030     if l:m ==# "i"
                                  let l:mode = ['insert']
                                elseif l:m ==# "R"
                                  let l:mode = ['replace']
                                elseif l:m =~# '\v(v|V||s|S|)'
                                  let l:mode = ['visual']
                                elseif l:m ==# "t"
                                  let l:mode = ['terminal']
                                else
   12              0.000034       let l:mode = ['normal']
   12              0.000013     endif
   12              0.000081     let w:airline_current_mode = get(g:airline_mode_map, l:m, l:m)
   12              0.000014   else
    2              0.000007     let l:mode = ['inactive']
    2              0.000016     let w:airline_current_mode = get(g:airline_mode_map, '__')
    2              0.000003   endif
                            
   14              0.000074   if g:airline_detect_modified && &modified
                                call add(l:mode, 'modified')
                              endif
                            
   14              0.000035   if g:airline_detect_paste && &paste
                                call add(l:mode, 'paste')
                              endif
                            
   14              0.000112   if g:airline_detect_crypt && exists("+key") && !empty(&key)
                                call add(l:mode, 'crypt')
                              endif
                            
   14              0.000033   if g:airline_detect_spell && &spell
                                call add(l:mode, 'spell')
                              endif
                            
   14              0.000028   if &readonly || ! &modifiable
    8              0.000038     call add(l:mode, 'readonly')
    8              0.000009   endif
                            
   14              0.000081   let mode_string = join(l:mode)
   14              0.000031   if s:airline_run < 3
                                " skip this round.
                                " When this function is run too early after startup,
                                " it forces a redraw by vim which will remove the intro screen.
                                let w:airline_lastmode = mode_string
                                return ''
                              endif
   14              0.000075   if get(w:, 'airline_lastmode', '') != mode_string
    2   0.000465   0.000024     call airline#highlighter#highlight_modified_inactive(context.bufnr)
    2   0.048896   0.000034     call airline#highlighter#highlight(l:mode, context.bufnr)
    2              0.000015     let w:airline_lastmode = mode_string
    2              0.000002   endif
                            
   14              0.000020   return ''

FUNCTION  airline#util#append()
Called 42 times
Total time:   0.000644
 Self time:   0.000644

count  total (s)   self (s)
   42              0.000131   if a:minwidth > 0 && winwidth(0) < a:minwidth
                                return ''
                              endif
   42              0.000200   let prefix = s:spc == "\ua0" ? s:spc : s:spc.s:spc
   42              0.000175   return empty(a:text) ? '' : prefix.g:airline_left_alt_sep.s:spc.a:text

FUNCTION  <SNR>164_nvim_output_handler()
Called 1 time
Total time:   0.000037
 Self time:   0.000037

count  total (s)   self (s)
    1              0.000016     if a:event == 'stdout' || a:event == 'stderr'
    1              0.000014       let self.buf .=  join(a:data)
    1              0.000002     endif

FUNCTION  <SNR>163_session_exists()
Called 1 time
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    1              0.000006 	return exists('g:fireplace_nrepl_sessions') && len(g:fireplace_nrepl_sessions)

FUNCTION  <SNR>7_doautocmd()
Called 9 times
Total time:   0.045602
 Self time:   0.000203

count  total (s)   self (s)
    9              0.000105   if exists('#'.join(a:000, '#'))
    2   0.045427   0.000028     execute 'doautocmd' ((v:version > 703 || has('patch442')) ? '<nomodeline>' : '') join(a:000)
    2              0.000001   endif

FUNCTION  ctrlp#utils#writecache()
Called 1 time
Total time:   0.017224
 Self time:   0.017209

count  total (s)   self (s)
    1   0.000024   0.000009 	if isdirectory(ctrlp#utils#mkdir(a:0 ? a:1 : s:cache_dir))
    1              0.017188 		sil! cal writefile(a:lines, a:0 >= 2 ? a:2 : ctrlp#utils#cachefile())
    1              0.000009 	en

FUNCTION  neomake#statusline#QflistCounts()
Called 12 times
Total time:   0.000032
 Self time:   0.000032

count  total (s)   self (s)
   12              0.000025     return s:qflist_counts

FUNCTION  neomake#GetCurrentErrorMsg()
Called 3 times
Total time:   0.000260
 Self time:   0.000260

count  total (s)   self (s)
    3              0.000021     let buf = bufnr('%')
    3              0.000013     let ln = line('.')
    3              0.000010     let ln_errors = []
                            
    9              0.000037     for maker_type in ['file', 'project']
    6              0.000058         let buf_errors = get(s:current_errors[maker_type], buf, {})
    6              0.000039         let ln_errors += get(buf_errors, ln, [])
    6              0.000012     endfor
                            
    3              0.000011     if empty(ln_errors)
    3              0.000007         return ''
                                endif
                            
                                if len(ln_errors) > 1
                                    let ln_errors = copy(ln_errors)
                                    call sort(ln_errors, function('neomake#utils#sort_by_col'))
                                endif
                                let entry = ln_errors[0]
                                let r = entry.maker_name . ': ' . entry.text
                                let suffix = entry.type . (entry.nr != -1 ? entry.nr : '')
                                if !empty(suffix)
                                    let r .= ' ('.suffix.')'
                                endif
                                return r

FUNCTION  bm#all_bookmarks_by_line()
Called 2 times
Total time:   0.000019
 Self time:   0.000019

count  total (s)   self (s)
    2              0.000010   if !has_key(g:line_map, a:file)
    2              0.000007     return {}
                              endif
                              return g:line_map[a:file]

FUNCTION  atags#setup()
Called 5 times
Total time:   0.000155
 Self time:   0.000155

count  total (s)   self (s)
    5              0.000020   if !exists('g:atags_on_generate_stderr')
                                let g:atags_on_generate_stderr = 'atags#onGenerateErr'
                              endif
                            
    5              0.000015   if !exists('g:atags_on_generate_stdout')
                                let g:atags_on_generate_stdout = 'atags#onGenerateOut'
                              endif
                            
    5              0.000014   if !exists('g:atags_on_generate_exit')
                                let g:atags_on_generate_exit = 'atags#onGenerateExit'
                              endif
                            
    5              0.000012   if !exists('g:atags_quiet')
                                let g:atags_quiet = 0
                              endif
                            
    5              0.000015   if !exists('g:atags_build_commands_list')
                                let g:atags_build_commands_list = ["ctags -R -f tags.tmp","awk 'length($0) < 400' tags.tmp > tags","rm tags.tmp"]
                              endif
                            

FUNCTION  <SNR>7_glob()
Called 35 times
Total time:   0.002816
 Self time:   0.002461

count  total (s)   self (s)
   35   0.002799   0.002445   return s:lines(globpath(a:from, a:pattern))

FUNCTION  <SNR>7_lod()
Called 1 time
Total time:   0.018459
 Self time:   0.001136

count  total (s)   self (s)
    8              0.000009   for name in a:names
    7   0.000049   0.000026     call s:remove_triggers(name)
    7              0.000018     let s:loaded[name] = 1
    7              0.000005   endfor
    1   0.002171   0.000023   call s:reorg_rtp()
                            
    8              0.000406   for name in a:names
    7   0.000256   0.000061     let rtp = s:rtp(g:plugs[name])
   21              0.000046     for dir in a:types
   14   0.013939   0.000160       call s:source(rtp, dir.'/**/*.vim')
   14              0.000022     endfor
    7              0.000011     if a:0
    7   0.000736   0.000094       if !s:source(rtp, a:1) && !empty(s:glob(rtp, a:2))
                                    execute 'runtime' a:1
                                  endif
    7   0.000436   0.000049       call s:source(rtp, a:2)
    7              0.000008     endif
    7   0.000208   0.000058     call s:doautocmd('User', name)
    7              0.000008   endfor

FUNCTION  bm#all_files()
Called 2 times
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    2              0.000008   return keys(g:line_map)

FUNCTION  airline#util#exec_funcrefs()
Called 12 times
Total time:   0.011136
 Self time:   0.000860

count  total (s)   self (s)
   60              0.000114     for Fn in a:list
   60   0.010743   0.000467       let code = call(Fn, a:000)
   60              0.000089       if code != 0
   12              0.000015         return code
                                  endif
   48              0.000043     endfor
                                return 0

FUNCTION  <SNR>50_chop()
Called 1 time
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
    1              0.000010 	if len(a:mrufs) > {s:max} | cal remove(a:mrufs, {s:max}, -1) | en
    1              0.000001 	retu a:mrufs

FUNCTION  airline#extensions#neomake#get_warnings()
Called 6 times
Total time:   0.000343
 Self time:   0.000098

count  total (s)   self (s)
    6   0.000296   0.000052   let counts = s:get_counts()
    6              0.000024   let warnings = get(counts, 'W', 0)
    6              0.000016   return warnings ? s:warning_symbol.warnings : ''

FUNCTION  fugitive#buffer()
Called 2 times
Total time:   0.000078
 Self time:   0.000014

count  total (s)   self (s)
    2   0.000077   0.000013   return s:buffer(a:0 ? a:1 : '%')

FUNCTION  <SNR>21_repo_bare()
Called 1 time
Total time:   0.000014
 Self time:   0.000010

count  total (s)   self (s)
    1   0.000013   0.000008   if self.dir() =~# '/\.git$'
    1              0.000001     return 0
                              else
                                return s:configured_tree(self.git_dir) ==# ''
                              endif

FUNCTION  <SNR>123_wordcount_update()
Called 4 times
Total time:   0.000298
 Self time:   0.000298

count  total (s)   self (s)
    4              0.000023   if empty(bufname(''))
                                return
                              endif
    4              0.000122   if match(&ft, get(g:, 'airline#extensions#wordcount#filetypes')) > -1
                                let l:mode = mode()
                                if l:mode ==# 'v' || l:mode ==# 'V' || l:mode ==# 's' || l:mode ==# 'S'
                                  let b:airline_wordcount = airline#extensions#wordcount#formatters#{s:formatter}#format()
                                  let b:airline_change_tick = b:changedtick
                                else
                                  if get(b:, 'airline_wordcount_cache', '') is# '' || b:airline_wordcount_cache isnot# get(b:, 'airline_wordcount', '') || get(b:, 'airline_change_tick', 0) != b:changedtick ||  get(b:, 'airline_winwidth', 0) != winwidth(0)
                                    " cache data
                                    let b:airline_wordcount = airline#extensions#wordcount#formatters#{s:formatter}#format()
                                    let b:airline_wordcount_cache = b:airline_wordcount
                                    let b:airline_change_tick = b:changedtick
                                    let b:airline_winwidth = winwidth(0)
                                  endif
                                endif
                              endif

FUNCTION  airline#parts#filetype()
Called 6 times
Total time:   0.000048
 Self time:   0.000048

count  total (s)   self (s)
    6              0.000043   return winwidth(0) < 90 && strlen(&filetype) > 3 ? matchstr(&filetype, '...'). (&encoding is? 'utf-8' ? '…' : '>') : &filetype

FUNCTION  airline#parts#iminsert()
Called 6 times
Total time:   0.000058
 Self time:   0.000058

count  total (s)   self (s)
    6              0.000023   if g:airline_detect_iminsert && &iminsert && exists('b:keymap_name')
                                return toupper(b:keymap_name)
                              endif
    6              0.000008   return ''

FUNCTION  <SNR>126_exec_separator()
Called 64 times
Total time:   0.035279
 Self time:   0.002846

count  total (s)   self (s)
   64              0.000127   if pumvisible()
                                return
                              endif
   64   0.009645   0.000418   let l:from = airline#themes#get_highlight(a:from.a:suffix)
   64   0.009015   0.000400   let l:to = airline#themes#get_highlight(a:to.a:suffix)
   64              0.000258   let group = a:from.'_to_'.a:to.a:suffix
   64              0.000081   if a:inverse
   26              0.000120     let colors = [ l:from[1], l:to[1], l:from[3], l:to[3] ]
   26              0.000022   else
   38              0.000182     let colors = [ l:to[1], l:from[1], l:to[3], l:from[3] ]
   38              0.000032   endif
   64              0.000219   let a:dict[group] = colors
   64   0.015109   0.000519   call airline#highlighter#exec(group, colors)

FUNCTION  <SNR>3_SynSet()
Called 2 times
Total time:   0.017232
 Self time:   0.004814

count  total (s)   self (s)
                              " clear syntax for :set syntax=OFF  and any syntax name that doesn't exist
    2              0.000685   syn clear
    2              0.000019   if exists("b:current_syntax")
                                unlet b:current_syntax
                              endif
                            
    2              0.000016   let s = expand("<amatch>")
    2              0.000007   if s == "ON"
                                " :set syntax=ON
                                if &filetype == ""
                                  echohl ErrorMsg
                                  echo "filetype unknown"
                                  echohl None
                                endif
                                let s = &filetype
                              elseif s == "OFF"
                                let s = ""
                              endif
                            
    2              0.000004   if s != ""
                                " Load the syntax file(s).  When there are several, separated by dots,
                                " load each in sequence.
    4              0.000030     for name in split(s, '\.')
    2   0.016407   0.003989       exe "runtime! syntax/" . name . ".vim syntax/" . name . "/*.vim"
    2              0.000004     endfor
    2              0.000002   endif

FUNCTION  <SNR>7_rtp()
Called 62 times
Total time:   0.000922
 Self time:   0.000327

count  total (s)   self (s)
   62   0.000904   0.000310     return s:dirpath(a:spec.dir . get(a:spec, 'rtp', ''))

FUNCTION  <SNR>131_add_section()
Called 56 times
Total time:   0.004377
 Self time:   0.001790

count  total (s)   self (s)
   56              0.000299     let condition = (a:key is# "warning" || a:key is# "error") && (v:version == 704 && !has("patch1511"))
                                " i have no idea why the warning section needs special treatment, but it's
                                " needed to prevent separators from showing up
   56   0.000587   0.000294     if ((a:key == 'error' || a:key == 'warning') && empty(s:get_section(a:context.winnr, a:key)))
                                  return
                                endif
   56              0.000058     if condition
                                  call a:builder.add_raw('%(')
                                endif
   56   0.002849   0.000555     call a:builder.add_section('airline_'.a:key, s:get_section(a:context.winnr, a:key))
   56              0.000064     if condition
                                  call a:builder.add_raw('%)')
                                endif

FUNCTION  <SNR>79_syntax_match_references()
Called 1 time
Total time:   0.000693
 Self time:   0.000525

count  total (s)   self (s)
    1              0.000002 	if g:clojure_highlight_references
    1   0.000689   0.000521 		call vim_clojure_highlight#syntax_match_references(g:clojure_highlight_local_vars)
    1              0.000001 	endif

FUNCTION  <SNR>147_map()
Called 60 times
Total time:   0.004225
 Self time:   0.004225

count  total (s)   self (s)
   60              0.000169   if get(g:, 'fireplace_no_maps')
                                return
                              endif
   60              0.000525   let flags = (a:0 ? a:1 : '') . (a:rhs =~# '^<Plug>' ? '' : '<script>')
   60              0.000438   if flags =~# '<unique>' && !empty(mapcheck(a:lhs, a:mode))
    6              0.001920     return
                              endif
   54              0.000900   execute a:mode.'map <buffer>' flags a:lhs a:rhs

FUNCTION  <SNR>126_CheckDefined()
Called 168 times
Total time:   0.003273
 Self time:   0.003273

count  total (s)   self (s)
                              " Checks, whether the definition of the colors is valid and is not empty or NONE
                              " e.g. if the colors would expand to this:
                              " hi airline_c ctermfg=NONE ctermbg=NONE
                              " that means to clear that highlighting group, therefore, fallback to Normal
                              " highlighting group for the cterm values
                            
                              " This only works, if the Normal highlighting group is actually defined, so
                              " return early, if it has been cleared
  168              0.000600   if !exists("g:airline#highlighter#normal_fg_hi")
                                let g:airline#highlighter#normal_fg_hi = synIDattr(synIDtrans(hlID('Normal')), 'fg', 'cterm')
                              endif
  168              0.000512   if empty(g:airline#highlighter#normal_fg_hi) || g:airline#highlighter#normal_fg_hi < 0
  168              0.000311     return a:colors
                              endif
                            
                              for val in a:colors
                                if !empty(val) && val !=# 'NONE'
                                  return a:colors
                                endif
                              endfor
                              " this adds the bold attribute to the term argument of the :hi command,
                              " but at least this makes sure, the group will be defined
                              let fg = g:airline#highlighter#normal_fg_hi
                              let bg = synIDattr(synIDtrans(hlID('Normal')), 'bg', 'cterm')
                              if bg < 0
                                " in case there is no background color defined for Normal
                                let bg = a:colors[3]
                              endif
                              return a:colors[0:1] + [fg, bg] + [a:colors[4]]

FUNCTION  classpath#detect()
Called 2 times
Total time:  14.156340
 Self time:  14.155607

count  total (s)   self (s)
    2   0.000025   0.000015   let sep = classpath#file_separator()
                            
    2              0.000004   let buffer = a:0 ? a:1 : '%'
    2              0.000009   let default = $CLASSPATH ==# '' ? ',' : classpath#to_vim($CLASSPATH)
    2              0.000008   let root = getbufvar(buffer, 'java_root')
    2              0.000003   if root ==# ''
    1              0.000048     let root = simplify(fnamemodify(bufname(buffer), ':p:s?[\/]$??'))
    1              0.000001   endif
                            
    2              0.000014   if !isdirectory(fnamemodify(root, ':h'))
                                return default
                              endif
                            
    2              0.000003   let previous = ""
    5              0.000010   while root !=# previous
    5              0.000308     if filereadable(root . '/project.clj') && join(readfile(root . '/project.clj', '', 50), "\n") =~# '(\s*defproject'
    2              0.000006       let file = 'project.clj'
    2              0.000003       let cmd = 'lein classpath'
    2              0.000003       let pattern = "[^\n]*\\ze\n*$"
    2              0.000073       let default = join(map(['test', 'src', 'dev-resources', 'resources', 'target'.sep.'classes'], 'escape(root . sep . v:val, ", ")'), ',')
    2              0.000003       let base = ''
    2              0.000003       break
                                endif
    3              0.000020     if filereadable(root . '/pom.xml')
                                  let file = 'pom.xml'
                                  let cmd = 'mvn dependency:build-classpath'
                                  let pattern = '\%(^\|classpath:\n\)\zs[^[].\{-\}\ze\n'
                                  let base = ''
                                  for line in filter(readfile(root . '/pom.xml'), 'v:val =~# "<directory>.*</directory>"')
                                    let base .= escape(root.sep.matchstr(line, '<directory>\zs.*\ze</directory>'), ', ').','
                                  endfor
                                  if empty(base)
                                    let base = escape(root.sep.'src'.sep.'*'.sep.'*', ', ') . ','
                                  endif
                                  let default = base . default
                                  break
                                endif
    3              0.000004     let previous = root
    3              0.000009     let root = fnamemodify(root, ':h')
    3              0.000002   endwhile
                            
    2              0.000076   if !exists('cmd') || !executable(matchstr(cmd, '^\S\+'))
                                if a:0 > 1 && a:2 ==# 'keep'
                                  return ''
                                else
                                  return default
                                endif
                              endif
                            
    2              0.000057   let cache = expand(g:classpath_cache . '/') . substitute(root, '[:\/]', '%', 'g')
    2              0.000014   let disk = getftime(root . sep . file)
                            
    2              0.000487   if getftime(cache) >= disk
    1   0.000032   0.000026     return join(readfile(cache), classpath#separator())
                              else
    1              0.000001     try
    1              0.000002       if &verbose
                                    echomsg 'Determining class path with '.cmd.' ...'
                                  endif
    1              0.000006       let cd = exists('*haslocaldir') && haslocaldir() ? 'lcd ' : 'cd '
    1              0.000025       let dir = getcwd()
    1              0.000001       try
    1              0.000051         execute cd . fnameescape(root)
    1             14.136944         let out = system(cmd)
    1              0.000006       finally
    1              0.000081         execute cd . fnameescape(dir)
    1              0.000002       endtry
    1              0.000002     catch /^Vim:Interrupt/
                                  return default
                                endtry
    1              0.000542     let match = matchstr(out, pattern)
    1              0.000006     if !v:shell_error && exists('out') && out !=# ''
    1   0.000754   0.000035       let path = base . classpath#to_vim(match)
    1              0.000001     else
                                  echohl WarningMSG
                                  echomsg "Couldn't determine class path."
                                  echohl NONE
                                  echo out
                                  let path = default
                                endif
    1              0.016492     call writefile([path], cache)
    1              0.000018     return path
                              endif

FUNCTION  fugitive#detect()
Called 1 time
Total time:   0.002405
 Self time:   0.000244

count  total (s)   self (s)
    1              0.000003   if exists('b:git_dir') && (b:git_dir ==# '' || b:git_dir =~# '/$')
                                unlet b:git_dir
                              endif
    1              0.000001   if !exists('b:git_dir')
    1   0.000589   0.000011     let dir = fugitive#extract_git_dir(a:path)
    1              0.000001     if dir !=# ''
    1              0.000002       let b:git_dir = dir
    1   0.000698   0.000020       if empty(fugitive#buffer().path())
                                    silent! exe haslocaldir() ? 'lcd .' : 'cd .'
                                  endif
    1              0.000001     endif
    1              0.000001   endif
    1              0.000002   if exists('b:git_dir')
    1              0.000007     if exists('#User#FugitiveBoot')
                                  try
                                    let [save_mls, &modelines] = [&mls, 0]
                                    doautocmd User FugitiveBoot
                                  finally
                                    let &mls = save_mls
                                  endtry
                                endif
    1              0.000002     if !exists('g:fugitive_no_maps')
    1              0.000028       cnoremap <buffer> <expr> <C-R><C-G> fnameescape(<SID>recall())
    1              0.000016       nnoremap <buffer> <silent> y<C-G> :call setreg(v:register, <SID>recall())<CR>
    1              0.000001     endif
    1   0.000034   0.000004     let buffer = fugitive#buffer()
    1              0.000027     if expand('%:p') =~# '://'
                                  call buffer.setvar('&path', s:sub(buffer.getvar('&path'), '^\.%(,|$)', ''))
                                endif
    1   0.000013   0.000009     if stridx(buffer.getvar('&tags'), escape(b:git_dir, ', ')) == -1
    1              0.000015       if filereadable(b:git_dir.'/tags')
                                    call buffer.setvar('&tags', escape(b:git_dir.'/tags', ', ').','.buffer.getvar('&tags'))
                                  endif
    1              0.000011       if &filetype !=# '' && filereadable(b:git_dir.'/'.&filetype.'.tags')
                                    call buffer.setvar('&tags', escape(b:git_dir.'/'.&filetype.'.tags', ', ').','.buffer.getvar('&tags'))
                                  endif
    1              0.000001     endif
    1              0.000001     try
    1              0.000010       let [save_mls, &modelines] = [&mls, 0]
    1   0.000244   0.000009       call s:define_commands()
    1   0.000651   0.000016       doautocmd User Fugitive
    1              0.000002     finally
    1              0.000011       let &mls = save_mls
    1              0.000002     endtry
    1              0.000001   endif

FUNCTION  <SNR>125_wrap_accent()
Called 4 times
Total time:   0.000093
 Self time:   0.000077

count  total (s)   self (s)
    4              0.000013   if exists('a:part.accent')
    4   0.000054   0.000038     call airline#highlighter#add_accent(a:part.accent)
    4              0.000021     return '%#__accent_'.(a:part.accent).'#'.a:value.'%#__restore__#'
                              endif
                              return a:value

FUNCTION  16()
Called 1 time
Total time:  14.343760
 Self time:   0.005107

count  total (s)   self (s)
    1  14.343757   0.005105     exec "edit " . self.str({'format': 'Edit'})

FUNCTION  17()
Called 1 time
Total time:   0.000039
 Self time:   0.000028

count  total (s)   self (s)
    1   0.000015   0.000005     if nerdtree#runningWindows()
                                    if a:fullpath =~ '^\(\\\\\|\/\/\)'
                                        "For network shares, the 'drive' consists of the first two parts of the path, i.e. \\boxname\share
                                        let self.drive = substitute(a:fullpath, '^\(\(\\\\\|\/\/\)[^\\\/]*\(\\\|\/\)[^\\\/]*\).*', '\1', '')
                                        let self.drive = substitute(self.drive, '/', '\', "g")
                                    else
                                        let self.drive = substitute(a:fullpath, '\(^[a-zA-Z]:\).*', '\1', '')
                                    endif
                                else
    1              0.000004         let self.drive = ''
    1              0.000001     endif
                            

FUNCTION  <SNR>21_repo()
Called 18 times
Total time:   0.000653
 Self time:   0.000653

count  total (s)   self (s)
   18              0.000139   let dir = a:0 ? a:1 : (exists('b:git_dir') && b:git_dir !=# '' ? b:git_dir : fugitive#extract_git_dir(expand('%:p')))
   18              0.000037   if dir !=# ''
   18              0.000054     if has_key(s:repos, dir)
   18              0.000062       let repo = get(s:repos, dir)
   18              0.000019     else
                                  let repo = {'git_dir': dir}
                                  let s:repos[dir] = repo
                                endif
   18              0.000228     return extend(extend(repo, s:repo_prototype, 'keep'), s:abstract_prototype, 'keep')
                              endif
                              call s:throw('not a git repository: '.expand('%:p'))

FUNCTION  105()
Called 1 time
Total time:  14.394000
 Self time:   0.000037

count  total (s)   self (s)
    1  14.393999   0.000036     call self.open(a:0 ? a:1 : {})

FUNCTION  <SNR>106_GetRpcFunction()
Called 1 time
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    1              0.000002   if a:sync
    1              0.000001     return 'rpcrequest'
                              endif
                              return 'rpcnotify'

FUNCTION  <SNR>120_update_branch()
Called 6 times
Total time:   0.003310
 Self time:   0.000963

count  total (s)   self (s)
    6              0.000461   let b:airline_fname_path = get(b:, 'airline_fname_path', exists("*fnamemodify") ? fnamemodify(resolve(@%), ":p:h") : expand("%:p:h"))
   18              0.000066   for vcs in keys(s:vcs_config)
   12   0.002523   0.000177     call {s:vcs_config[vcs].update_branch}(b:airline_fname_path)
   12              0.000065     if b:buffer_vcs_config[vcs].branch != s:vcs_config[vcs].branch
    1              0.000005       let b:buffer_vcs_config[vcs].branch = s:vcs_config[vcs].branch
    1              0.000002       unlet! b:airline_head
    1              0.000001     endif
   12              0.000014   endfor

FUNCTION  22()
Called 1 time
Total time:   0.000019
 Self time:   0.000019

count  total (s)   self (s)
    1              0.000003     if empty(self.pathSegments)
                                    return ''
                                endif
    1              0.000004     let toReturn = self.pathSegments[-1]
    1              0.000002     if a:dirSlash && self.isDirectory
                                    let toReturn = toReturn . '/'
                                endif
    1              0.000002     return toReturn

FUNCTION  113()
Called 1 time
Total time:   0.000225
 Self time:   0.000007

count  total (s)   self (s)
    1   0.000222   0.000004     if a:path.equals(self.path)
    1              0.000002         return self
                                endif
                                return {}

FUNCTION  118()
Called 1 time
Total time:   0.004753
 Self time:   0.000042

count  total (s)   self (s)
    1              0.000002     try
    1   0.001652   0.000017         let path = b:NERDTree.ui.getPath(line("."))
    1              0.000003         if path ==# {}
                                        return {}
                                    endif
    1   0.003087   0.000011         return b:NERDTree.root.findNode(path)
                                catch /^NERDTree/
                                    return {}
                                endtry

FUNCTION  <SNR>164_nvim_untracked_job_handler()
Called 1 time
Total time:   0.000061
 Self time:   0.000032

count  total (s)   self (s)
    1              0.000004     if a:event == 'exit'
    1   0.000045   0.000016       call s:untracked_output(self, self.buf)
    1              0.000003       if has_key(s:untracked_jobs, self.file)
    1              0.000004         call remove(s:untracked_jobs, self.file)
    1              0.000001       endif
    1              0.000001     endif

FUNCTION  vim_clojure_highlight#syntax_match_references()
Called 1 time
Total time:   0.000017
 Self time:   0.000011

count  total (s)   self (s)
    1   0.000017   0.000010 	if !s:session_exists() | return | endif
                            
                            	try
                            		call s:require()
                            
                            		let ns = "'" . fireplace#ns()
                            		let opts = (a:0 > 0 && !a:1) ? ' :local-vars false' : ''
                            
                            		execute fireplace#evalparse("(vim-clojure-highlight/ns-syntax-command " . ns . opts . ")")
                            		let &syntax = &syntax
                            	catch /./
                            	endtry

FUNCTION  <SNR>21_buffer_spec()
Called 8 times
Total time:   0.000402
 Self time:   0.000275

count  total (s)   self (s)
    8              0.000025     let bufname = bufname(self['#'])
    8   0.000373   0.000246     return s:shellslash(bufname == '' ? '' : fnamemodify(bufname,':p'))

FUNCTION  <SNR>47_SetUpForNewFiletype()
Called 4 times
Total time:   0.000492
 Self time:   0.000492

count  total (s)   self (s)
    4              0.000015     let ft = a:filetype
                            
                                "for compound filetypes, if we don't know how to handle the full filetype
                                "then break it down and use the first part that we know how to handle
    4              0.000030     if ft =~ '\.' && !has_key(s:delimiterMap, ft)
                                    let filetypes = split(a:filetype, '\.')
                                    for i in filetypes
                                        if has_key(s:delimiterMap, i)
                                            let ft = i
                                            break
                                        endif
                                    endfor
                                endif
                            
    4              0.000011     let b:NERDSexyComMarker = ''
                            
    4              0.000016     if has_key(s:delimiterMap, ft)
    4              0.000015         let b:NERDCommenterDelims = s:delimiterMap[ft]
   20              0.000038         for i in ['left', 'leftAlt', 'right', 'rightAlt']
   16              0.000038             if !has_key(b:NERDCommenterDelims, i)
    3              0.000007                 let b:NERDCommenterDelims[i] = ''
    3              0.000002             endif
   16              0.000015         endfor
   12              0.000021         for i in ['nested', 'nestedAlt']
    8              0.000019             if !has_key(b:NERDCommenterDelims, i)
    2              0.000004                 let b:NERDCommenterDelims[i] = 0
    2              0.000001             endif
    8              0.000006         endfor
                                    " if g:NERD_<filetype>_alt_style is defined, use the alternate style
    4              0.000017         let b:NERDCommenterFirstInit = getbufvar(1,"NERDCommenterFirstInit")
    4              0.000020         if exists('g:NERDAltDelims_'.ft) && eval('g:NERDAltDelims_'.ft) && !b:NERDCommenterFirstInit
                                        call s:SwitchToAlternativeDelimiters(0)
                                        let b:NERDCommenterFirstInit = 1
                                    endif
    4              0.000003     else
                                    let b:NERDCommenterDelims = s:CreateDelimMapFromCms()
                                endif
                            

FUNCTION  33()
Called 7 times
Total time:   0.001582
 Self time:   0.000070

count  total (s)   self (s)
    7   0.001579   0.000067     return self.str() ==# a:path.str()

FUNCTION  34()
Called 1 time
Total time:   0.000483
 Self time:   0.000062

count  total (s)   self (s)
    1              0.000029     let newPath = copy(self)
                            
    1   0.000425   0.000018     call newPath.readInfoFromDisk(s:Path.AbsolutePathFor(a:path))
                            
    1              0.000002     let newPath.cachedDisplayString = ""
    1   0.000022   0.000009     let newPath.flagSet = g:NERDTreeFlagSet.New()
                            
    1              0.000002     return newPath

FUNCTION  35()
Called 29 times
Total time:   0.000573
 Self time:   0.000347

count  total (s)   self (s)
                            
   29   0.000327   0.000101     if nerdtree#runningWindows()
                                    if exists('+shellslash') && &shellslash
                                        return '/'
                                    endif
                            
                                    return '\'
                                endif
                            
   29              0.000031     return '/'

FUNCTION  36()
Called 2 times
Total time:   0.000096
 Self time:   0.000096

count  total (s)   self (s)
    2              0.000043     let tmp = resolve(a:path)
    2              0.000052     return tmp =~# '.\+/$' ? substitute(tmp, '/$', '', '') : tmp

FUNCTION  37()
Called 1 time
Total time:   0.000368
 Self time:   0.000178

count  total (s)   self (s)
    1   0.000047   0.000009     call self.extractDriveLetter(a:fullpath)
                            
    1   0.000028   0.000009     let fullpath = s:Path.WinToUnixPath(a:fullpath)
                            
    1              0.000014     if getftype(fullpath) ==# "fifo"
                                    throw "NERDTree.InvalidFiletypeError: Cant handle FIFO files: " . a:fullpath
                                endif
                            
    1              0.000028     let self.pathSegments = filter(split(fullpath, '/'), '!empty(v:val)')
                            
    1              0.000002     let self.isReadOnly = 0
    1              0.000005     if isdirectory(a:fullpath)
                                    let self.isDirectory = 1
                                elseif filereadable(a:fullpath)
    1              0.000002         let self.isDirectory = 0
    1              0.000012         let self.isReadOnly = filewritable(a:fullpath) ==# 0
    1              0.000001     else
                                    throw "NERDTree.InvalidArgumentsError: Invalid path = " . a:fullpath
                                endif
                            
    1              0.000003     let self.isExecutable = 0
    1              0.000002     if !self.isDirectory
    1              0.000012         let self.isExecutable = getfperm(a:fullpath) =~# 'x'
    1              0.000002     endif
                            
                                "grab the last part of the path (minus the trailing slash)
    1   0.000029   0.000011     let lastPathComponent = self.getLastPathComponent(0)
                            
                                "get the path to the new node with the parent dir fully resolved
    1   0.000088   0.000018     let hardPath = s:Path.Resolve(self.strTrunk()) . '/' . lastPathComponent
                            
                                "if  the last part of the path is a symlink then flag it as such
    1   0.000054   0.000010     let self.isSymLink = (s:Path.Resolve(hardPath) != hardPath)
    1              0.000001     if self.isSymLink
                                    let self.symLinkDest = s:Path.Resolve(fullpath)
                            
                                    "if the link is a dir then slap a / on the end of its dest
                                    if isdirectory(self.symLinkDest)
                            
                                        "we always wanna treat MS windows shortcuts as files for
                                        "simplicity
                                        if hardPath !~# '\.lnk$'
                            
                                            let self.symLinkDest = self.symLinkDest . '/'
                                        endif
                                    endif
                                endif

FUNCTION  ctrlp#utils#lash()
Called 3 times
Total time:   0.000015
 Self time:   0.000015

count  total (s)   self (s)
    3              0.000014 	retu &ssl || !exists('+ssl') ? '/' : '\'

FUNCTION  <SNR>126_Get()
Called 336 times
Total time:   0.002962
 Self time:   0.002962

count  total (s)   self (s)
  336              0.001117   let res=get(a:dict, a:key, '')
  336              0.000636   if res is ''
  163              0.000173     return ''
                              else
  173              0.000427     return a:prefix. res
                              endif

FUNCTION  ctrlp#mrufiles#cachefile()
Called 1 time
Total time:   0.000664
 Self time:   0.000411

count  total (s)   self (s)
    1              0.000003 	if !exists('s:cadir') || !exists('s:cafile')
    1   0.000651   0.000402 		let s:cadir = ctrlp#utils#cachedir().ctrlp#utils#lash().'mru'
    1   0.000007   0.000004 		let s:cafile = s:cadir.ctrlp#utils#lash().'cache.txt'
    1              0.000001 	en
    1              0.000001 	retu s:cafile

FUNCTION  122()
Called 1 time
Total time:  14.393963
 Self time:   0.000029

count  total (s)   self (s)
    1              0.000003     let opts = a:0 ? a:1 : {}
    1   0.000094   0.000015     let opener = g:NERDTreeOpener.New(self.path, opts)
    1  14.393866   0.000010     call opener.open(self)

FUNCTION  nerdtree#checkForBrowse()
Called 1 time
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
    1              0.000009     if !isdirectory(a:dir)
    1              0.000002         return
                                endif
                            
                                if s:reuseWin(a:dir)
                                    return
                                endif
                            
                                call g:NERDTreeCreator.CreateWindowTree(a:dir)

FUNCTION  41()
Called 31 times
Total time:   0.003352
 Self time:   0.001559

count  total (s)   self (s)
   31              0.000086     let options = a:0 ? a:1 : {}
   31              0.000052     let toReturn = ""
                            
   31              0.000073     if has_key(options, 'format')
    2              0.000005         let format = options['format']
    2              0.000007         if has_key(self, '_strFor' . format)
    2   0.000048   0.000023             exec 'let toReturn = self._strFor' . format . '()'
    2              0.000001         else
                                        throw 'NERDTree.UnknownFormatError: unknown format "'. format .'"'
                                    endif
    2              0.000001     else
   29   0.001619   0.000155         let toReturn = self._str()
   29              0.000031     endif
                            
   31   0.000247   0.000132     if nerdtree#has_opt(options, 'escape')
                                    let toReturn = shellescape(toReturn)
                                endif
                            
   31              0.000065     if has_key(options, 'truncateTo')
                                    let limit = options['truncateTo']
                                    if len(toReturn) > limit-1
                                        let toReturn = toReturn[(len(toReturn)-limit+1):]
                                        if len(split(toReturn, '/')) > 1
                                            let toReturn = '</' . join(split(toReturn, '/')[1:], '/') . '/'
                                        else
                                            let toReturn = '<' . toReturn
                                        endif
                                    endif
                                endif
                            
   31              0.000047     return toReturn

FUNCTION  42()
Called 1 time
Total time:   0.000025
 Self time:   0.000025

count  total (s)   self (s)
    1              0.000012     let toReturn = '/' . join(self.pathSegments, '/')
    1              0.000004     if self.isDirectory && toReturn != '/'
    1              0.000003         let toReturn  = toReturn . '/'
    1              0.000001     endif
    1              0.000002     return toReturn

FUNCTION  44()
Called 1 time
Total time:   0.000144
 Self time:   0.000052

count  total (s)   self (s)
                            
                                " Make the path relative to the current working directory, if possible.
    1   0.000115   0.000030     let l:result = fnamemodify(self.str(), ':.')
                            
                                " On Windows, the drive letter may be removed by "fnamemodify()".  Add it
                                " back, if necessary.
    1   0.000011   0.000005     if nerdtree#runningWindows() && l:result[0] == s:Path.Slash()
                                    let l:result = self.drive . l:result
                                endif
                            
    1              0.000007     let l:result = fnameescape(l:result)
                            
    1              0.000001     if empty(l:result)
                                    let l:result = '.'
                                endif
                            
    1              0.000001     return l:result

FUNCTION  46()
Called 29 times
Total time:   0.001465
 Self time:   0.000678

count  total (s)   self (s)
   29   0.000714   0.000141     let l:separator = s:Path.Slash()
   29              0.000061     let l:leader = l:separator
                            
   29   0.000313   0.000099     if nerdtree#runningWindows()
                                    let l:leader = self.drive . l:separator
                                endif
                            
   29              0.000243     return l:leader . join(self.pathSegments, l:separator)

FUNCTION  47()
Called 1 time
Total time:   0.000019
 Self time:   0.000019

count  total (s)   self (s)
    1              0.000018     return self.drive . '/' . join(self.pathSegments[0:-2], '/')

FUNCTION  48()
Called 1 time
Total time:   0.000148
 Self time:   0.000067

count  total (s)   self (s)
    1   0.000085   0.000004     let str = self.str()
    2              0.000005     for t in range(tabpagenr('$'))
    3              0.000005         for b in tabpagebuflist(t+1)
    2              0.000035             if str == expand('#' . b . ':p')
                                            return t+1
                                        endif
    2              0.000002         endfor
    1              0.000001     endfor
    1              0.000001     return 0

FUNCTION  49()
Called 1 time
Total time:   0.000018
 Self time:   0.000008

count  total (s)   self (s)
    1   0.000015   0.000005     if !nerdtree#runningWindows()
    1              0.000002         return a:pathstr
                                endif
                            
                                let toReturn = a:pathstr
                            
                                "remove the x:\ of the front
                                let toReturn = substitute(toReturn, '^.*:\(\\\|/\)\?', '/', "")
                            
                                "remove the \\ network share from the front
                                let toReturn = substitute(toReturn, '^\(\\\\\|\/\/\)[^\\\/]*\(\\\|\/\)[^\\\/]*\(\\\|\/\)\?', '/', "")
                            
                                "convert all \ chars to /
                                let toReturn = substitute(toReturn, '\', '/', "g")
                            
                                return toReturn

FUNCTION  <SNR>50_mergelists()
Called 1 time
Total time:   0.001788
 Self time:   0.000394

count  total (s)   self (s)
    1   0.001399   0.000018 	let diskmrufs = ctrlp#utils#readfile(ctrlp#mrufiles#cachefile())
    1              0.000308 	cal filter(diskmrufs, 'index(s:mrufs, v:val) < 0')
    1              0.000055 	let mrufs = s:mrufs + diskmrufs
    1   0.000025   0.000012 	retu s:chop(mrufs)

FUNCTION  139()
Called 6 times
Total time:   0.006340
 Self time:   0.000597

count  total (s)   self (s)
    6   0.001397   0.000033     if a:path.equals(self.path)
                                    return self
                                endif
    6   0.001328   0.000068     if stridx(a:path.str(), self.path.str(), 0) ==# -1
    3              0.000005         return {}
                                endif
                            
    3              0.000005     if self.path.isDirectory
    6              0.000015         for i in self.children
    6   0.000257   0.000032             let retVal = i.findNode(a:path)
    6              0.000013             if retVal != {}
    3              0.000004                 return retVal
                                        endif
    3              0.000003         endfor
                                endif
                                return {}

FUNCTION  ctrlp#utils#readfile()
Called 1 time
Total time:   0.000717
 Self time:   0.000717

count  total (s)   self (s)
    1              0.000056 	if filereadable(a:file)
    1              0.000648 		let data = readfile(a:file)
    1              0.000006 		if empty(data) || type(data) != 3
                            			unl data
                            			let data = []
                            		en
    1              0.000001 		retu data
                            	en
                            	retu []

FUNCTION  <SNR>136_clear_cache()
Called 1 time
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    1              0.000003     if has_key(s:cache, a:bufnr)
                                    unlet s:cache[a:bufnr]
                                endif

FUNCTION  <SNR>7_loaded_names()
Called 1 time
Total time:   0.000104
 Self time:   0.000104

count  total (s)   self (s)
    1              0.000103   return filter(copy(g:plugs_order), 'get(s:loaded, v:val, 0)')

FUNCTION  <SNR>78_bookmark_save_file()
Called 1 time
Total time:   0.000045
 Self time:   0.000030

count  total (s)   self (s)
                              " Managing bookmarks per buffer implies saving them to a location based on the
                              " open file (working dir doesn't make much sense unless auto changing the
                              " working directory based on current file location is turned on - but this is
                              " a serious dependency to try and require), so the function used to customize
                              " the bookmarks file location must be based on the current file.
                              " For backwards compatibility reasons, a new function is used.
    1              0.000003   if (g:bookmark_manage_per_buffer ==# 1)
                                return exists("*g:BMBufferFileLocation") ? g:BMBufferFileLocation(a:file) : s:default_file_location()
                              elseif (g:bookmark_save_per_working_dir)
    1   0.000030   0.000015     return exists("*g:BMWorkDirFileLocation") ? g:BMWorkDirFileLocation() : s:default_file_location()
                              else
                                return g:bookmark_auto_save_file
                              endif

FUNCTION  provider#pythonx#Detect()
Called 1 time
Total time:   0.000016
 Self time:   0.000016

count  total (s)   self (s)
    1              0.000002   if a:major_ver == 2
                                if exists('g:python_host_prog')
                                  return [g:python_host_prog, '']
                                else
                                  let progs = ['python2', 'python2.7', 'python2.6', 'python']
                                endif
                              else
    1              0.000003     if exists('g:python3_host_prog')
    1              0.000002       return [g:python3_host_prog, '']
                                else
                                  let progs = ['python3', 'python3.7', 'python3.6', 'python3.5', 'python3.4', 'python3.3', 'python']
                                endif
                              endif
                            
                              let errors = []
                            
                              for prog in progs
                                let [result, err] = s:check_interpreter(prog, a:major_ver)
                                if result
                                  return [prog, err]
                                endif
                                " Accumulate errors in case we don't find
                                " any suitable Python interpreter.
                                call add(errors, err)
                              endfor
                            
                              " No suitable Python interpreter found.
                              return ['', 'provider/pythonx: Could not load Python ' . a:major_ver . ":\n" .  join(errors, "\n")]

FUNCTION  <SNR>155_MakeWindowId()
Called 1 time
Total time:   0.000023
 Self time:   0.000023

count  total (s)   self (s)
    1              0.000009     if g:slimv_repl_split && !exists('w:id')
    1              0.000004         let s:win_id = s:win_id + 1
    1              0.000006         let w:id = s:win_id
    1              0.000001     endif

FUNCTION  <SNR>120_format_name()
Called 2 times
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    2              0.000005     return a:name

FUNCTION  airline#section#create()
Called 4 times
Total time:   0.000906
 Self time:   0.000040

count  total (s)   self (s)
    4   0.000904   0.000038   return s:create(a:parts, 0)

FUNCTION  airline#extensions#default#apply()
Called 12 times
Total time:   0.006734
 Self time:   0.000665

count  total (s)   self (s)
   12              0.000031   let winnr = a:context.winnr
   12              0.000023   let active = a:context.active
                            
   12   0.000141   0.000084   if airline#util#getwinvar(winnr, 'airline_render_left', active || (!active && !g:airline_inactive_collapse))
   10   0.002780   0.000080     call s:build_sections(a:builder, a:context, s:layout[0])
   10              0.000009   else
    2   0.000107   0.000015     let text = s:get_section(winnr, 'c')
    2              0.000004     if empty(text)
                                  let text = ' %f%m '
                                endif
    2   0.000024   0.000014     call a:builder.add_section('airline_c'.(a:context.bufnr), text)
    2              0.000002   endif
                            
   12   0.000656   0.000117   call a:builder.split(s:get_section(winnr, 'gutter', '', ''))
                            
   12   0.000091   0.000052   if airline#util#getwinvar(winnr, 'airline_render_right', 1)
    6   0.002674   0.000042     call s:build_sections(a:builder, a:context, s:layout[1])
    6              0.000005   endif
                            
   12              0.000012   return 1

FUNCTION  71()
Called 1 time
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
    1              0.000003     if !exists("s:keyMaps")
                                    let s:keyMaps = []
                                endif
    1              0.000002     return s:keyMaps

FUNCTION  72()
Called 1 time
Total time:   0.000077
 Self time:   0.000069

count  total (s)   self (s)
    8   0.000026   0.000017     for i in s:KeyMap.All()
    8              0.000025          if i.key ==# a:key && i.scope ==# a:scope
    1              0.000001             return i
                                    endif
    7              0.000007     endfor
                                return {}

FUNCTION  76()
Called 1 time
Total time:  14.394059
 Self time:   0.000039

count  total (s)   self (s)
    1              0.000008     let Callback = function(self.callback)
    1              0.000001     if a:0
    1  14.394040   0.000020         call Callback(a:1)
    1              0.000002     else
                                    call Callback()
                                endif

FUNCTION  77()
Called 1 time
Total time:  14.399006
 Self time:   0.000108

count  total (s)   self (s)
                            
                                "required because clicking the command window below another window still
                                "invokes the <LeftRelease> mapping - but changes the window cursor
                                "is in first
                                "
                                "TODO: remove this check when the vim bug is fixed
    1   0.000022   0.000013     if !g:NERDTree.ExistsForBuf()
                                    return {}
                                endif
                            
    1   0.004798   0.000045     let node = g:NERDTreeFileNode.GetSelected()
    1              0.000003     if !empty(node)
                            
                                    "try file node
    1              0.000002         if !node.path.isDirectory
    1   0.000089   0.000012             let km = s:KeyMap.FindFor(a:key, "FileNode")
    1              0.000002             if !empty(km)
    1  14.394075   0.000016                 return km.invoke(node)
                                        endif
                                    endif
                            
                                    "try dir node
                                    if node.path.isDirectory
                                        let km = s:KeyMap.FindFor(a:key, "DirNode")
                                        if !empty(km)
                                            return km.invoke(node)
                                        endif
                                    endif
                            
                                    "try generic node
                                    let km = s:KeyMap.FindFor(a:key, "Node")
                                    if !empty(km)
                                        return km.invoke(node)
                                    endif
                            
                                endif
                            
                                "try bookmark
                                let bm = g:NERDTreeBookmark.GetSelected()
                                if !empty(bm)
                                    let km = s:KeyMap.FindFor(a:key, "Bookmark")
                                    if !empty(km)
                                        return km.invoke(bm)
                                    endif
                                endif
                            
                                "try all
                                let km = s:KeyMap.FindFor(a:key, "all")
                                if !empty(km)
                                    return km.invoke()
                                endif

FUNCTION  bm#location_list()
Called 1 time
Total time:   0.000041
 Self time:   0.000034

count  total (s)   self (s)
    1   0.000018   0.000011   let files = sort(bm#all_files())
    1              0.000001   let locations = []
    1              0.000003   for file in files
                                let line_nrs = sort(bm#all_lines(file), "bm#compare_lines")
                                for line_nr in line_nrs
                                  let bookmark = bm#get_bookmark_by_line(file, line_nr)
                                  let content = bookmark['annotation'] !=# '' ? "Annotation: ". bookmark['annotation'] : (bookmark['content'] !=# ""   ? bookmark['content']   : "empty line")
                                  call add(locations, file .":". line_nr .":". content)
                                endfor
                              endfor
    1              0.000001   return locations

FUNCTION  <SNR>74_activateFileNode()
Called 1 time
Total time:  14.394020
 Self time:   0.000020

count  total (s)   self (s)
    1  14.394019   0.000019     call a:node.activate({'reuse': 'all', 'where': 'p'})

FUNCTION  168()
Called 2 times
Total time:   0.000024
 Self time:   0.000019

count  total (s)   self (s)
    2              0.000002     if self._keepopen
                                    return
                                endif
                            
    2              0.000004     if (a:newtab && self._where == 't') || !a:newtab
    1   0.000010   0.000005         call g:NERDTree.CloseIfQuitOnOpen()
    1              0.000001     endif

FUNCTION  airline#highlighter#add_separator()
Called 46 times
Total time:   0.025057
 Self time:   0.000854

count  total (s)   self (s)
   46              0.000331   let s:separators[a:from.a:to] = [a:from, a:to, a:inverse]
   46   0.024697   0.000494   call <sid>exec_separator({}, a:from, a:to, a:inverse, '')

FUNCTION  <SNR>130_get_prev_group()
Called 70 times
Total time:   0.000922
 Self time:   0.000922

count  total (s)   self (s)
   70              0.000139   let x = a:i - 1
   76              0.000125   while x >= 0
   64              0.000153     let group = a:sections[x][0]
   64              0.000166     if group != '' && group != '|'
   58              0.000080       return group
                                endif
    6              0.000009     let x = x - 1
    6              0.000006   endwhile
   12              0.000013   return ''

FUNCTION  <SNR>164_untracked_output()
Called 1 time
Total time:   0.000029
 Self time:   0.000029

count  total (s)   self (s)
    1              0.000013   if a:buf =~? ('^'. a:dict.cfg['untracked_mark'])
    1              0.000010     let a:dict.cfg.untracked[a:dict.file] = get(g:, 'airline#extensions#branch#notexists', g:airline_symbols.notexists)
    1              0.000001   else
                                let a:dict.cfg.untracked[a:dict.file] = ''
                              endif

FUNCTION  <SNR>125_create()
Called 4 times
Total time:   0.000865
 Self time:   0.000753

count  total (s)   self (s)
    4              0.000008   let _ = ''
    8              0.000024   for idx in range(len(a:parts))
    4   0.000050   0.000030     let part = airline#parts#get(a:parts[idx])
    4              0.000007     let val = ''
    4              0.000013     let add_sep = get(l:, 'add_sep', 0)
                            
    4              0.000013     if exists('part.function')
    4              0.000012       let func = (part.function).'()'
    4              0.000007     elseif exists('part.text')
                                  let func = '"'.(part.text).'"'
                                else
                                  if a:append > 0 && idx != 0
                                    let val .= s:spc.g:airline_left_alt_sep.s:spc
                                  endif
                                  if a:append < 0 && idx != 0
                                    let t = ''
                                    if !add_sep
                                      let t = s:spc.g:airline_right_alt_sep.s:spc
                                    endif
                                    let val = t.val
                                  endif
                                  if exists('part.raw')
                                    let _ .= s:wrap_accent(part, val.(part.raw))
                                    continue
                                  else
                                    let _ .= s:wrap_accent(part, val.a:parts[idx])
                                    continue
                                  endif
                                endif
                            
    4              0.000014     let minwidth = get(part, 'minwidth', 0)
                            
    4              0.000008     if a:append > 0 && idx != 0
                                  let partval = printf('%%{airline#util#append(%s,%s)}', func, minwidth)
                                  " will add an extra separator, if minwidth is zero
                                  let add_sep = (minwidth == 0)
                                elseif a:append < 0 && idx != len(a:parts) - 1
                                  let partval = printf('%%{airline#util#prepend(%s,%s)}', func, minwidth)
                                  " will add an extra separator, if minwidth is zero
                                  let add_sep = (minwidth == 0)
                                else
    4              0.000024       let partval = printf('%%{airline#util#wrap(%s,%s)}', func, minwidth)
    4              0.000007       let add_sep = 0
    4              0.000003     endif
                            
    4              0.000011     if exists('part.condition')
                                  let partval = substitute(partval, '{', '\="{".(part.condition)." ? "', '')
                                  let partval = substitute(partval, '}', ' : ""}', '')
                                endif
                            
    4   0.000128   0.000035     let val .= s:wrap_accent(part, partval)
    4              0.000013     let _ .= val
    4              0.000004   endfor
    4              0.000007   return _

FUNCTION  remote#host#IsRunning()
Called 1 time
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    1              0.000002   if !has_key(s:hosts, a:name)
                                throw 'No host named "'.a:name.'" is registered'
                              endif
    1              0.000002   return s:hosts[a:name].channel != 0

FUNCTION  SlimvGetFiletype()
Called 2 times
Total time:   0.000021
 Self time:   0.000021

count  total (s)   self (s)
    2              0.000011     if &ft != ''
                                    " Return Vim filetype if defined
    2              0.000005         return &ft
                                endif
                            
                                if match( tolower( g:slimv_lisp ), 'clojure' ) >= 0 || match( tolower( g:slimv_lisp ), 'clj' ) >= 0
                                    " Must be Clojure
                                    return 'clojure'
                                endif
                            
                                " We have no clue, guess its lisp
                                return 'lisp'

FUNCTION  airline#util#wrap()
Called 56 times
Total time:   0.000452
 Self time:   0.000452

count  total (s)   self (s)
   56              0.000185   if a:minwidth > 0 && winwidth(0) < a:minwidth
                                return ''
                              endif
   56              0.000089   return a:text

FUNCTION  170()
Called 1 time
Total time:   0.049585
 Self time:   0.000038

count  total (s)   self (s)
    1   0.000007   0.000005     if b:NERDTree.isWinTree()
                                    if self._where == 'v'
                                        vsplit
                                    elseif self._where == 'h'
                                        split
                                    elseif self._where == 't'
                                        tabnew
                                    endif
                                else
    1   0.000012   0.000004         call self._checkToCloseTree(1)
                            
    1              0.000001         if self._where == 'v'
                                        call self._newVSplit()
                                    elseif self._where == 'h'
                                        call self._newSplit()
                                    elseif self._where == 't'
                                        tabnew
                                    elseif self._where == 'p'
    1   0.049526   0.000005             call self._previousWindow()
    1              0.000001         endif
                            
    1   0.000021   0.000005         call self._checkToCloseTree(0)
    1              0.000001     endif

FUNCTION  171()
Called 2 times
Total time:   0.040055
 Self time:   0.000102

count  total (s)   self (s)
                                "gotta split if theres only one window (i.e. the NERD tree)
    2              0.000005     if winnr("$") ==# 1
                                    return 0
                                endif
                            
    2              0.000005     let oldwinnr = winnr()
    2   0.022337   0.000019     call nerdtree#exec(a:winnumber . "wincmd p")
    2              0.000020     let specialWindow = getbufvar("%", '&buftype') != '' || getwinvar('%', '&previewwindow')
    2              0.000006     let modified = &modified
    2   0.017654   0.000020     call nerdtree#exec(oldwinnr . "wincmd p")
                            
                                "if its a special window e.g. quickfix or another explorer plugin then we
                                "have to split
    2              0.000004     if specialWindow
                                    return 0
                                endif
                            
    2              0.000002     if &hidden
    2              0.000002         return 1
                                endif
                            
                                return !modified || self._bufInWindows(winbufnr(a:winnumber)) >= 2

FUNCTION  172()
Called 1 time
Total time:   0.000079
 Self time:   0.000062

count  total (s)   self (s)
    1              0.000016     let newObj = copy(self)
                            
    1              0.000003     let newObj._path = a:path
    1   0.000011   0.000006     let newObj._stay = nerdtree#has_opt(a:opts, 'stay')
                            
    1              0.000003     if has_key(a:opts, 'reuse')
    1              0.000003         let newObj._reuse = a:opts['reuse']
    1              0.000001     else
                                    let newObj._reuse = ''
                                endif
                            
    1   0.000010   0.000006     let newObj._keepopen = nerdtree#has_opt(a:opts, 'keepopen')
    1              0.000005     let newObj._where = has_key(a:opts, 'where') ? a:opts['where'] : ''
    1              0.000003     let newObj._nerdtree = b:NERDTree
    1   0.000014   0.000007     call newObj._saveCursorPos()
                            
    1              0.000002     return newObj

FUNCTION  175()
Called 1 time
Total time:  14.393856
 Self time:   0.000019

count  total (s)   self (s)
    1              0.000002     if self._path.isDirectory
                                    call self._openDirectory(a:target)
                                else
    1  14.393846   0.000009         call self._openFile()
    1              0.000001     endif

FUNCTION  176()
Called 1 time
Total time:  14.393837
 Self time:   0.000046

count  total (s)   self (s)
    1   0.000452   0.000006     if self._reuseWindow()
                                    return
                                endif
                            
    1   0.049592   0.000007     call self._gotoTargetWin()
    1  14.343781   0.000021     call self._path.edit()
    1              0.000003     if self._stay
                                    call self._restoreCursorPos()
                                endif

FUNCTION  178()
Called 1 time
Total time:   0.049521
 Self time:   0.000049

count  total (s)   self (s)
    1   0.022351   0.000012     if !self._isWindowUsable(winnr("#")) && self._firstUsableWindow() ==# -1
                                    call self._newSplit()
                                else
    1              0.000002         try
    1   0.017727   0.000011             if !self._isWindowUsable(winnr("#"))
                                            call nerdtree#exec(self._firstUsableWindow() . "wincmd w")
                                        else
    1   0.009422   0.000005                 call nerdtree#exec('wincmd p')
    1              0.000001             endif
    1              0.000001         catch /^Vim\%((\a\+)\)\=:E37/
                                        call g:NERDTree.CursorToTreeWin()
                                        throw "NERDTree.FileAlreadyOpenAndModifiedError: ". self._path.str() ." is already open and modified."
                                    catch /^Vim\%((\a\+)\)\=:/
                                        echo v:exception
                                    endtry
    1              0.000001     endif

FUNCTION  <SNR>78_default_file_location()
Called 1 time
Total time:   0.000016
 Self time:   0.000016

count  total (s)   self (s)
    1              0.000015   return getcwd(). '/.vim-bookmarks'

FUNCTION  <SNR>51_on_window_changed()
Called 9 times
Total time:   0.064091
 Self time:   0.000361

count  total (s)   self (s)
    9              0.000028   if pumvisible() && (!&previewwindow || g:airline_exclude_preview)
                                return
                              endif
                              " Handle each window only once, since we might come here several times for
                              " different autocommands.
    9              0.000084   let l:key = [bufnr('%'), winnr(), winnr('$'), tabpagenr(), &ft]
    9              0.000083   if get(g:, 'airline_last_window_changed', []) == l:key && &stl is# '%!airline#statusline('.winnr().')' && &ft !~? 'gitcommit'
                                " fugitive is special, it changes names and filetypes several times,
                                " make sure the caching does not get into its way
    3              0.000003     return
                              endif
    6              0.000032   let g:airline_last_window_changed = l:key
    6   0.000056   0.000034   call s:init()
    6   0.063746   0.000038   call airline#update_statusline()

FUNCTION  bm#total_count()
Called 1 time
Total time:   0.000052
 Self time:   0.000011

count  total (s)   self (s)
    1   0.000051   0.000010   return len(bm#location_list())

FUNCTION  180()
Called 1 time
Total time:   0.000446
 Self time:   0.000177

count  total (s)   self (s)
    1              0.000003     if empty(self._reuse)
                                    return 0
                                endif
                            
                                "check the current tab for the window
    1   0.000259   0.000138     let winnr = bufwinnr('^' . self._path.str() . '$')
    1              0.000002     if winnr != -1
                                    call nerdtree#exec(winnr . "wincmd w")
                                    call self._checkToCloseTree(0)
                                    return 1
                                endif
                            
    1              0.000002     if self._reuse == 'currenttab'
                                    return 0
                                endif
                            
                                "check other tabs
    1   0.000157   0.000009     let tabnr = self._path.tabnr()
    1              0.000001     if tabnr
                                    call self._checkToCloseTree(1)
                                    call nerdtree#exec('normal! ' . tabnr . 'gt')
                                    let winnr = bufwinnr('^' . self._path.str() . '$')
                                    call nerdtree#exec(winnr . "wincmd w")
                                    return 1
                                endif
                            
    1              0.000001     return 0

FUNCTION  181()
Called 1 time
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
    1              0.000004     let self._bufnr = bufnr("")
    1              0.000003     let self._tabnr = tabpagenr()

FUNCTION  <SNR>7_reorg_rtp()
Called 1 time
Total time:   0.002148
 Self time:   0.001318

count  total (s)   self (s)
    1              0.000002   if !empty(s:first_rtp)
    1              0.000014     execute 'set rtp-='.s:first_rtp
    1              0.000012     execute 'set rtp-='.s:last_rtp
    1              0.000001   endif
                            
                              " &rtp is modified from outside
    1              0.000006   if exists('s:prtp') && s:prtp !=# &rtp
                                call s:remove_rtp()
                                unlet! s:middle
                              endif
                            
    1              0.000005   let s:middle = get(s:, 'middle', &rtp)
    1   0.000995   0.000165   let rtps     = map(s:loaded_names(), 's:rtp(g:plugs[v:val])')
    1              0.000822   let afters   = filter(map(copy(rtps), 'globpath(v:val, "after")'), '!empty(v:val)')
    1              0.000155   let rtp      = join(map(rtps, 'escape(v:val, ",")'), ',') . ','.s:middle.',' . join(map(afters, 'escape(v:val, ",")'), ',')
    1              0.000084   let &rtp     = substitute(substitute(rtp, ',,*', ',', 'g'), '^,\|,$', '', 'g')
    1              0.000003   let s:prtp   = &rtp
                            
    1              0.000003   if !empty(s:first_rtp)
    1              0.000022     execute 'set rtp^='.s:first_rtp
    1              0.000013     execute 'set rtp+='.s:last_rtp
    1              0.000001   endif

FUNCTION  airline#extensions#apply_left_override()
Called 4 times
Total time:   0.000987
 Self time:   0.000081

count  total (s)   self (s)
    4              0.000013   let w:airline_section_a = a:section1
    4              0.000009   let w:airline_section_b = a:section2
    4   0.000942   0.000036   let w:airline_section_c = airline#section#create(['readonly'])
    4              0.000009   let w:airline_render_left = 1
    4              0.000008   let w:airline_render_right = 0

FUNCTION  airline#extensions#whitespace#check()
Called 6 times
Total time:   0.001361
 Self time:   0.001026

count  total (s)   self (s)
    6              0.000032   let max_lines = get(g:, 'airline#extensions#whitespace#max_lines', 20000)
    6              0.000050   if &readonly || !&modifiable || !s:enabled || line('$') > max_lines || get(b:, 'airline_whitespace_disabled', 0)
                                return ''
                              endif
                            
    6              0.000024   if !exists('b:airline_whitespace_check')
    1              0.000003     let b:airline_whitespace_check = ''
    1              0.000007     let checks = get(b:, 'airline_whitespace_checks', get(g:, 'airline#extensions#whitespace#checks', s:default_checks))
                            
    1              0.000002     let trailing = 0
    1              0.000004     if index(checks, 'trailing') > -1
    1              0.000002       try
    1              0.000005         let regexp = get(g:, 'airline#extensions#whitespace#trailing_regexp', '\s$')
    1              0.000038         let trailing = search(regexp, 'nw')
    1              0.000002       catch
                                    echomsg 'airline#whitespace: error occured evaluating '. regexp
                                    echomsg v:exception
                                    return ''
                                  endtry
    1              0.000001     endif
                            
    1              0.000002     let mixed = 0
    1              0.000002     let check = 'indent'
    1              0.000014     if index(checks, check) > -1 && index(get(s:skip_check_ft, &ft, []), check) < 0
    1   0.000098   0.000016       let mixed = s:check_mixed_indent()
    1              0.000002     endif
                            
    1              0.000003     let mixed_file = ''
    1              0.000003     let check = 'mixed-indent-file'
    1              0.000011     if index(checks, check) > -1 && index(get(s:skip_check_ft, &ft, []), check) < 0
    1   0.000081   0.000019       let mixed_file = s:check_mixed_indent_file()
    1              0.000001     endif
                            
    1              0.000002     let long = 0
    1              0.000004     if index(checks, 'long') > -1 && &tw > 0
                                  let long = search('\%>'.&tw.'v.\+', 'nw')
                                endif
                            
    1              0.000005     if trailing != 0 || mixed != 0 || long != 0 || !empty(mixed_file)
                                  let b:airline_whitespace_check = s:symbol
                                  if strlen(s:symbol) > 0
                                    let space = (g:airline_symbols.space)
                                  else
                                    let space = ''
                                  endif
                            
                                  if s:show_message
                                    if trailing != 0
                                      let trailing_fmt = get(g:, 'airline#extensions#whitespace#trailing_format', '[%s]trailing')
                                      let b:airline_whitespace_check .= space.printf(trailing_fmt, trailing)
                                    endif
                                    if mixed != 0
                                      let mixed_indent_fmt = get(g:, 'airline#extensions#whitespace#mixed_indent_format', '[%s]mixed-indent')
                                      let b:airline_whitespace_check .= space.printf(mixed_indent_fmt, mixed)
                                    endif
                                    if long != 0
                                      let long_fmt = get(g:, 'airline#extensions#whitespace#long_format', '[%s]long')
                                      let b:airline_whitespace_check .= space.printf(long_fmt, long)
                                    endif
                                    if !empty(mixed_file)
                                      let mixed_indent_file_fmt = get(g:, 'airline#extensions#whitespace#mixed_indent_file_format', '[%s]mix-indent-file')
                                      let b:airline_whitespace_check .= space.printf(mixed_indent_file_fmt, mixed_file)
                                    endif
                                  endif
                                endif
    1              0.000001   endif
    6   0.000240   0.000050   return airline#util#shorten(b:airline_whitespace_check, 120, 9)

FUNCTION  airline#async#nvim_vcs_untracked()
Called 8 times
Total time:   0.002678
 Self time:   0.002450

count  total (s)   self (s)
    8              0.000081   let cmd = a:cfg.cmd . shellescape(a:file)
    8              0.000019   let id = -1
    8   0.000460   0.000231   let config = { 'buf': '', 'vcs': a:vcs, 'cfg': a:cfg, 'file': a:file, 'cwd': s:valid_dir(fnamemodify(a:file, ':p:h')) }
    8              0.000038   if has("nvim")
    8              0.000213     call extend(config, { 'on_stdout': function('s:nvim_output_handler'), 'on_exit': function('s:nvim_untracked_job_handler')})
    8              0.000037     if has_key(s:untracked_jobs, config.file)
                                  " still running
    7              0.000010       return
                                endif
    1              0.001744     let id = jobstart(cmd, config)
    1              0.000016     let s:untracked_jobs[a:file] = id
    1              0.000003   endif
                              " vim without job feature or nvim jobstart failed
    1              0.000003   if id < 1
                                let output=system(cmd)
                                call s:untracked_output(config, output)
                                call airline#extensions#branch#update_untracked_config(a:file, a:vcs)
                              endif

FUNCTION  <SNR>121_check_mixed_indent()
Called 1 time
Total time:   0.000083
 Self time:   0.000083

count  total (s)   self (s)
    1              0.000006   let indent_algo = get(g:, 'airline#extensions#whitespace#mixed_indent_algo', 0)
    1              0.000002   if indent_algo == 1
                                " [<tab>]<space><tab>
                                " spaces before or between tabs are not allowed
                                let t_s_t = '(^\t* +\t\s*\S)'
                                " <tab>(<space> x count)
                                " count of spaces at the end of tabs should be less than tabstop value
                                let t_l_s = '(^\t+ {' . &ts . ',}' . '\S)'
                                return search('\v' . t_s_t . '|' . t_l_s, 'nw')
                              elseif indent_algo == 2
                                return search('\v(^\t* +\t\s*\S)', 'nw')
                              else
    1              0.000057     return search('\v(^\t+ +)|(^ +\t+)', 'nw')
                              endif

FUNCTION  <SNR>21_buffer_commit()
Called 1 time
Total time:   0.000055
 Self time:   0.000009

count  total (s)   self (s)
    1   0.000054   0.000009   return matchstr(self.spec(),'^fugitive://.\{-\}//\zs\w*')

FUNCTION  remote#define#AutocmdBootstrap()
Called 1 time
Total time:   0.000989
 Self time:   0.000316

count  total (s)   self (s)
    1   0.000029   0.000008   let channel = remote#host#Require(a:host)
                            
    1              0.000241   exe 'autocmd! '.a:opts.group
    1              0.000003   if channel
    1   0.000263   0.000023     call remote#define#AutocmdOnChannel(channel, a:method, a:sync, a:name, a:opts)
    1   0.000438   0.000025     exe eval(a:forward)
    1              0.000004   else
                                exe 'augroup! '.a:opts.group
                                echoerr 'Host "'a:host.'" for "'.a:name.'" autocmd is not available'
                              endif

FUNCTION  <SNR>164_valid_dir()
Called 8 times
Total time:   0.000229
 Self time:   0.000229

count  total (s)   self (s)
    8              0.000081   if empty(a:dir) || !isdirectory(a:dir)
                                return getcwd()
                              endif
    8              0.000018   return a:dir

FUNCTION  <SNR>7_dirpath()
Called 62 times
Total time:   0.000594
 Self time:   0.000594

count  total (s)   self (s)
   62              0.000575     return substitute(a:path, '[/\\]*$', '/', '')

FUNCTION  fugitive#extract_git_dir()
Called 1 time
Total time:   0.000579
 Self time:   0.000323

count  total (s)   self (s)
    1   0.000027   0.000010   if s:shellslash(a:path) =~# '^fugitive://.*//'
                                return matchstr(s:shellslash(a:path), '\C^fugitive://\zs.\{-\}\ze//')
                              endif
    1              0.000005   if isdirectory(a:path)
                                let path = fnamemodify(a:path, ':p:s?[\/]$??')
                              else
    1              0.000017     let path = fnamemodify(a:path, ':p:h:s?[\/]$??')
    1              0.000001   endif
    1   0.000027   0.000015   let root = s:shellslash(resolve(path))
    1              0.000001   let previous = ""
    3              0.000006   while root !=# previous
    3              0.000023     if root =~# '\v^//%([^/]+/?)?$'
                                  " This is for accessing network shares from Cygwin Vim. There won't be
                                  " any git directory called //.git or //serverName/.git so let's avoid
                                  " checking for them since such checks are extremely slow.
                                  break
                                endif
    3              0.000027     if index(split($GIT_CEILING_DIRECTORIES, ':'), root) >= 0
                                  break
                                endif
    3              0.000011     if root ==# $GIT_WORK_TREE && fugitive#is_git_dir($GIT_DIR)
                                  return simplify(fnamemodify(expand($GIT_DIR), ':p:s?[\/]$??'))
                                endif
    3   0.000118   0.000026     if fugitive#is_git_dir($GIT_DIR)
                                  " Ensure that we've cached the worktree
                                  call s:configured_tree(simplify(fnamemodify(expand($GIT_DIR), ':p:s?[\/]$??')))
                                  if has_key(s:dir_for_worktree, root)
                                    return s:dir_for_worktree[root]
                                  endif
                                endif
    3   0.000055   0.000018     let dir = s:sub(root, '[\/]$', '') . '/.git'
    3              0.000021     let type = getftype(dir)
    3   0.000041   0.000009     if type ==# 'dir' && fugitive#is_git_dir(dir)
    1              0.000001       return dir
                                elseif type ==# 'link' && fugitive#is_git_dir(dir)
                                  return resolve(dir)
                                elseif type !=# '' && filereadable(dir)
                                  let line = get(readfile(dir, '', 1), 0, '')
                                  if line =~# '^gitdir: \.' && fugitive#is_git_dir(root.'/'.line[8:-1])
                                    return simplify(root.'/'.line[8:-1])
                                  elseif line =~# '^gitdir: ' && fugitive#is_git_dir(line[8:-1])
                                    return line[8:-1]
                                  endif
                                elseif fugitive#is_git_dir(root)
                                  return root
                                endif
    2              0.000003     let previous = root
    2              0.000007     let root = fnamemodify(root, ':h')
    2              0.000002   endwhile
                              return ''

FUNCTION  fugitive#head()
Called 6 times
Total time:   0.001593
 Self time:   0.000150

count  total (s)   self (s)
    6              0.000027   if !exists('b:git_dir')
                                return ''
                              endif
                            
    6   0.001542   0.000099   return s:repo().head(a:0 ? a:1 : 0)

FUNCTION  <SNR>21_define_commands()
Called 1 time
Total time:   0.000236
 Self time:   0.000236

count  total (s)   self (s)
   28              0.000030   for command in s:commands
   27              0.000180     exe 'command! -buffer '.command
   27              0.000018   endfor

FUNCTION  <SNR>21_buffer_type()
Called 1 time
Total time:   0.000372
 Self time:   0.000172

count  total (s)   self (s)
    1   0.000006   0.000004   if self.getvar('fugitive_type') != ''
                                let type = self.getvar('fugitive_type')
                              elseif fnamemodify(self.spec(),':p') =~# '.\git/refs/\|\.git/\w*HEAD$'
                                let type = 'head'
                              elseif self.getline(1) =~ '^tree \x\{40\}$' && self.getline(2) == ''
                                let type = 'tree'
                              elseif self.getline(1) =~ '^\d\{6\} \w\{4\} \x\{40\}\>\t'
                                let type = 'tree'
                              elseif self.getline(1) =~ '^\d\{6\} \x\{40\}\> \d\t'
                                let type = 'index'
                              elseif isdirectory(self.spec())
                                let type = 'directory'
                              elseif self.spec() == ''
                                let type = 'null'
                              else
    1              0.000002     let type = 'file'
    1              0.000001   endif
    1              0.000001   if a:0
    1              0.000011     return !empty(filter(copy(a:000),'v:val ==# type'))
                              else
                                return type
                              endif

FUNCTION  ctrlp#utils#mkdir()
Called 1 time
Total time:   0.000015
 Self time:   0.000015

count  total (s)   self (s)
    1              0.000010 	if exists('*mkdir') && !isdirectory(a:dir)
                            		sil! cal mkdir(a:dir, 'p')
                            	en
    1              0.000001 	retu a:dir

FUNCTION  <SNR>115_sync_active_winnr()
Called 3 times
Total time:   0.000039
 Self time:   0.000039

count  total (s)   self (s)
    3              0.000023   if exists('#airline') && winnr() != s:active_winnr
                                call airline#update_statusline()
                              endif

FUNCTION  nerdtree#runningWindows()
Called 62 times
Total time:   0.000475
 Self time:   0.000475

count  total (s)   self (s)
   62              0.000448     return has("win16") || has("win32") || has("win64")

FUNCTION  classpath#file_separator()
Called 2 times
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    2              0.000008  return exists('shellslash') && !&shellslash ? '\' : '/'

FUNCTION  remote#host#RegisterClone()
Called 1 time
Total time:   0.000019
 Self time:   0.000019

count  total (s)   self (s)
    1              0.000004   if !has_key(s:hosts, a:orig_name)
                                throw 'No host named "'.a:orig_name.'" is registered'
                              endif
    1              0.000004   let Factory = s:hosts[a:orig_name].factory
    1              0.000007   let s:hosts[a:name] = { 'factory': Factory, 'channel': 0, 'initialized': 0, 'orig_name': a:orig_name }

FUNCTION  <SNR>92_DirenvExport()
Called 1 time
Total time:   0.030276
 Self time:   0.030276

count  total (s)   self (s)
                              " FIXME: vim seems to read both stdout and stderr, it would be nice to
                              "        display stderr in a buffer on error
    1              0.030268   execute system('direnv export vim 2>/dev/null')

FUNCTION  airline#highlighter#highlight()
Called 2 times
Total time:   0.048862
 Self time:   0.006179

count  total (s)   self (s)
    2              0.000004   let bufnr = a:0 ? a:1 : ''
    2              0.000006   let p = g:airline#themes#{g:airline_theme}#palette
                            
                              " draw the base mode, followed by any overrides
    2              0.000016   let mapped = map(a:modes, 'v:val == a:modes[0] ? v:val : a:modes[0]."_".v:val')
    2              0.000005   let suffix = a:modes[0] == 'inactive' ? '_inactive' : ''
    5              0.000010   for mode in mapped
    3              0.000008     if mode == 'inactive' && winnr('$') == 1
                                  " there exist no inactive windows, don't need to create all those
                                  " highlighting groups
                                  continue
                                endif
    3              0.000015     if exists('g:airline#themes#{g:airline_theme}#palette[mode]')
    2              0.000006       let dict = g:airline#themes#{g:airline_theme}#palette[mode]
   36              0.000121       for kvp in items(dict)
   34              0.000085         let mode_colors = kvp[1]
   34              0.000071         let name = kvp[0]
   34              0.000119         if name is# 'airline_c' && !empty(bufnr) && suffix is# '_inactive'
    1              0.000002           let name = 'airline_c'.bufnr
    1              0.000001         endif
   34   0.010009   0.000337         call airline#highlighter#exec(name.suffix, mode_colors)
                            
  102              0.000292         for accent in keys(s:accents)
   68              0.000224           if !has_key(p.accents, accent)
                                        continue
                                      endif
   68              0.000366           let colors = copy(mode_colors)
   68              0.000219           if p.accents[accent][0] != ''
   34              0.000106             let colors[0] = p.accents[accent][0]
   34              0.000031           endif
   68              0.000223           if p.accents[accent][2] != ''
   34              0.000092             let colors[2] = p.accents[accent][2]
   34              0.000028           endif
   68              0.000138           if len(colors) >= 5
   68              0.000274             let colors[4] = get(p.accents[accent], 4, '')
   68              0.000064           else
                                        call add(colors, get(p.accents[accent], 4, ''))
                                      endif
   68   0.022702   0.000765           call airline#highlighter#exec(name.suffix.'_'.accent, colors)
   68              0.000094         endfor
   34              0.000035       endfor
                            
                                  " TODO: optimize this
   20              0.000073       for sep in items(s:separators)
   18   0.011352   0.000277         call <sid>exec_separator(dict, sep[1][0], sep[1][1], sep[1][2], suffix)
   18              0.000025       endfor
    2              0.000004     endif
    3              0.000002   endfor

FUNCTION  <SNR>120_update_git_branch()
Called 6 times
Total time:   0.002007
 Self time:   0.000414

count  total (s)   self (s)
    6              0.000015   if !s:has_fugitive
                                let s:vcs_config['git'].branch = ''
                                return
                              endif
                            
    6   0.001645   0.000051   let name = fugitive#head(7)
    6              0.000017   if empty(name)
                                if has_key(s:git_dirs, a:path)
                                  let s:vcs_config['git'].branch = s:git_dirs[a:path]
                                  return
                                endif
                            
                                let dir = fugitive#extract_git_dir(a:path)
                                if empty(dir)
                                  let name = ''
                                else
                                  try
                                    let line = join(readfile(dir . '/HEAD'))
                                    if strpart(line, 0, 16) == 'ref: refs/heads/'
                                      let name = strpart(line, 16)
                                    else
                                      " raw commit hash
                                      let name = strpart(line, 0, 7)
                                    endif
                                  catch
                                    let name = ''
                                  endtry
                                endif
                              endif
                            
    6              0.000031   let s:git_dirs[a:path] = name
    6              0.000026   let s:vcs_config['git'].branch = name

FUNCTION  airline#parts#ffenc()
Called 6 times
Total time:   0.000211
 Self time:   0.000211

count  total (s)   self (s)
    6              0.000035   let expected = get(g:, 'airline#parts#ffenc#skip_expected_string', '')
    6              0.000020   let bomb     = &l:bomb ? '[BOM]' : ''
    6              0.000063   let ff       = strlen(&ff) ? '['.&ff.']' : ''
    6              0.000039   if expected is# &fenc.bomb.ff
                                return ''
                              else
    6              0.000029     return &fenc.bomb.ff
                              endif

FUNCTION  <SNR>21_buffer_getvar()
Called 12 times
Total time:   0.000036
 Self time:   0.000036

count  total (s)   self (s)
   12              0.000033   return getbufvar(self['#'],a:var)

FUNCTION  airline#extensions#ctrlp#apply()
Called 6 times
Total time:   0.000067
 Self time:   0.000067

count  total (s)   self (s)
                              " disable statusline overwrite if ctrlp already did it
    6              0.000059   return match(&statusline, 'CtrlPwhite') >= 0 ? -1 : 0

FUNCTION  <SNR>130_get_transitioned_seperator()
Called 46 times
Total time:   0.026171
 Self time:   0.001114

count  total (s)   self (s)
   46              0.000077   let line = ''
   46   0.025358   0.000301   call airline#highlighter#add_separator(a:prev_group, a:group, a:side)
   46              0.000255   let line .= '%#'.a:prev_group.'_to_'.a:group.'#'
   46              0.000202   let line .= a:side ? a:self._context.left_sep : a:self._context.right_sep
   46              0.000147   let line .= '%#'.a:group.'#'
   46              0.000063   return line

FUNCTION  neomake#CursorMovedDelayed()
Called 3 times
Total time:   0.000138
 Self time:   0.000138

count  total (s)   self (s)
    3              0.000031     if exists('s:cursormoved_timer')
    3              0.000015         call timer_stop(s:cursormoved_timer)
    3              0.000005     endif
    3              0.000054     let s:cursormoved_timer = timer_start(get(g:, 'neomake_cursormoved_delay', 100), function('s:cursormoved_delayed_cb'))
    3              0.000024     let s:cursormoved_last_pos = getpos('.')

FUNCTION  ctrlp#utils#opts()
Called 1 time
Total time:   0.000081
 Self time:   0.000057

count  total (s)   self (s)
    1   0.000016   0.000009 	let s:lash = ctrlp#utils#lash()
    1   0.000018   0.000009 	let usrhome = $HOME . s:lash( $HOME )
    1              0.000005 	let cahome = exists('$XDG_CACHE_HOME') ? $XDG_CACHE_HOME : usrhome.'.cache'
    1   0.000029   0.000021 	let cadir = isdirectory(usrhome.'.ctrlp_cache') ? usrhome.'.ctrlp_cache' : cahome.s:lash(cahome).'ctrlp'
    1              0.000003 	if exists('g:ctrlp_cache_dir')
                            		let cadir = expand(g:ctrlp_cache_dir, 1)
                            		if isdirectory(cadir.s:lash(cadir).'.ctrlp_cache')
                            			let cadir = cadir.s:lash(cadir).'.ctrlp_cache'
                            		en
                            	en
    1              0.000002 	let s:cache_dir = cadir

FUNCTION  rainbow_parentheses#load()
Called 4 times
Total time:   0.003005
 Self time:   0.003005

count  total (s)   self (s)
    4              0.000028 	let [level, grp, type] = ['', '', s:types[a:1]]
    4              0.000074 	let alllvls = map(range(1, s:max), '"level".v:val')
    4              0.000010 	if !exists('b:loaded')
    1              0.000002 		let b:loaded = [0,0,0,0]
    1              0.000001 	endif
    4              0.000012 	let b:loaded[a:1] = s:loadtgl && b:loaded[a:1] ? 0 : 1
   68              0.000077 	for each in range(1, s:max)
   64              0.000187 		let region = 'level'. each .(b:loaded[a:1] ? '' : 'none')
   64              0.000157 		let grp = b:loaded[a:1] ? 'level'.each.'c' : 'Normal'
   64              0.000125 		let cmd = 'sy region %s matchgroup=%s start=/%s/ end=/%s/ contains=TOP,%s,NoInParens'
   64              0.002067 		exe printf(cmd, region, grp, type[0], type[1], join(alllvls, ','))
   64              0.000132 		cal remove(alllvls, 0)
   64              0.000050 	endfor

FUNCTION  <SNR>130_get_seperator()
Called 40 times
Total time:   0.034165
 Self time:   0.000571

count  total (s)   self (s)
   40   0.011236   0.000255   if s:should_change_group(a:prev_group, a:group)
   40   0.022897   0.000283     return s:get_transitioned_seperator(a:self, a:prev_group, a:group, a:side)
                              else
                                return a:side ? a:self._context.left_alt_sep : a:self._context.right_alt_sep
                              endif

FUNCTION  <SNR>120_update_untracked()
Called 6 times
Total time:   0.006991
 Self time:   0.002809

count  total (s)   self (s)
    6              0.000265   let file = expand("%:p")
    6              0.000053   if empty(file) || isdirectory(file)
                                return
                              endif
                            
    6              0.000016   let needs_update = 1
   18              0.000055   for vcs in keys(s:vcs_config)
   12              0.000093     if file =~ s:vcs_config[vcs].exclude
                                  " Skip check for files that live in the exclude directory
                                  let needs_update = 0
                                endif
   12              0.000053     if has_key(s:vcs_config[vcs].untracked, file)
    2              0.000004       let needs_update = 0
    2   0.000069   0.000027       call airline#extensions#branch#update_untracked_config(file, vcs)
    2              0.000002     endif
   12              0.000013   endfor
                            
    6              0.000012   if !needs_update
    2              0.000003     return
                              endif
                            
   12              0.000041   for vcs in keys(s:vcs_config)
    8              0.000033     let config = s:vcs_config[vcs]
    8              0.000019     if g:airline#init#vim_async
                                  " Note that asynchronous update updates s:vcs_config only, and only
                                  " s:update_untracked updates b:buffer_vcs_config. If s:vcs_config is
                                  " invalidated again before s:update_untracked is called, then we lose the
                                  " result of the previous call, i.e. the head string is not updated. It
                                  " doesn't happen often in practice, so we let it be.
                                  call airline#async#vim_vcs_untracked(config, file)
                                else
                                  " nvim async or vim without job-feature
    8   0.005830   0.001691       call airline#async#nvim_vcs_untracked(config, file, vcs)
    8              0.000012     endif
    8              0.000012   endfor

FUNCTION  classpath#separator()
Called 2 times
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    2              0.000011  return has('win32') ? ';' : ':'

FUNCTION  airline#parts#get()
Called 4 times
Total time:   0.000020
 Self time:   0.000020

count  total (s)   self (s)
    4              0.000018   return get(s:parts, a:key, {})

FUNCTION  airline#parts#paste()
Called 6 times
Total time:   0.000027
 Self time:   0.000027

count  total (s)   self (s)
    6              0.000023   return g:airline_detect_paste && &paste ? g:airline_symbols.paste : ''

FUNCTION  RepeatableMap()
Called 34 times
Total time:   0.001120
 Self time:   0.001120

count  total (s)   self (s)
   34              0.000328   let escaped_keys = substitute(a:keys, '["<]', '\\\0', "g")
   34              0.000771   execute a:map_type . ' <silent> <buffer> ' . a:keys . ' ' . a:command . '\|silent! call repeat#set("' . escaped_keys . '")<CR>'

FUNCTION  airline#update_statusline()
Called 6 times
Total time:   0.063708
 Self time:   0.000777

count  total (s)   self (s)
    6   0.000070   0.000041   if airline#util#getwinvar(winnr(), 'airline_disabled', 0)
                                return
                              endif
   12              0.000065   for nr in filter(range(1, winnr('$')), 'v:val != winnr()')
    6   0.000052   0.000029     if airline#util#getwinvar(nr, 'airline_disabled', 0)
                                  continue
                                endif
    6              0.000024     call setwinvar(nr, 'airline_active', 0)
    6              0.000034     let context = { 'winnr': nr, 'active': 0, 'bufnr': winbufnr(nr) }
    6   0.020148   0.000100     call s:invoke_funcrefs(context, s:inactive_funcrefs)
    6              0.000007   endfor
                            
    6              0.000020   unlet! w:airline_render_left w:airline_render_right
    6              0.000108   exe 'unlet! ' 'w:airline_section_'. join(s:sections, ' w:airline_section_')
                            
    6              0.000015   let w:airline_active = 1
    6              0.000041   let context = { 'winnr': winnr(), 'active': 1, 'bufnr': winbufnr(winnr()) }
    6   0.042980   0.000148   call s:invoke_funcrefs(context, g:airline_statusline_funcrefs)

FUNCTION  <SNR>78_remove_all_bookmarks()
Called 1 time
Total time:   0.000016
 Self time:   0.000013

count  total (s)   self (s)
    1   0.000006   0.000004   let files = bm#all_files()
    1              0.000002   for file in files
                                let lines = bm#all_lines(file)
                                for line_nr in lines
                                  call s:bookmark_remove(file, line_nr)
                                endfor
                              endfor

FUNCTION  airline#extensions#branch#update_untracked_config()
Called 2 times
Total time:   0.000042
 Self time:   0.000042

count  total (s)   self (s)
    2              0.000010   if !has_key(s:vcs_config[a:vcs].untracked, a:file)
                                return
                              elseif s:vcs_config[a:vcs].untracked[a:file] != b:buffer_vcs_config[a:vcs].untracked
    1              0.000006     let b:buffer_vcs_config[a:vcs].untracked = s:vcs_config[a:vcs].untracked[a:file]
    1              0.000003     unlet! b:airline_head
    1              0.000001   endif

FUNCTION  ctrlp#utils#cachedir()
Called 1 time
Total time:   0.000002
 Self time:   0.000002

count  total (s)   self (s)
    1              0.000002 	retu s:cache_dir

FUNCTION  <SNR>147_set_up_doc()
Called 2 times
Total time:   0.000343
 Self time:   0.000116

count  total (s)   self (s)
    2              0.000015   command! -buffer -nargs=1 FindDoc :exe s:Lookup(s:repl_ns(), 'find-doc', printf('#"%s"', <q-args>))
    2              0.000012   command! -buffer -bar -nargs=1 Javadoc :exe s:Lookup('clojure.java.javadoc', 'javadoc', <q-args>)
    2              0.000009   command! -buffer -bar -nargs=1 -complete=customlist,fireplace#eval_complete Doc     :exe s:Doc(<q-args>)
    2              0.000012   command! -buffer -bar -nargs=1 -complete=customlist,fireplace#eval_complete Source  :exe s:Lookup(s:repl_ns(), 'source', <q-args>)
    2              0.000010   setlocal keywordprg=:Doc
                            
    2              0.000010   if get(g:, 'fireplace_no_maps') | return | endif
    2   0.000097   0.000015   call s:map('n', 'K', '<Plug>FireplaceK', '<unique>')
    2   0.000088   0.000014   call s:map('n', '[d', '<Plug>FireplaceSource')
    2   0.000084   0.000013   call s:map('n', ']d', '<Plug>FireplaceSource')

FUNCTION  <SNR>131_build_sections()
Called 16 times
Total time:   0.005332
 Self time:   0.000954

count  total (s)   self (s)
   76              0.000120   for key in a:keys
   60              0.000192     if (key == 'warning' || key == 'error') && !a:context.active
    4              0.000005       continue
                                endif
   56   0.004691   0.000314     call s:add_section(a:builder, a:context, key)
   56              0.000064   endfor

FUNCTION  <SNR>106_AddEval()
Called 1 time
Total time:   0.000018
 Self time:   0.000018

count  total (s)   self (s)
    1              0.000005   if has_key(a:opts, 'eval')
                                if type(a:opts.eval) != type('') || a:opts.eval == ''
                                  throw "Eval option must be a non-empty string"
                                endif
                                " evaluate an expression and pass as argument
                                call add(a:rpcargs, 'eval("'.escape(a:opts.eval, '"').'")')
                              endif

FUNCTION  <SNR>147_set_up_eval()
Called 2 times
Total time:   0.001427
 Self time:   0.000294

count  total (s)   self (s)
    2              0.000024   command! -buffer -bang -range=0 -nargs=? -complete=customlist,fireplace#eval_complete Eval :exe s:Eval(<bang>0, <line1>, <line2>, <count>, <q-args>)
    2              0.000012   command! -buffer -bang -bar -count=1 Last exe s:Last(<bang>0, <count>)
                            
    2              0.000012   if get(g:, 'fireplace_no_maps') | return | endif
                            
    2   0.000101   0.000020   call s:map('n', 'cp', '<Plug>FireplacePrint')
    2   0.000101   0.000015   call s:map('n', 'cpp', '<Plug>FireplaceCountPrint')
                            
    2   0.000125   0.000017   call s:map('n', 'c!', '<Plug>FireplaceFilter')
    2   0.000117   0.000028   call s:map('n', 'c!!', '<Plug>FireplaceCountFilter')
                            
    2   0.000094   0.000016   call s:map('n', 'cm', '<Plug>FireplaceMacroExpand')
    2   0.000085   0.000014   call s:map('n', 'cmm', '<Plug>FireplaceCountMacroExpand')
    2   0.000080   0.000012   call s:map('n', 'c1m', '<Plug>Fireplace1MacroExpand')
    2   0.000081   0.000012   call s:map('n', 'c1mm', '<Plug>FireplaceCount1MacroExpand')
                            
    2   0.000083   0.000014   call s:map('n', 'cq', '<Plug>FireplaceEdit')
    2   0.000079   0.000012   call s:map('n', 'cqq', '<Plug>FireplaceCountEdit')
                            
    2   0.000078   0.000012   call s:map('n', 'cqp', '<Plug>FireplacePrompt')
    2   0.000085   0.000018   call s:map('n', 'cqc', '<Plug>FireplacePrompt' . &cedit . 'i')
                            
    2   0.000086   0.000014   call s:map('i', '<C-R>(', '<Plug>FireplaceRecall')
    2   0.000088   0.000012   call s:map('c', '<C-R>(', '<Plug>FireplaceRecall')
    2   0.000080   0.000012   call s:map('s', '<C-R>(', '<Plug>FireplaceRecall')

FUNCTION  airline#parts#readonly()
Called 14 times
Total time:   0.000161
 Self time:   0.000161

count  total (s)   self (s)
   14              0.000065   if &readonly && !filereadable(bufname('%'))
                                return '[noperm]'
                              else
   14              0.000036     return &readonly ? g:airline_symbols.readonly : ''
                              endif

FUNCTION  remote#host#PluginsForHost()
Called 1 time
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
    1              0.000003   if !has_key(s:plugins_for_host, a:host)
    1              0.000003     let s:plugins_for_host[a:host] = []
    1              0.000001   end
    1              0.000002   return s:plugins_for_host[a:host]

FUNCTION  <SNR>35_append()
Called 6 times
Total time:   0.000177
 Self time:   0.000177

count  total (s)   self (s)
    6              0.000019   if &filetype == 'unite'
                                " Ignore unite window.
                                return
                              endif
                            
                              " Save unite window information.
    6              0.000130   let w:unite_window = { 'time' : localtime(), 'cwd' : getcwd(),}

FUNCTION  neomake#statusline#LoclistCounts()
Called 12 times
Total time:   0.000208
 Self time:   0.000208

count  total (s)   self (s)
   12              0.000068     let buf = a:0 ? a:1 : bufnr('%')
   12              0.000027     if buf is# 'all'
                                    return s:loclist_counts
                                endif
   12              0.000059     return get(s:loclist_counts, buf, {})

FUNCTION  <SNR>21_buffer_repo()
Called 6 times
Total time:   0.000185
 Self time:   0.000038

count  total (s)   self (s)
    6   0.000183   0.000037   return s:repo(self.getvar('git_dir'))

FUNCTION  nerdtree#has_opt()
Called 33 times
Total time:   0.000124
 Self time:   0.000124

count  total (s)   self (s)
   33              0.000110     return has_key(a:options, a:name) && a:options[a:name] == 1

FUNCTION  airline#util#getwinvar()
Called 108 times
Total time:   0.000424
 Self time:   0.000424

count  total (s)   self (s)
  108              0.000375     return getwinvar(a:winnr, a:key, a:def)

FUNCTION  airline#highlighter#exec()
Called 168 times
Total time:   0.046576
 Self time:   0.014164

count  total (s)   self (s)
  168              0.000323   if pumvisible()
                                return
                              endif
  168              0.000316   let colors = a:colors
  168              0.000215   if s:is_win32term
                                let colors[2] = s:gui2cui(get(colors, 0, ''), get(colors, 2, ''))
                                let colors[3] = s:gui2cui(get(colors, 1, ''), get(colors, 3, ''))
                              endif
  168   0.025404   0.001047   let old_hi = airline#highlighter#get_highlight(a:group)
  168              0.000385   if len(colors) == 4
   64              0.000179     call add(colors, '')
   64              0.000053   endif
  168              0.000319   if g:airline_gui_mode ==# 'gui'
                                let new_hi = [colors[0], colors[1], '', '', colors[4]]
                              else
  168              0.001242     let new_hi = ['', '', printf("%s", colors[2]), printf("%s", colors[3]), colors[4]]
  168              0.000156   endif
  168   0.004140   0.000867   let colors = s:CheckDefined(colors)
  168   0.002922   0.001102   if old_hi != new_hi || !s:hl_group_exists(a:group)
   48   0.004599   0.001637     let cmd = printf('hi %s %s %s %s %s %s %s %s', a:group, s:Get(colors, 0, 'guifg='), s:Get(colors, 1, 'guibg='), s:Get(colors, 2, 'ctermfg='), s:Get(colors, 3, 'ctermbg='), s:Get(colors, 4, 'gui='), s:Get(colors, 4, 'cterm='), s:Get(colors, 4, 'term='))
   48              0.000637     exe cmd
   48              0.000177     if has_key(s:hl_groups, a:group)
   48              0.000150       let s:hl_groups[a:group] = colors
   48              0.000046     endif
   48              0.000038   endif

FUNCTION  <SNR>126_hl_group_exists()
Called 124 times
Total time:   0.001820
 Self time:   0.001820

count  total (s)   self (s)
  124              0.000538   if !hlexists(a:group)
                                return 0
                              elseif empty(synIDattr(hlID(a:group), 'fg'))
    4              0.000005     return 0
                              endif
  120              0.000111   return 1

FUNCTION  airline#themes#get_highlight()
Called 128 times
Total time:   0.017842
 Self time:   0.001093

count  total (s)   self (s)
  128   0.017778   0.001029   return call('airline#highlighter#get_highlight', [a:group] + a:000)

FUNCTION  <SNR>148_connect()
Called 2 times
Total time:   0.000239
 Self time:   0.000088

count  total (s)   self (s)
    2              0.000022   if !exists('b:salve') || !exists(':FireplaceConnect')
                                return {}
                              endif
    2   0.000174   0.000023   let portfile = s:portfile()
    2              0.000010   if exists('g:salve_auto_start_repl') && a:autostart && empty(portfile) && exists(':Start') ==# 2
                                call s:repl(1, '')
                                let portfile = s:portfile()
                              endif
                            
    2              0.000010   return empty(portfile) ? {} : fireplace#register_port_file(portfile, b:salve.root)

FUNCTION  nerdtree#exec()
Called 5 times
Total time:   0.049369
 Self time:   0.000292

count  total (s)   self (s)
    5              0.000024     let old_ei = &ei
    5              0.000038     set ei=BufEnter,BufLeave,VimEnter
    5   0.049256   0.000179     exec a:cmd
    5              0.000045     let &ei = old_ei

FUNCTION  <SNR>142_lash()
Called 2 times
Total time:   0.000017
 Self time:   0.000017

count  total (s)   self (s)
    2              0.000016 	retu ( a:0 ? a:1 : getcwd() ) !~ '[\/]$' ? s:lash : ''

FUNCTION  neomake#CursorMoved()
Called 3 times
Total time:   0.000486
 Self time:   0.000041

count  total (s)   self (s)
    3   0.000480   0.000036     call neomake#EchoCurrentError()

FUNCTION  neomake#EchoCurrentError()
Called 3 times
Total time:   0.000445
 Self time:   0.000185

count  total (s)   self (s)
                                " a:1 might be a timer from the VimResized event.
    3              0.000024     let force = a:0 ? a:1 : 0
    3              0.000024     if !force && !get(g:, 'neomake_echo_current_error', 1)
                                    return
                                endif
                            
    3   0.000316   0.000055     let message = neomake#GetCurrentErrorMsg()
    3              0.000011     if empty(message)
    3              0.000016         if exists('s:neomake_last_echoed_error')
                                        echon ''
                                        unlet s:neomake_last_echoed_error
                                    endif
    3              0.000005         return
                                endif
                                if !force && exists('s:neomake_last_echoed_error') && s:neomake_last_echoed_error == message
                                    return
                                endif
                                let s:neomake_last_echoed_error = message
                                call neomake#utils#WideMessage(message)

FUNCTION  <SNR>21_winshell()
Called 10 times
Total time:   0.000068
 Self time:   0.000068

count  total (s)   self (s)
   10              0.000063   return &shell =~? 'cmd' || exists('+shellslash') && !&shellslash

FUNCTION  <SNR>122_get_counts()
Called 12 times
Total time:   0.000451
 Self time:   0.000211

count  total (s)   self (s)
   12   0.000300   0.000092   let l:counts = neomake#statusline#LoclistCounts()
                            
   12              0.000033   if empty(l:counts)
   12   0.000097   0.000065     return neomake#statusline#QflistCounts()
                              else
                                return l:counts
                              endif

FUNCTION  <SNR>147_set_up_tests()
Called 2 times
Total time:   0.000038
 Self time:   0.000038

count  total (s)   self (s)
    2              0.000023   command! -buffer -bar -bang -range=0 -nargs=* -complete=customlist,fireplace#ns_complete RunTests call s:RunTests(<bang>0, <line1> == 0 ? -1 : <count>, <f-args>)
    2              0.000012   command! -buffer -bang -nargs=* RunAllTests call s:RunTests(<bang>0, -1, <f-args>)

FUNCTION  RepeatableNNoRemap()
Called 34 times
Total time:   0.001348
 Self time:   0.000228

count  total (s)   self (s)
   34   0.001333   0.000213   call RepeatableMap('nnoremap', a:keys, a:command)

FUNCTION  <SNR>21_buffer_path()
Called 1 time
Total time:   0.000630
 Self time:   0.000094

count  total (s)   self (s)
    1   0.000068   0.000013   let rev = matchstr(self.spec(),'^fugitive://.\{-\}//\zs.*')
    1              0.000001   if rev != ''
                                let rev = s:sub(rev,'\w*','')
                              elseif s:cpath(self.spec()[0 : len(self.repo().dir())]) ==# s:cpath(self.repo().dir() . '/')
                                let rev = '/.git'.self.spec()[strlen(self.repo().dir()) : -1]
                              elseif !self.repo().bare() && s:cpath(self.spec()[0 : len(self.repo().tree())]) ==# s:cpath(self.repo().tree() . '/')
    1   0.000111   0.000009     let rev = self.spec()[strlen(self.repo().tree()) : -1]
    1              0.000001   endif
    1   0.000025   0.000007   return s:sub(s:sub(rev,'.\zs/$',''),'^/',a:0 ? a:1 : '')

FUNCTION  <SNR>130_section_is_empty()
Called 70 times
Total time:   0.000895
 Self time:   0.000895

count  total (s)   self (s)
   70              0.000115   let start=1
                            
                              " do not check for inactive windows or the tabline
   70              0.000123   if a:self._context.active == 0
   26              0.000026     return 0
                              elseif get(a:self._context, 'tabline', 0)
                                return 0
                              endif
                            
                              " only check, if airline#skip_empty_sections == 1
   44              0.000131   if get(g:, 'airline_skip_empty_sections', 0) == 0
   44              0.000047     return 0
                              endif
                            
                              " only check, if airline#skip_empty_sections == 1
                              if get(w:, 'airline_skip_empty_sections', -1) == 0
                                return 0
                              endif
                              " assume accents sections to be never empty
                              " (avoides, that on startup the mode message becomes empty)
                              if match(a:content, '%#__accent_[^#]*#.*__restore__#') > -1
                                return 0
                              endif
                              if empty(a:content)
                                return 1
                              endif
                              let list=matchlist(a:content, '%{\zs.\{-}\ze}', 1, start)
                              if empty(list)
                                return 0 " no function in statusline text
                              endif
                              while len(list) > 0
                                let expr = list[0]
                                try
                                  " catch all exceptions, just in case
                                  if !empty(eval(expr))
                                    return 0
                                  endif
                                catch
                                  return 0
                                endtry
                                let start += 1
                                let list=matchlist(a:content, '%{\zs.\{-}\ze}', 1, start)
                              endw
                              return 1

FUNCTION  <SNR>130_should_change_group()
Called 40 times
Total time:   0.010981
 Self time:   0.000962

count  total (s)   self (s)
   40              0.000098   if a:group1 == a:group2
                                return 0
                              endif
   40   0.005407   0.000221   let color1 = airline#highlighter#get_highlight(a:group1)
   40   0.005026   0.000193   let color2 = airline#highlighter#get_highlight(a:group2)
   40              0.000071   if g:airline_gui_mode ==# 'gui'
                                return color1[1] != color2[1] || color1[0] != color2[0]
                              else
   40              0.000123     return color1[3] != color2[3] || color1[2] != color2[2]
                              endif

FUNCTION  <SNR>21_buffer_getline()
Called 3 times
Total time:   0.000022
 Self time:   0.000022

count  total (s)   self (s)
    3              0.000020   return get(getbufline(self['#'], a:lnum), 0, '')

FUNCTION  <SNR>120_init_buffer()
Called 1 time
Total time:   0.000044
 Self time:   0.000044

count  total (s)   self (s)
    1              0.000006   let b:buffer_vcs_config = {}
    3              0.000013   for vcs in keys(s:vcs_config)
    2              0.000012     let b:buffer_vcs_config[vcs] = {     'branch': '',     'untracked': '',   }
    2              0.000003   endfor
    1              0.000003   unlet! b:airline_head

FUNCTION  <SNR>7_lines()
Called 35 times
Total time:   0.000355
 Self time:   0.000355

count  total (s)   self (s)
   35              0.000325   return split(a:msg, "[\r\n]")

FUNCTION  <SNR>7_remove_triggers()
Called 7 times
Total time:   0.000023
 Self time:   0.000023

count  total (s)   self (s)
    7              0.000014   if !has_key(s:triggers, a:name)
    7              0.000006     return
                              endif
                              for cmd in s:triggers[a:name].cmd
                                execute 'silent! delc' cmd
                              endfor
                              for map in s:triggers[a:name].map
                                execute 'silent! unmap' map
                                execute 'silent! iunmap' map
                              endfor
                              call remove(s:triggers, a:name)

FUNCTION  <SNR>155_Cygpath()
Called 1 time
Total time:   0.000024
 Self time:   0.000024

count  total (s)   self (s)
    1              0.000004     let path = a:path
    1              0.000002     if g:slimv_cygwin
                                    let path = system( 'cygpath -w ' . path )
                                    let path = substitute( path, "\n", "", "g" )
                                    let path = substitute( path, "\\", "/", "g" )
                                endif
    1              0.000003     return path

FUNCTION  airline#highlighter#add_accent()
Called 4 times
Total time:   0.000016
 Self time:   0.000016

count  total (s)   self (s)
    4              0.000013   let s:accents[a:accent] = 1

FUNCTION  <SNR>131_get_section()
Called 78 times
Total time:   0.002922
 Self time:   0.002647

count  total (s)   self (s)
   78              0.000213   if has_key(s:section_truncate_width, a:key)
   44              0.000127     if winwidth(a:winnr) < s:section_truncate_width[a:key]
    6              0.000007       return ''
                                endif
   38              0.000024   endif
   72              0.000150   let spc = g:airline_symbols.space
   72              0.000328   if !exists('g:airline_section_{a:key}')
                                return ''
                              endif
   72   0.000813   0.000538   let text = airline#util#getwinvar(a:winnr, 'airline_section_'.a:key, g:airline_section_{a:key})
   72              0.000519   let [prefix, suffix] = [get(a:000, 0, '%('.spc), get(a:000, 1, spc.'%)')]
   72              0.000286   return empty(text) ? '' : prefix.text.suffix

FUNCTION  <SNR>21_repo_dir()
Called 21 times
Total time:   0.000153
 Self time:   0.000153

count  total (s)   self (s)
   21              0.000144   return join([self.git_dir]+a:000,'/')

FUNCTION  airline#parts#spell()
Called 6 times
Total time:   0.000232
 Self time:   0.000232

count  total (s)   self (s)
    6              0.000104   let spelllang = g:airline_detect_spelllang ? printf(" [%s]", toupper(substitute(&spelllang, ',', '/', 'g'))) : ''
    6              0.000020   if g:airline_detect_spell && &spell
                                if winwidth(0) >= 90
                                  return g:airline_symbols.spell . spelllang
                                elseif winwidth(0) >= 70
                                  return g:airline_symbols.spell
                                else
                                  return split(g:airline_symbols.spell, '\zs')[0]
                                endif
                              endif
    6              0.000008   return ''

FUNCTION  <SNR>78_set_up_auto_save()
Called 1 time
Total time:   0.000522
 Self time:   0.000255

count  total (s)   self (s)
    1              0.000007   if g:bookmark_auto_save ==# 1 || g:bookmark_manage_per_buffer ==# 1
    1   0.000287   0.000020     call s:startup_load_bookmarks(a:file)
    1              0.000004     let g:bm_current_file = a:file
    1              0.000004     augroup bm_auto_save
    1              0.000201       autocmd!
    1              0.000007       autocmd BufWinEnter * call s:add_missing_signs(expand('<afile>:p'))
    1              0.000008       autocmd BufLeave,VimLeave * call s:auto_save()
    1              0.000001     augroup END
    1              0.000001   endif

FUNCTION  <SNR>50_record()
Called 2 times
Total time:   0.019539
 Self time:   0.000080

count  total (s)   self (s)
    2              0.000007 	if s:locked | retu | en
    2              0.000006 	let bufnr = a:bufnr + 0
    2              0.000006 	let bufname = bufname(bufnr)
    2              0.000006 	if bufnr > 0 && !empty(bufname)
    2              0.000017 		cal filter(s:mrbs, 'v:val != bufnr')
    2              0.000007 		cal insert(s:mrbs, bufnr)
    2   0.019480   0.000020 		cal s:addtomrufs(bufname)
    2              0.000002 	en

FUNCTION  <SNR>85_dopopd()
Called 5 times
Total time:   0.000038
 Self time:   0.000038

count  total (s)   self (s)
    5              0.000026   if !exists('w:fzf_dir') || s:fzf_getcwd() != w:fzf_dir[1]
    5              0.000006     return
                              endif
                              execute 'lcd' s:escape(w:fzf_dir[0])
                              unlet w:fzf_dir

FUNCTION  208()
Called 1 time
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    1              0.000008     let newObj = copy(self)
    1              0.000003     let newObj._flags = {}
    1              0.000002     return newObj

FUNCTION  <SNR>106_GetAutocmdPrefix()
Called 1 time
Total time:   0.000046
 Self time:   0.000046

count  total (s)   self (s)
    1              0.000004   if has_key(a:opts, 'group')
    1              0.000003     let group = a:opts.group
    1              0.000001   else
                                let group = s:GetNextAutocmdGroup()
                              endif
    1              0.000004   let rv = ['autocmd!', group, a:name]
                            
    1              0.000003   if has_key(a:opts, 'pattern')
    1              0.000004     call add(rv, a:opts.pattern)
    1              0.000001   else
                                call add(rv, '*')
                              endif
                            
    1              0.000003   if has_key(a:opts, 'nested') && a:opts.nested
                                call add(rv, 'nested')
                              endif
                            
    1              0.000008   return join(rv, ' ')

FUNCTION  <SNR>120_check_in_path()
Called 2 times
Total time:   0.000228
 Self time:   0.000228

count  total (s)   self (s)
    2              0.000008   if !exists('b:airline_file_in_root')
    1              0.000008     let root = get(b:, 'git_dir', get(b:, 'mercurial_dir', ''))
    1              0.000086     let bufferpath = resolve(fnamemodify(expand('%'), ':p'))
                            
    1              0.000009     if !filereadable(root) "not a file
                                  " if .git is a directory, it's the old submodule format
    1              0.000018       if match(root, '\.git$') >= 0
    1              0.000020         let root = expand(fnamemodify(root, ':h'))
    1              0.000002       else
                                    " else it's the newer format, and we need to guesstimate
                                    " 1) check for worktrees
                                    if match(root, 'worktrees') > -1
                                      " worktree can be anywhere, so simply assume true here
                                      return 1
                                    endif
                                    " 2) check for submodules
                                    let pattern = '\.git[\\/]\(modules\)[\\/]'
                                    if match(root, pattern) >= 0
                                      let root = substitute(root, pattern, '', '')
                                    endif
                                  endif
    1              0.000001     endif
                            
    1              0.000006     let b:airline_file_in_root = stridx(bufferpath, root) > -1
    1              0.000001   endif
    2              0.000004   return b:airline_file_in_root

FUNCTION  airline#parts#crypt()
Called 6 times
Total time:   0.000063
 Self time:   0.000063

count  total (s)   self (s)
    6              0.000056   return g:airline_detect_crypt && exists("+key") && !empty(&key) ? g:airline_symbols.crypt : ''

FUNCTION  <SNR>52_invoke_funcrefs()
Called 12 times
Total time:   0.062879
 Self time:   0.000740

count  total (s)   self (s)
   12   0.000452   0.000077   let builder = airline#builder#new(a:context)
   12   0.011286   0.000150   let err = airline#util#exec_funcrefs(a:funcrefs + s:core_funcrefs, builder, a:context)
   12              0.000017   if err == 1
   12   0.050748   0.000120     let a:context.line = builder.build()
   12              0.000156     let s:contexts[a:context.winnr] = a:context
   12              0.000176     call setwinvar(a:context.winnr, '&statusline', '%!airline#statusline('.a:context.winnr.')')
   12              0.000014   endif

FUNCTION  214()
Called 1 time
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    1              0.000002     if g:NERDTreeQuitOnOpen && s:NERDTree.IsOpen()
                                    call s:NERDTree.Close()
                                endif

FUNCTION  217()
Called 1 time
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    1              0.000007     return exists("b:NERDTree")

FUNCTION  airline#extensions#keymap#status()
Called 6 times
Total time:   0.000098
 Self time:   0.000098

count  total (s)   self (s)
    6              0.000048   if (get(g:, 'airline#extensions#keymap#enabled', 1) && has('keymap'))
    6              0.000042     return printf('%s', (!empty(&keymap) ? (g:airline_symbols.keymap . ' '. &keymap) : ''))
                              else
                                return ''
                              endif

FUNCTION  fugitive#is_git_dir()
Called 6 times
Total time:   0.000190
 Self time:   0.000134

count  total (s)   self (s)
    6   0.000095   0.000040   let path = s:sub(a:path, '[\/]$', '') . '/'
    6              0.000090   return getfsize(path.'HEAD') > 10 && ( isdirectory(path.'objects') && isdirectory(path.'refs') || getftype(path.'commondir') ==# 'file')

FUNCTION  <SNR>78_add_missing_signs()
Called 2 times
Total time:   0.000063
 Self time:   0.000044

count  total (s)   self (s)
    2   0.000045   0.000026   let bookmarks = values(bm#all_bookmarks_by_line(a:file))
    2              0.000005   for bookmark in bookmarks
                                call bm_sign#add_at(a:file, bookmark['sign_idx'], bookmark['line_nr'], bookmark['annotation'] !=# "")
                              endfor

FUNCTION  airline#extensions#branch#head()
Called 6 times
Total time:   0.011309
 Self time:   0.000681

count  total (s)   self (s)
    6              0.000028   if !exists('b:buffer_vcs_config')
    1   0.000059   0.000015     call s:init_buffer()
    1              0.000001   endif
                            
    6   0.003374   0.000065   call s:update_branch()
    6   0.007068   0.000078   call s:update_untracked()
                            
    6              0.000034   if exists('b:airline_head') && !empty(b:airline_head)
    4              0.000009     return b:airline_head
                              endif
                            
    2              0.000009   let b:airline_head = ''
    2              0.000013   let vcs_priority = get(g:, "airline#extensions#branch#vcs_priority", ["git", "mercurial"])
                            
    2              0.000005   let heads = {}
    6              0.000013   for vcs in vcs_priority
    4              0.000018     if !empty(b:buffer_vcs_config[vcs].branch)
    2              0.000009       let heads[vcs] = b:buffer_vcs_config[vcs].branch
    2              0.000002     endif
    4              0.000006   endfor
                            
    4              0.000012   for vcs in keys(heads)
    2              0.000006     if !empty(b:airline_head)
                                  let b:airline_head .= ' | '
                                endif
    2   0.000075   0.000069     let b:airline_head .= (len(heads) > 1 ? s:vcs_config[vcs].exe .':' : '') . s:format_name(heads[vcs])
    2              0.000010     let b:airline_head .= b:buffer_vcs_config[vcs].untracked
    2              0.000003   endfor
                            
    2              0.000005   if empty(heads)
                                if s:has_vcscommand
                                  call VCSCommandEnableBufferSetup()
                                  if exists('b:VCSCommandBufferInfo')
                                    let b:airline_head = s:format_name(get(b:VCSCommandBufferInfo, 0, ''))
                                  endif
                                endif
                              endif
                            
    2              0.000010   if exists("g:airline#extensions#branch#displayed_head_limit")
                                let w:displayed_head_limit = g:airline#extensions#branch#displayed_head_limit
                                if len(b:airline_head) > w:displayed_head_limit - 1
                                  let b:airline_head = b:airline_head[0:(w:displayed_head_limit - 1)].(&encoding ==? 'utf-8' ?  '…' : '.')
                                endif
                              endif
                            
    2   0.000252   0.000024   if has_key(heads, 'git') && !s:check_in_path()
                                let b:airline_head = ''
                              endif
    2              0.000012   let minwidth = empty(get(b:, 'airline_hunks', '')) ? 14 : 7
    2   0.000068   0.000020   let b:airline_head = airline#util#shorten(b:airline_head, 120, minwidth)
    2              0.000006   return b:airline_head

FUNCTION  <SNR>147_set_up_require()
Called 2 times
Total time:   0.000117
 Self time:   0.000037

count  total (s)   self (s)
    2              0.000016   command! -buffer -bar -bang -complete=customlist,fireplace#ns_complete -nargs=? Require :exe s:Require(<bang>0, 1, <q-args>)
                            
    2   0.000097   0.000017   call s:map('n', 'cpr', ":<C-R>=expand('%:e') ==# 'cljs' ? 'Require' : 'RunTests'<CR><CR>", '<silent>')

FUNCTION  <SNR>7_esc()
Called 7 times
Total time:   0.000049
 Self time:   0.000049

count  total (s)   self (s)
    7              0.000044   return escape(a:path, ' ')

FUNCTION  235()
Called 1 time
Total time:   0.001635
 Self time:   0.000324

count  total (s)   self (s)
    1              0.000007     let line = getline(a:ln)
                            
    1   0.000071   0.000010     let rootLine = self.getRootLineNum()
                            
                                "check to see if we have the root node
    1              0.000002     if a:ln == rootLine
                                    return self.nerdtree.root.path
                                endif
                            
    1   0.000013   0.000010     if line ==# s:UI.UpDirLine()
                                    return self.nerdtree.root.path.getParent()
                                endif
                            
    1   0.000050   0.000009     let indent = self._indentLevelFor(line)
                            
                                "remove the tree parts and the leading space
    1   0.000116   0.000011     let curFile = self._stripMarkup(line, 0)
                            
    1              0.000002     let wasdir = 0
    1              0.000004     if curFile =~# '/$'
                                    let wasdir = 1
                                    let curFile = substitute(curFile, '/\?$', '/', "")
                                endif
                            
    1              0.000002     let dir = ""
    1              0.000002     let lnum = a:ln
    4              0.000007     while lnum > 0
    4              0.000007         let lnum = lnum - 1
    4              0.000013         let curLine = getline(lnum)
    4   0.000431   0.000031         let curLineStripped = self._stripMarkup(curLine, 1)
                            
                                    "have we reached the top of the tree?
    4              0.000009         if lnum == rootLine
    1   0.000117   0.000016             let dir = self.nerdtree.root.path.str({'format': 'UI'}) . dir
    1              0.000002             break
                                    endif
    3              0.000019         if curLineStripped =~# '/$'
    3   0.000145   0.000026             let lpindent = self._indentLevelFor(curLine)
    3              0.000007             if lpindent < indent
    1              0.000003                 let indent = indent - 1
                            
    1              0.000009                 let dir = substitute (curLineStripped,'^\\', "", "") . dir
    1              0.000002                 continue
                                        endif
    2              0.000002         endif
    2              0.000002     endwhile
    1              0.000006     let curFile = self.nerdtree.root.path.drive . dir . curFile
    1   0.000494   0.000011     let toReturn = g:NERDTreePath.New(curFile)
    1              0.000002     return toReturn

FUNCTION  <SNR>7_source()
Called 28 times
Total time:   0.014647
 Self time:   0.002874

count  total (s)   self (s)
   28              0.000068   let found = 0
   56              0.000113   for pattern in a:000
   35   0.002866   0.000211     for vim in s:glob(a:from, pattern)
    7   0.010976   0.001859       execute 'source' s:esc(vim)
    7              0.000032       let found = 1
    7              0.000011     endfor
   28              0.000028   endfor
   28              0.000051   return found

FUNCTION  <SNR>126_get_syn()
Called 752 times
Total time:   0.025939
 Self time:   0.025939

count  total (s)   self (s)
  752              0.002342   if !exists("g:airline_gui_mode")
                                let g:airline_gui_mode = airline#init#gui_mode()
                              endif
  752              0.001096   let color = ''
  752              0.002791   if hlexists(a:group)
  636              0.004390     let color = synIDattr(synIDtrans(hlID(a:group)), a:what, g:airline_gui_mode)
  636              0.001045   endif
  752              0.001898   if empty(color) || color == -1
                                " should always exists
  136              0.000980     let color = synIDattr(synIDtrans(hlID('Normal')), a:what, g:airline_gui_mode)
                                " however, just in case
  136              0.000288     if empty(color) || color == -1
  136              0.000210       let color = 'NONE'
  136              0.000113     endif
  136              0.000094   endif
  752              0.000925   return color

FUNCTION  225()
Called 1 time
Total time:   0.000002
 Self time:   0.000002

count  total (s)   self (s)
    1              0.000002     return self._type == "window"

FUNCTION  airline#parts#mode()
Called 6 times
Total time:   0.000201
 Self time:   0.000070

count  total (s)   self (s)
    6   0.000194   0.000064   return airline#util#shorten(get(w:, 'airline_current_mode', ''), 79, 1)

FUNCTION  <SNR>21_cpath()
Called 5 times
Total time:   0.000034
 Self time:   0.000034

count  total (s)   self (s)
    5              0.000014   if exists('+fileignorecase') && &fileignorecase
                                return tolower(a:path)
                              else
    5              0.000006     return a:path
                              endif

FUNCTION  <SNR>155_MenuMap()
Called 63 times
Total time:   0.002497
 Self time:   0.002497

count  total (s)   self (s)
   63              0.000074     if g:slimv_keybindings == 1
                                    " Short (one-key) keybinding set
   63              0.000098         let shortcut = a:shortcut1
   63              0.000059     elseif g:slimv_keybindings == 2
                                    " Easy to remember (two-key) keybinding set
                                    let shortcut = a:shortcut2
                                else
                                    " No bindings
                                    let shortcut = ''
                                endif
                            
   63              0.000076     if shortcut != ''
   51              0.000552         execute "noremap <silent> " . shortcut . " " . a:command
   51              0.000098         if a:name != '' && g:slimv_menu == 1
   50              0.000686             silent execute "amenu " . a:name . "<Tab>" . shortcut . " " . a:command
   50              0.000042         endif
   51              0.000065     elseif a:name != '' && g:slimv_menu == 1
   12              0.000128         silent execute "amenu " . a:name . " " . a:command
   12              0.000008     endif

FUNCTION  remote#define#AutocmdOnChannel()
Called 1 time
Total time:   0.000240
 Self time:   0.000172

count  total (s)   self (s)
    1              0.000007   let rpcargs = [a:channel, '"'.a:method.'"']
    1   0.000034   0.000016   call s:AddEval(rpcargs, a:opts)
                            
    1   0.000086   0.000035   let autocmd_def = s:GetAutocmdPrefix(a:name, a:opts) . ' call '.s:GetRpcFunction(a:sync).'('.join(rpcargs, ', ').')'
    1              0.000110   exe autocmd_def

FUNCTION  airline#extensions#quickfix#apply()
Called 6 times
Total time:   0.000078
 Self time:   0.000078

count  total (s)   self (s)
    6              0.000022   if &buftype == 'quickfix'
                                let w:airline_section_a = s:get_text()
                                let w:airline_section_b = '%{get(w:, "quickfix_title", "")}'
                                let w:airline_section_c = ''
                                let w:airline_section_x = ''
                              endif

FUNCTION  <SNR>34_append()
Called 2 times
Total time:   0.000087
 Self time:   0.000059

count  total (s)   self (s)
    2              0.000012   if bufnr('%') != expand('<abuf>')
                                return
                              endif
                            
    2              0.000012   if !has('vim_starting') || bufname(bufnr('%')) != ''
    2   0.000051   0.000023     call unite#sources#buffer#variables#append(bufnr('%'))
    2              0.000002   endif

FUNCTION  <SNR>21_sub()
Called 17 times
Total time:   0.000257
 Self time:   0.000257

count  total (s)   self (s)
   17              0.000243   return substitute(a:str,'\v\C'.a:pat,a:rep,'')

FUNCTION  237()
Called 1 time
Total time:   0.000061
 Self time:   0.000061

count  total (s)   self (s)
    1              0.000003     let rootLine = 1
    4              0.000035     while getline(rootLine) !~# '^\(/\|<\)'
    3              0.000008         let rootLine = rootLine + 1
    3              0.000006     endwhile
    1              0.000002     return rootLine

FUNCTION  <SNR>147_set_up_source()
Called 2 times
Total time:   0.000491
 Self time:   0.000108

count  total (s)   self (s)
    2              0.000015   setlocal define=^\\s*(def\\w*
    2              0.000010   command! -bar -buffer -nargs=1 -complete=customlist,fireplace#eval_complete Djump  :exe s:Edit('edit', <q-args>)
    2              0.000011   command! -bar -buffer -nargs=1 -complete=customlist,fireplace#eval_complete Dsplit :exe s:Edit('<mods> split', <q-args>)
                            
    2   0.000083   0.000012   call s:map('n', '[<C-D>',     '<Plug>FireplaceDjump')
    2   0.000072   0.000011   call s:map('n', ']<C-D>',     '<Plug>FireplaceDjump')
    2   0.000078   0.000011   call s:map('n', '<C-W><C-D>', '<Plug>FireplaceDsplit')
    2   0.000124   0.000013   call s:map('n', '<C-W>d',     '<Plug>FireplaceDsplit')
    2   0.000093   0.000021   call s:map('n', '<C-W>gd',    '<Plug>FireplaceDtabjump')

FUNCTION  <SNR>126_get_array()
Called 376 times
Total time:   0.003616
 Self time:   0.003616

count  total (s)   self (s)
  376              0.001372   let opts=empty(a:opts) ? '' : join(a:opts, ',')
  376              0.001987   return g:airline_gui_mode ==# 'gui' ? [ a:fg, a:bg, '', '', opts ] : [ '', '', a:fg, a:bg, opts ]

FUNCTION  airline#extensions#wordcount#apply()
Called 6 times
Total time:   0.000191
 Self time:   0.000191

count  total (s)   self (s)
    6              0.000161   if match(&ft, get(g:, 'airline#extensions#wordcount#filetypes')) > -1
                                call airline#extensions#prepend_to_section('z', '%{get(b:, "airline_wordcount", "")}')
                              endif

FUNCTION  <SNR>135_cursormoved_delayed_cb()
Called 3 times
Total time:   0.000614
 Self time:   0.000128

count  total (s)   self (s)
    3              0.000070     if getpos('.') == s:cursormoved_last_pos
    3   0.000528   0.000042         call neomake#CursorMoved()
    3              0.000005     endif

FUNCTION  <SNR>115_is_excluded_window()
Called 12 times
Total time:   0.000689
 Self time:   0.000689

count  total (s)   self (s)
   12              0.000035   for matchft in g:airline_exclude_filetypes
                                if matchft ==# &ft
                                  return 1
                                endif
                              endfor
                            
   48              0.000072   for matchw in g:airline_exclude_filenames
   36              0.000274     if matchstr(expand('%'), matchw) ==# matchw
                                  return 1
                                endif
   36              0.000031   endfor
                            
   12              0.000022   if g:airline_exclude_preview && &previewwindow
                                return 1
                              endif
                            
   12              0.000011   return 0

FUNCTION  <SNR>21_can_diffoff()
Called 1 time
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
    1              0.000009   return getwinvar(bufwinnr(a:buf), '&diff') && !empty(getbufvar(a:buf, 'git_dir')) && !empty(getwinvar(bufwinnr(a:buf), 'fugitive_diff_restore'))

FUNCTION  246()
Called 5 times
Total time:   0.000038
 Self time:   0.000038

count  total (s)   self (s)
    5              0.000035     return '^\(['.g:NERDTreeDirArrowExpandable.g:NERDTreeDirArrowCollapsible.'] \| \+['.g:NERDTreeDirArrowExpandable.g:NERDTreeDirArrowCollapsible.'] \| \+\)'

FUNCTION  remote#host#RegisterPlugin()
Called 1 time
Total time:   0.000090
 Self time:   0.000074

count  total (s)   self (s)
    1   0.000025   0.000015   let plugins = remote#host#PluginsForHost(a:host)
                            
    1              0.000002   for plugin in plugins
                                if plugin.path == a:path
                                  throw 'Plugin "'.a:path.'" is already registered'
                                endif
                              endfor
                            
    1   0.000018   0.000011   if has_key(s:hosts, a:host) && remote#host#IsRunning(a:host)
                                " For now we won't allow registration of plugins when the host is already
                                " running.
                                throw 'Host "'.a:host.'" is already running'
                              endif
                            
    1              0.000002   for spec in a:specs
                                let type = spec.type
                                let name = spec.name
                                let sync = spec.sync
                                let opts = spec.opts
                                let rpc_method = a:path
                                if type == 'command'
                                  let rpc_method .= ':command:'.name
                                  call remote#define#CommandOnHost(a:host, rpc_method, sync, name, opts)
                                elseif type == 'autocmd'
                                  " Since multiple handlers can be attached to the same autocmd event by a
                                  " single plugin, we need a way to uniquely identify the rpc method to
                                  " call.  The solution is to append the autocmd pattern to the method
                                  " name(This still has a limit: one handler per event/pattern combo, but
                                  " there's no need to allow plugins define multiple handlers in that case)
                                  let rpc_method .= ':autocmd:'.name.':'.get(opts, 'pattern', '*')
                                  call remote#define#AutocmdOnHost(a:host, rpc_method, sync, name, opts)
                                elseif type == 'function'
                                  let rpc_method .= ':function:'.name
                                  call remote#define#FunctionOnHost(a:host, rpc_method, sync, name, opts)
                                else
                                  echoerr 'Invalid declaration type: '.type
                                endif
                              endfor
                            
    1              0.000005   call add(plugins, {'path': a:path, 'specs': a:specs})

FUNCTION  <SNR>21_repo_head_ref()
Called 6 times
Total time:   0.000452
 Self time:   0.000339

count  total (s)   self (s)
    6   0.000186   0.000122   if !filereadable(self.dir('HEAD'))
                                return ''
                              endif
    6   0.000241   0.000192   return readfile(self.dir('HEAD'))[0]

FUNCTION  <SNR>7_lod_ft()
Called 1 time
Total time:   0.063989
 Self time:   0.000078

count  total (s)   self (s)
    1              0.000003   let syn = 'syntax/'.a:pat.'.vim'
    1   0.018479   0.000020   call s:lod(a:names, ['plugin', 'after/plugin'], syn, 'after/'.syn)
    1              0.000019   execute 'autocmd! PlugLOD FileType' a:pat
    1   0.043717   0.000019   call s:doautocmd('filetypeplugin', 'FileType')
    1   0.001766   0.000011   call s:doautocmd('filetypeindent', 'FileType')

FUNCTION  <SNR>21_buffer()
Called 4 times
Total time:   0.000118
 Self time:   0.000105

count  total (s)   self (s)
    4              0.000018   let buffer = {'#': bufnr(a:0 ? a:1 : '%')}
    4              0.000057   call extend(extend(buffer,s:buffer_prototype,'keep'),s:abstract_prototype,'keep')
    4   0.000035   0.000022   if buffer.getvar('git_dir') !=# ''
    4              0.000004     return buffer
                              endif
                              call s:throw('not a git repository: '.expand('%:p'))

FUNCTION  251()
Called 5 times
Total time:   0.000504
 Self time:   0.000466

count  total (s)   self (s)
    5              0.000012     let line = a:line
                                "remove the tree parts and the leading space
    5   0.000115   0.000078     let line = substitute (line, g:NERDTreeUI.MarkupReg(),"","")
                            
                                "strip off any read only flag
    5              0.000041     let line = substitute (line, ' \['.g:NERDTreeGlyphReadOnly.'\]', "","")
                            
                                "strip off any bookmark flags
    5              0.000028     let line = substitute (line, ' {[^}]*}', "","")
                            
                                "strip off any executable flags
    5              0.000030     let line = substitute (line, '*\ze\($\| \)', "","")
                            
                                "strip off any generic flags
    5              0.000030     let line = substitute (line, '\[[^]]*\]', "","")
                            
    5              0.000009     let wasdir = 0
    5              0.000022     if line =~# '/$'
    4              0.000006         let wasdir = 1
    4              0.000004     endif
    5              0.000031     let line = substitute (line,' -> .*',"","") " remove link to
    5              0.000008     if wasdir ==# 1
    4              0.000053         let line = substitute (line, '/\?$', '/', "")
    4              0.000005     endif
                            
    5              0.000009     if a:removeLeadingSpaces
    4              0.000032         let line = substitute (line, '^ *', '', '')
    4              0.000005     endif
                            
    5              0.000009     return line

FUNCTION  <SNR>20_LoadIndent()
Called 3 times
Total time:   0.004228
 Self time:   0.002498

count  total (s)   self (s)
    3              0.000010     if exists("b:undo_indent")
    2              0.000039       exe b:undo_indent
    2              0.000006       unlet! b:undo_indent b:did_indent
    2              0.000001     endif
    3              0.000012     let s = expand("<amatch>")
    3              0.000005     if s != ""
    3              0.000005       if exists("b:did_indent")
                            	unlet b:did_indent
                                  endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "indent/aaa.vim" and then "indent/bbb.vim".
    6              0.000023       for name in split(s, '\.')
    3   0.004088   0.002357 	exe 'runtime! indent/' . name . '.vim'
    3              0.000004       endfor
    3              0.000002     endif

FUNCTION  <SNR>148_path()
Called 2 times
Total time:   0.000742
 Self time:   0.000503

count  total (s)   self (s)
    2   0.000298   0.000059   let conn = s:connect(0)
                            
    2              0.000021   let projts = getftime(b:salve.local_manifest)
    2              0.000023   let profts = getftime(b:salve.global_manifest)
    2              0.000079   let cache = expand(g:classpath_cache . '/') . substitute(b:salve.root, '[:\/]', '%', 'g')
                            
    2              0.000018   let ts = getftime(cache)
    2              0.000005   if ts > projts && ts > profts
    2              0.000135     let path = split(get(readfile(cache), 0, ''), ',')
                            
    2              0.000005   elseif has_key(conn, 'path')
                                let ts = +get(conn.eval('(.getStartTime (java.lang.management.ManagementFactory/getRuntimeMXBean))', {'session': '', 'ns': 'user'}), 'value', '-2000')[0:-4]
                                if ts > projts && ts > profts
                                  let response = conn.eval( '[(System/getProperty "path.separator") (or (System/getProperty "fake.class.path") (System/getProperty "java.class.path"))]', {'session': '', 'ns': 'user'})
                                  let path = split(eval(response.value[5:-2]), response.value[2])
                                  call writefile([join(path, ',')], cache)
                                endif
                              endif
                            
    2              0.000006   if !exists('path')
                                let path = s:scrape_path(b:salve.root)
                                if empty(path)
                                  let path = map(['test', 'src', 'dev-resources', 'resources'], 'b:salve.root."/".v:val')
                                endif
                                call writefile([join(path, ',')], cache)
                              endif
                            
    2              0.000003   return path

FUNCTION  <SNR>50_addtomrufs()
Called 2 times
Total time:   0.019459
 Self time:   0.000431

count  total (s)   self (s)
    2              0.000093 	let fn = fnamemodify(a:fname, ':p')
    2              0.000014 	let fn = exists('+ssl') ? tr(fn, '/', '\') : fn
    2              0.000117 	if ( !empty({s:in}) && fn !~# {s:in} ) || ( !empty({s:ex}) && fn =~# {s:ex} ) || !empty(getbufvar('^'.fn.'$', '&bt')) || !filereadable(fn) | retu
                            	en
    2              0.000014 	let idx = index(s:mrufs, fn, 0, !{s:cseno})
    2              0.000003 	if idx
    1              0.000005 		cal filter(s:mrufs, 'v:val !='.( {s:cseno} ? '#' : '?' ).' fn')
    1              0.000002 		cal insert(s:mrufs, fn)
    1              0.000003 		if {s:soup} && idx < 0
    1   0.019183   0.000155 			cal s:savetofile(s:mergelists())
    1              0.000002 		en
    1              0.000001 	en

FUNCTION  airline#extensions#apply()
Called 12 times
Total time:   0.002877
 Self time:   0.001202

count  total (s)   self (s)
   12              0.000035   let s:active_winnr = winnr()
                            
   12   0.000751   0.000063   if s:is_excluded_window()
                                return -1
                              endif
                            
   12              0.000028   if &buftype == 'help'
                                call airline#extensions#apply_left_override('Help', '%f')
                                let w:airline_section_x = ''
                                let w:airline_section_y = ''
                                let w:airline_render_right = 1
                              endif
                            
   12              0.000016   if &previewwindow
                                let w:airline_section_a = 'Preview'
                                let w:airline_section_b = ''
                                let w:airline_section_c = bufname(winbufnr(winnr()))
                              endif
                            
   12              0.000068   if has_key(s:filetype_overrides, &ft)
    4              0.000018     let args = s:filetype_overrides[&ft]
    4   0.001026   0.000040     call airline#extensions#apply_left_override(args[0], args[1])
    4              0.000004   endif
                            
   12              0.000045   for item in items(s:filetype_regex_overrides)
                                if match(&ft, item[0]) >= 0
                                  call airline#extensions#apply_left_override(item[1][0], item[1][1])
                                endif
                              endfor

FUNCTION  <SNR>21_repo_tree()
Called 3 times
Total time:   0.000104
 Self time:   0.000078

count  total (s)   self (s)
    3   0.000036   0.000021   if self.dir() =~# '/\.git$'
    3   0.000023   0.000012     let dir = self.dir()[0:-6]
    3              0.000007     if dir !~# '/'
                                  let dir .= '/'
                                endif
    3              0.000002   else
                                let dir = s:configured_tree(self.git_dir)
                              endif
    3              0.000004   if dir ==# ''
                                call s:throw('no work tree')
                              else
    3              0.000009     return join([dir]+a:000,'/')
                              endif

FUNCTION  airline#statusline()
Called 14 times
Total time:   0.000322
 Self time:   0.000322

count  total (s)   self (s)
   14              0.000140   if has_key(s:contexts, a:winnr)
   14              0.000148     return '%{airline#check_mode('.a:winnr.')}'.s:contexts[a:winnr].line
                              endif
                            
                              " in rare circumstances this happens...see #276
                              return ''

FUNCTION  260()
Called 1 time
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    1              0.000002     return '.. (up a dir)'

FUNCTION  <SNR>120_update_hg_branch()
Called 6 times
Total time:   0.000340
 Self time:   0.000340

count  total (s)   self (s)
                              " path argument is not actually used, so we don't actually care about a:1
                              " it is just needed, because update_git_branch needs it.
    6              0.000013   if s:has_lawrencium
                                let cmd='LC_ALL=C hg qtop'
                                let stl=lawrencium#statusline()
                                let file=expand('%:p')
                                if !empty(stl) && get(b:, 'airline_do_mq_check', 1)
                                  if g:airline#init#vim_async
                                    call airline#async#get_mq_async(cmd, file)
                                  elseif has("nvim")
                                    call airline#async#nvim_get_mq_async(cmd, file)
                                  else
                                    " remove \n at the end of the command
                                    let output=system(cmd)[0:-2]
                                    call airline#async#mq_output(output, file)
                                  endif
                                endif
                                " do not do mq check anymore
                                let b:airline_do_mq_check = 0
                                if exists("b:mq") && !empty(b:mq)
                                  if stl is# 'default'
                                    " Shorten default a bit
                                    let stl='def'
                                  endif
                                  let stl.=' ['.b:mq.']'
                                endif
                                let s:vcs_config['mercurial'].branch = stl
                              else
    6              0.000024     let s:vcs_config['mercurial'].branch = ''
    6              0.000007   endif

FUNCTION  <SNR>148_detect()
Called 2 times
Total time:   0.003276
 Self time:   0.003276

count  total (s)   self (s)
    2              0.000008   if !exists('b:salve')
    1              0.000040     let root = simplify(fnamemodify(a:file, ':p:s?[\/]$??'))
    1              0.000011     if !isdirectory(fnamemodify(root, ':h'))
                                  return ''
                                endif
    1              0.000003     let previous = ""
    4              0.000012     while root !=# previous
    4              0.002887       if filereadable(root . '/project.clj') && join(readfile(root . '/project.clj', '', 50)) =~# '(\s*defproject\%(\s*{{\)\@!'
    1              0.000065         let b:salve = { "local_manifest": root.'/project.clj', "global_manifest": expand('~/.lein/profiles.clj'), "root": root, "compiler": "lein", "repl_cmd": "lein repl", "classpath_cmd": "lein -o classpath", "start_cmd": "lein run" }
    1              0.000004         let b:java_root = root
    1              0.000003         break
                                  elseif filereadable(root . '/build.boot')
                                    if $BOOT_HOME
                                      let boot_home = $BOOT_HOME
                                    else
                                      let boot_home = expand('~/.boot')
                                    endif
                                    let b:salve = { "local_manifest": root.'/build.boot', "global_manifest": boot_home.'/.profile.boot', "root": root, "compiler": "boot", "repl_cmd": "boot repl", "classpath_cmd": "boot show --fake-classpath", "start_cmd": "boot repl -s" }
                                    let b:java_root = root
                                    break
                                  endif
    3              0.000009       let previous = root
    3              0.000016       let root = fnamemodify(root, ':h')
    3              0.000005     endwhile
    1              0.000002   endif
    2              0.000008   return exists('b:salve')

FUNCTION  airline#highlighter#get_highlight()
Called 376 times
Total time:   0.051125
 Self time:   0.021569

count  total (s)   self (s)
  376              0.001579   if get(g:, 'airline_highlighting_cache', 0) && has_key(s:hl_groups, a:group)
                                return s:hl_groups[a:group]
                              else
  376   0.015518   0.002352     let fg = s:get_syn(a:group, 'fg')
  376   0.014766   0.001993     let bg = s:get_syn(a:group, 'bg')
  376              0.004849     let reverse = g:airline_gui_mode ==# 'gui' ? synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'gui') : synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'cterm')|| synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'term')
  376              0.001970     let bold = synIDattr(synIDtrans(hlID(a:group)), 'bold')
  376              0.000653     let opts = a:000
  376              0.000435     if bold
   17              0.000033       let opts = ['bold']
   17              0.000014     endif
  376   0.006487   0.002871     let res = reverse ? s:get_array(bg, fg, opts) : s:get_array(fg, bg, opts)
  376              0.000352   endif
  376              0.001327   let s:hl_groups[a:group] = res
  376              0.000474   return res

FUNCTION  airline#util#shorten()
Called 14 times
Total time:   0.000369
 Self time:   0.000369

count  total (s)   self (s)
   14              0.000086   if winwidth(0) < a:winwidth && len(split(a:text, '\zs')) > a:minwidth
                                if get(a:000, 0, 0)
                                  " shorten from tail
                                  return '…'.matchstr(a:text, '.\{'.a:minwidth.'}$')
                                else
                                  " shorten from beginning of string
                                  return matchstr(a:text, '^.\{'.a:minwidth.'}').'…'
                                endif
                              else
   14              0.000025     return a:text
                              endif

FUNCTION  SlimvInitBuffer()
Called 1 time
Total time:   0.000567
 Self time:   0.000534

count  total (s)   self (s)
                                " Map space to display function argument list in status line
    1   0.000016   0.000007     if SlimvGetFiletype() == 'r'
                                    inoremap <silent> <buffer> (          (<C-R>=SlimvArglist()<CR>
                                else
    1              0.000003         if !exists("g:slimv_unmap_space") || g:slimv_unmap_space == 0
    1              0.000018             inoremap <silent> <buffer> <Space>    <Space><C-R>=SlimvArglist()<CR>
    1              0.000001         endif
    1              0.000002         if !exists("g:slimv_unmap_cr") || g:slimv_unmap_cr == 0
    1              0.000010             inoremap <silent> <buffer> <CR>       <C-R>=pumvisible() ?  "\<lt>C-Y>" : SlimvHandleEnter()<CR><C-R>=SlimvArglistOnEnter()<CR>
    1              0.000001         endif
    1              0.000001     endif
                                "noremap  <silent> <buffer> <C-C>      :call SlimvInterrupt()<CR>
    1              0.000005     augroup SlimvInsertLeave
    1              0.000306         au!
    1              0.000022         au InsertEnter * :let s:save_showmode=&showmode
    1              0.000006         au InsertLeave * :let &showmode=s:save_showmode
    1              0.000010     augroup END
    1              0.000019     inoremap <silent> <buffer> <C-X>0     <C-O>:call SlimvCloseForm()<CR>
    1              0.000005     if !exists("g:slimv_unmap_tab") || g:slimv_unmap_tab == 0
    1              0.000012         inoremap <silent> <buffer> <Tab>      <C-R>=SlimvHandleTab()<CR>
    1              0.000002     endif
    1              0.000013     inoremap <silent> <buffer> <S-Tab>    <C-R>=pumvisible() ? "\<lt>C-P>" : "\<lt>S-Tab>"<CR>
    1              0.000004     if g:slimv_tags_file != ''
    1              0.000011         nnoremap <silent> <buffer> <C-]>      :call SlimvFindDefinitions()<CR>
    1              0.000001     endif
                            
                                " Setup balloonexp to display symbol description
    1              0.000007     if g:slimv_balloon && has( 'balloon_eval' )
                                    "setlocal balloondelay=100
                                    setlocal ballooneval
                                    setlocal balloonexpr=SlimvDescribe(v:beval_text)
                                endif
                                " This is needed for safe switching of modified buffers
    1              0.000014     set hidden
    1   0.000062   0.000040     call s:MakeWindowId()

FUNCTION  270()
Called 12 times
Total time:   0.000055
 Self time:   0.000055

count  total (s)   self (s)
   12              0.000049   call add(self._sections, ['|', a:0 ? a:1 : '%='])

FUNCTION  272()
Called 58 times
Total time:   0.000251
 Self time:   0.000251

count  total (s)   self (s)
   58              0.000227   call add(self._sections, [a:group, a:contents])

FUNCTION  274()
Called 12 times
Total time:   0.050628
 Self time:   0.007539

count  total (s)   self (s)
   12              0.000018   let side = 1
   12              0.000016   let line = ''
   12              0.000016   let i = 0
   12              0.000030   let length = len(self._sections)
   12              0.000017   let split = 0
   12              0.000018   let is_empty = 0
   12              0.000018   let prev_group = ''
                            
   82              0.000141   while i < length
   70              0.000172     let section = self._sections[i]
   70              0.000143     let group = section[0]
   70              0.000135     let contents = section[1]
   70              0.000120     let pgroup = prev_group
   70   0.001367   0.000445     let prev_group = s:get_prev_group(self._sections, i)
   70              0.000215     if group ==# 'airline_c' && &buftype ==# 'terminal' && self._context.active
                                  let group = 'airline_term'
                                elseif group ==# 'airline_c' && !self._context.active && has_key(self._context, 'bufnr')
    4              0.000009       let group = 'airline_c'. self._context.bufnr
    4              0.000010     elseif prev_group ==# 'airline_c' && !self._context.active && has_key(self._context, 'bufnr')
    4              0.000009       let prev_group = 'airline_c'. self._context.bufnr
    4              0.000003     endif
   70              0.000079     if is_empty
                                  let prev_group = pgroup
                                endif
   70   0.001295   0.000399     let is_empty = s:section_is_empty(self, contents)
                            
   70              0.000072     if is_empty
                                  " need to fix highlighting groups, since we
                                  " have skipped a section, we actually need
                                  " the previous previous group and so the
                                  " seperator goes from the previous previous group
                                  " to the current group
                                  let pgroup = group
                                endif
                            
   70              0.000112     if group == ''
                                  let line .= contents
                                elseif group == '|'
   12              0.000014       let side = 0
   12              0.000027       let line .= contents
   12              0.000013       let split = 1
   12              0.000010     else
   58              0.000089       if prev_group == ''
   12              0.000044         let line .= '%#'.group.'#'
   12              0.000013       elseif split
    6              0.000006         if !is_empty
    6   0.003614   0.000056           let line .= s:get_transitioned_seperator(self, prev_group, group, side)
    6              0.000006         endif
    6              0.000009         let split = 0
    6              0.000005       else
   40              0.000045         if !is_empty
   40   0.034526   0.000361           let line .= s:get_seperator(self, prev_group, group, side)
   40              0.000041         endif
   40              0.000029       endif
   58   0.004126   0.000577       let line .= is_empty ? '' : s:get_accented_line(self, group, contents)
   58              0.000054     endif
                            
   70              0.000127     let i = i + 1
   70              0.000082   endwhile
                            
   12              0.000022   if !self._context.active
                                "let line = substitute(line, '%#airline_c#', '%#airline_c'.self._context.bufnr.'#', '')
    6              0.000219     let line = substitute(line, '%#.\{-}\ze#', '\0_inactive', 'g')
    6              0.000006   endif
   12              0.000020   return line

FUNCTION  BookmarkLoad()
Called 1 time
Total time:   0.000169
 Self time:   0.000101

count  total (s)   self (s)
    1              0.000006   let supports_confirm = has("dialog_con") || has("dialog_gui")
    1   0.000061   0.000009   let has_bookmarks = bm#total_count() ># 0
    1              0.000001   let confirmed = 1
    1              0.000002   if (supports_confirm && has_bookmarks && !a:silent)
                                let confirmed = confirm("Do you want to override your ". bm#total_count() ." bookmarks?", "&Yes\n&No")
                              endif
    1              0.000001   if (confirmed ==# 1)
    1   0.000024   0.000008     call s:remove_all_bookmarks()
    1              0.000001     try
    1              0.000030       let data = readfile(a:target_file)
                                  let new_entries = bm#deserialize(data)
                                  if !a:startup
                                    for entry in new_entries
                                      call bm_sign#add_at(entry['file'], entry['sign_idx'], entry['line_nr'], entry['annotation'] !=# "")
                                    endfor
                                    if (!a:silent)
                                      echo "Bookmarks loaded"
                                    endif
                                    return 1
                                  endif
                                catch
    1              0.000002       if (!a:startup && !a:silent)
                                    echo "Failed to load/parse file"
                                  endif
    1              0.000002       return 0
                                endtry
                              endif

FUNCTION  242()
Called 4 times
Total time:   0.000160
 Self time:   0.000152

count  total (s)   self (s)
                                "have to do this work around because match() returns bytes, not chars
    4              0.000055     let numLeadBytes = match(a:line, '\M\[^ '.g:NERDTreeDirArrowExpandable.g:NERDTreeDirArrowCollapsible.']')
                                " The next line is a backward-compatible workaround for strchars(a:line(0:numLeadBytes-1]). strchars() is in 7.3+
    4              0.000055     let leadChars = len(split(a:line[0:numLeadBytes-1], '\zs'))
                            
    4   0.000038   0.000029     return leadChars / s:UI.IndentWid()

FUNCTION  airline#highlighter#highlight_modified_inactive()
Called 2 times
Total time:   0.000441
 Self time:   0.000063

count  total (s)   self (s)
    2              0.000009   if getbufvar(a:bufnr, '&modified')
                                let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c : []
                              else
    2              0.000020     let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive.airline_c : []
    2              0.000001   endif
                            
    2              0.000003   if !empty(colors)
    2   0.000395   0.000018     call airline#highlighter#exec('airline_c'.(a:bufnr).'_inactive', colors)
    2              0.000001   endif

FUNCTION  243()
Called 4 times
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
    4              0.000006     return 2

FUNCTION  <SNR>148_portfile()
Called 2 times
Total time:   0.000151
 Self time:   0.000151

count  total (s)   self (s)
    2              0.000006   if !exists('b:salve')
                                return ''
                              endif
                            
    2              0.000006   let root = b:salve.root
    2              0.000013   let portfiles = [root.'/.nrepl-port', root.'/target/repl-port', root.'/target/repl/repl-port']
                            
    8              0.000016   for f in portfiles
    6              0.000065     if getfsize(f) > 0
                                  return f
                                endif
    6              0.000005   endfor
    2              0.000003   return ''

FUNCTION  airline#extensions#branch#get_head()
Called 6 times
Total time:   0.011522
 Self time:   0.000214

count  total (s)   self (s)
    6   0.011373   0.000065   let head = airline#extensions#branch#head()
    6              0.000037   let empty_message = get(g:, 'airline#extensions#branch#empty_message', '')
    6              0.000039   let symbol = get(g:, 'airline#extensions#branch#symbol', g:airline_symbols.branch)
    6              0.000062   return empty(head) ? empty_message : printf('%s%s', empty(symbol) ? '' : symbol.(g:airline_symbols.space), head)

FUNCTION  <SNR>10_DetectElixir()
Called 1 time
Total time:   0.000014
 Self time:   0.000014

count  total (s)   self (s)
    1              0.000009   if getline(1) =~ '^#!.*\<elixir\>'
                                call s:setf('elixir')
                              endif

FUNCTION  <SNR>21_repo_head()
Called 6 times
Total time:   0.001142
 Self time:   0.000321

count  total (s)   self (s)
    6   0.000754   0.000080     let head = s:repo().head_ref()
                            
    6              0.000078     if head =~# '^ref: '
    6   0.000211   0.000064       let branch = s:sub(head,'^ref: %(refs/%(heads/|remotes/|tags/)=)=','')
    6              0.000013     elseif head =~# '^\x\{40\}$'
                                  " truncate hash to a:1 characters if we're in detached head mode
                                  let len = a:0 ? a:1 : 0
                                  let branch = len ? head[0:len-1] : ''
                                else
                                  return ''
                                endif
                            
    6              0.000010     return branch

FUNCTION  nerdtree#ui_glue#invokeKeyMap()
Called 1 time
Total time:  14.399031
 Self time:   0.000025

count  total (s)   self (s)
    1  14.399027   0.000021     call g:NERDTreeKeyMap.Invoke(a:key)

FUNCTION  <SNR>9_DetectScala()
Called 1 time
Total time:   0.000027
 Self time:   0.000027

count  total (s)   self (s)
    1              0.000021     if getline(1) =~# '^#!\(/usr\)\?/bin/env\s\+scalas\?'
                                    set filetype=scala
                                endif

FUNCTION  SlimvAutodetect()
Called 1 time
Total time:   0.000103
 Self time:   0.000103

count  total (s)   self (s)
                                " Firts try the most basic setup: everything in the path
    1              0.000094     if executable( 'lein' )
    1              0.000005         return ['"lein repl"', 'clojure']
                                endif
                                if executable( 'cake' )
                                    return ['"cake repl"', 'clojure']
                                endif
                                if executable( 'clojure' )
                                    return ['clojure', 'clojure']
                                endif
                                let lisps = []
                                if executable( 'clojure.jar' )
                                    let lisps = ['clojure.jar']
                                endif
                                if executable( 'clojure-contrib.jar' )
                                    let lisps = lisps + 'clojure-contrib.jar'
                                endif
                                if len( lisps ) > 0
                                    return s:BuildStartCmd( lisps )
                                endif
                            
                                " Check if Clojure is bundled with Slimv
                                let lisps = split( globpath( &runtimepath, 'swank-clojure/clojure*.jar'), '\n' )
                                if len( lisps ) > 0
                                    return s:BuildStartCmd( lisps )
                                endif
                            
                                " Try to find Clojure in the PATH
                                let path = substitute( $PATH, ';', ',', 'g' )
                                let lisps = split( globpath( path, 'clojure*.jar' ), '\n' )
                                if len( lisps ) > 0
                                    return s:BuildStartCmd( lisps )
                                endif
                            
                                if g:slimv_windows
                                    " Try to find Clojure on the standard installation places
                                    let lisps = split( globpath( 'c:/*clojure*,c:/*clojure*/lib', 'clojure*.jar' ), '\n' )
                                    if len( lisps ) > 0
                                        return s:BuildStartCmd( lisps )
                                    endif
                                else
                                    " Try to find Clojure in the home directory
                                    let lisps = split( globpath( '/usr/local/bin/*clojure*', 'clojure*.jar' ), '\n' )
                                    if len( lisps ) > 0
                                        return s:BuildStartCmd( lisps )
                                    endif
                                    let lisps = split( globpath( '~/*clojure*', 'clojure*.jar' ), '\n' )
                                    if len( lisps ) > 0
                                        return s:BuildStartCmd( lisps )
                                    endif
                                endif
                            
                                return ['', '']

FUNCTION  <SNR>121_check_mixed_indent_file()
Called 1 time
Total time:   0.000061
 Self time:   0.000061

count  total (s)   self (s)
    1              0.000009   let c_like_langs = get(g:, 'airline#extensions#c_like_langs', [ 'c', 'cpp', 'cuda', 'go', 'javascript', 'ld', 'php' ])
    1              0.000006   if index(c_like_langs, &ft) > -1
                                " for C-like languages: allow /** */ comment style with one space before the '*'
                                let head_spc = '\v(^ +\*@!)'
                              else
    1              0.000003     let head_spc = '\v(^ +)'
    1              0.000001   endif
    1              0.000014   let indent_tabs = search('\v(^\t+)', 'nw')
    1              0.000013   let indent_spc  = search(head_spc, 'nw')
    1              0.000003   if indent_tabs > 0 && indent_spc > 0
                                return printf("%d:%d", indent_tabs, indent_spc)
                              else
    1              0.000001     return ''
                              endif

FUNCTION  unite#sources#buffer#variables#append()
Called 2 times
Total time:   0.000028
 Self time:   0.000028

count  total (s)   self (s)
                              " Append the current buffer.
    2              0.000024   let s:buffer_list[a:bufnr] = { 'action__buffer_nr' : a:bufnr, 'source__time' : localtime(), }

FUNCTION  <SNR>12_DetectAPIBlueprint()
Called 1 time
Total time:   0.000025
 Self time:   0.000025

count  total (s)   self (s)
    1              0.000019   if getline(1) =~ '^FORMAT: 1A$'
                                set filetype=apiblueprint
                              endif

FUNCTION  PareditInitBuffer()
Called 2 times
Total time:   0.002931
 Self time:   0.001582

count  total (s)   self (s)
    2              0.000006     let b:paredit_init = 1
                                " in case they are accidentally removed
                                " Also define regular expressions to identify special characters used by paredit
    2              0.000049     if &ft =~ s:fts_balancing_all_brackets
    2              0.000007         let b:any_matched_char   = '(\|)\|\[\|\]\|{\|}\|\"'
    2              0.000005         let b:any_matched_pair   = '()\|\[\]\|{}\|\"\"'
    2              0.000004         let b:any_opening_char   = '(\|\[\|{'
    2              0.000004         let b:any_closing_char   = ')\|\]\|}'
    2              0.000004         let b:any_openclose_char = '(\|)\|\[\|\]\|{\|}'
    2              0.000004         let b:any_wsopen_char    = '\s\|(\|\[\|{'
    2              0.000004         let b:any_wsclose_char   = '\s\|)\|\]\|}'
    2              0.000002     else
                                    let b:any_matched_char   = '(\|)\|\"'
                                    let b:any_matched_pair   = '()\|\"\"'
                                    let b:any_opening_char   = '('
                                    let b:any_closing_char   = ')'
                                    let b:any_openclose_char = '(\|)'
                                    let b:any_wsopen_char    = '\s\|('
                                    let b:any_wsclose_char   = '\s\|)'
                                endif
                            
    2              0.000003     if g:paredit_mode
                                    " Paredit mode is on: add buffer specific keybindings
    2              0.000064         inoremap <buffer> <expr>   (            PareditInsertOpening('(',')')
    2              0.000027         inoremap <buffer> <silent> )            <C-R>=PareditInsertClosing('(',')')<CR>
    2              0.000019         inoremap <buffer> <expr>   "            PareditInsertQuotes()
    2              0.000021         inoremap <buffer> <expr>   <BS>         PareditBackspace(0)
    2              0.000023         inoremap <buffer> <expr>   <C-h>        PareditBackspace(0)
    2              0.000018         inoremap <buffer> <expr>   <Del>        PareditDel()
    2              0.000036         if &ft =~ s:fts_balancing_all_brackets && g:paredit_smartjump
                                        noremap  <buffer> <silent> (            :<C-U>call PareditSmartJumpOpening(0)<CR>
                                        noremap  <buffer> <silent> )            :<C-U>call PareditSmartJumpClosing(0)<CR>
                                        vnoremap <buffer> <silent> (            <Esc>:<C-U>call PareditSmartJumpOpening(1)<CR>
                                        vnoremap <buffer> <silent> )            <Esc>:<C-U>call PareditSmartJumpClosing(1)<CR>
                                    else
    2              0.000026             noremap  <buffer> <silent> (            :<C-U>call PareditFindOpening('(',')',0)<CR>
    2              0.000019             noremap  <buffer> <silent> )            :<C-U>call PareditFindClosing('(',')',0)<CR>
    2              0.000020             vnoremap <buffer> <silent> (            <Esc>:<C-U>call PareditFindOpening('(',')',1)<CR>
    2              0.000019             vnoremap <buffer> <silent> )            <Esc>:<C-U>call PareditFindClosing('(',')',1)<CR>
    2              0.000002         endif
    2              0.000019         noremap  <buffer> <silent> [[           :<C-U>call PareditFindDefunBck()<CR>
    2              0.000019         noremap  <buffer> <silent> ]]           :<C-U>call PareditFindDefunFwd()<CR>
                            
    2   0.000118   0.000025         call RepeatableNNoRemap('x', ':<C-U>call PareditEraseFwd()')
    2              0.000023         nnoremap <buffer> <silent> <Del>        :<C-U>call PareditEraseFwd()<CR>
    2   0.000085   0.000013         call RepeatableNNoRemap('X', ':<C-U>call PareditEraseBck()')
    2              0.000020         nnoremap <buffer> <silent> s            :<C-U>call PareditEraseFwd()<CR>i
    2   0.000082   0.000011         call RepeatableNNoRemap('D', 'v$:<C-U>call PareditDelete(visualmode(),1)')
    2              0.000021         nnoremap <buffer> <silent> C            v$:<C-U>call PareditChange(visualmode(),1)<CR>
    2              0.000019         nnoremap <buffer> <silent> d            :<C-U>call PareditSetDelete(v:count)<CR>g@
    2              0.000020         vnoremap <buffer> <silent> d            :<C-U>call PareditDelete(visualmode(),1)<CR>
    2              0.000018         vnoremap <buffer> <silent> x            :<C-U>call PareditDelete(visualmode(),1)<CR>
    2              0.000020         vnoremap <buffer> <silent> <Del>        :<C-U>call PareditDelete(visualmode(),1)<CR>
    2              0.000018         nnoremap <buffer> <silent> c            :set opfunc=PareditChange<CR>g@
    2              0.000018         vnoremap <buffer> <silent> c            :<C-U>call PareditChange(visualmode(),1)<CR>
    2   0.000086   0.000012         call RepeatableNNoRemap('dd', ':<C-U>call PareditDeleteLines()')
    2              0.000020         nnoremap <buffer> <silent> cc           :<C-U>call PareditChangeLines()<CR>
    2              0.000019         nnoremap <buffer> <silent> cw           :<C-U>call PareditChangeSpec('cw',1)<CR>
    2              0.000018         nnoremap <buffer> <silent> cW           :set opfunc=PareditChange<CR>g@E
    2              0.000019         nnoremap <buffer> <silent> cb           :<C-U>call PareditChangeSpec('cb',0)<CR>
    2              0.000019         nnoremap <buffer> <silent> ciw          :<C-U>call PareditChangeSpec('ciw',1)<CR>
    2              0.000018         nnoremap <buffer> <silent> caw          :<C-U>call PareditChangeSpec('caw',1)<CR>
    2   0.000089   0.000013         call RepeatableNNoRemap('p', ':<C-U>call PareditPut("p")')
    2   0.000084   0.000011         call RepeatableNNoRemap('P', ':<C-U>call PareditPut("P")')
    2   0.000100   0.000014         call RepeatableNNoRemap(g:paredit_leader . 'w(', ':<C-U>call PareditWrap("(",")")')
    2              0.000036         execute 'vnoremap <buffer> <silent> ' . g:paredit_leader.'w(  :<C-U>call PareditWrapSelection("(",")")<CR>'
    2   0.000099   0.000018         call RepeatableNNoRemap(g:paredit_leader . 'w"', ':<C-U>call PareditWrap('."'".'"'."','".'"'."')")
    2              0.000038         execute 'vnoremap <buffer> <silent> ' . g:paredit_leader.'w"  :<C-U>call PareditWrapSelection('."'".'"'."','".'"'."')<CR>"
                                    " Spliec s-expression killing backward/forward
    2              0.000031         execute 'nmap     <buffer> <silent> ' . g:paredit_leader.'<Up>    d[(:<C-U>call PareditSplice()<CR>'
    2              0.000029         execute 'nmap     <buffer> <silent> ' . g:paredit_leader.'<Down>  d])%:<C-U>call PareditSplice()<CR>'
    2   0.000096   0.000013         call RepeatableNNoRemap(g:paredit_leader . 'I', ':<C-U>call PareditRaise()')
    2              0.000031         if &ft =~ s:fts_balancing_all_brackets
    2              0.000022             inoremap <buffer> <expr>   [            PareditInsertOpening('[',']')
    2              0.000020             inoremap <buffer> <silent> ]            <C-R>=PareditInsertClosing('[',']')<CR>
    2              0.000016             inoremap <buffer> <expr>   {            PareditInsertOpening('{','}')
    2              0.000017             inoremap <buffer> <silent> }            <C-R>=PareditInsertClosing('{','}')<CR>
    2   0.000095   0.000014             call RepeatableNNoRemap(g:paredit_leader . 'w[', ':<C-U>call PareditWrap("[","]")')
    2              0.000034             execute 'vnoremap <buffer> <silent> ' . g:paredit_leader.'w[  :<C-U>call PareditWrapSelection("[","]")<CR>'
    2   0.000095   0.000016             call RepeatableNNoRemap(g:paredit_leader . 'w{', ':<C-U>call PareditWrap("{","}")')
    2              0.000035             execute 'vnoremap <buffer> <silent> ' . g:paredit_leader.'w{  :<C-U>call PareditWrapSelection("{","}")<CR>'
    2              0.000003         endif
                            
    2              0.000004         if g:paredit_shortmaps
                                        " Shorter keymaps: old functionality of KEY is remapped to <Leader>KEY
                                        call RepeatableNNoRemap('<', ':<C-U>call PareditMoveLeft()') 
                                        call RepeatableNNoRemap('>', ':<C-U>call PareditMoveRight()') 
                                        call RepeatableNNoRemap('O', ':<C-U>call PareditSplit()') 
                                        call RepeatableNNoRemap('J', ':<C-U>call PareditJoin()') 
                                        call RepeatableNNoRemap('W', ':<C-U>call PareditWrap("(",")")') 
                                        vnoremap <buffer> <silent> W            :<C-U>call PareditWrapSelection('(',')')<CR>
                                        call RepeatableNNoRemap('S', ':<C-U>call PareditSplice()') 
                                        execute 'nnoremap <buffer> <silent> ' . g:paredit_leader.'<  :<C-U>normal! <<CR>'
                                        execute 'nnoremap <buffer> <silent> ' . g:paredit_leader.'>  :<C-U>normal! ><CR>'
                                        execute 'nnoremap <buffer> <silent> ' . g:paredit_leader.'O  :<C-U>normal! O<CR>'
                                        execute 'nnoremap <buffer> <silent> ' . g:paredit_leader.'J  :<C-U>normal! J<CR>'
                                        execute 'nnoremap <buffer> <silent> ' . g:paredit_leader.'W  :<C-U>normal! W<CR>'
                                        execute 'vnoremap <buffer> <silent> ' . g:paredit_leader.'W  :<C-U>normal! W<CR>'
                                        execute 'nnoremap <buffer> <silent> ' . g:paredit_leader.'S  :<C-U>normal! S<CR>'
                                    else
                                        " Longer keymaps with <Leader> prefix
    2              0.000022             nnoremap <buffer> <silent> S            V:<C-U>call PareditChange(visualmode(),1)<CR>
    2   0.000099   0.000015             call RepeatableNNoRemap(g:paredit_leader . '<', ':<C-U>call PareditMoveLeft()') 
    2   0.000106   0.000013             call RepeatableNNoRemap(g:paredit_leader . '>', ':<C-U>call PareditMoveRight()') 
    2   0.000092   0.000013             call RepeatableNNoRemap(g:paredit_leader . 'O', ':<C-U>call PareditSplit()') 
    2   0.000086   0.000012             call RepeatableNNoRemap(g:paredit_leader . 'J', ':<C-U>call PareditJoin()') 
    2   0.000083   0.000011             call RepeatableNNoRemap(g:paredit_leader . 'W', ':<C-U>call PareditWrap("(",")")') 
    2              0.000036             execute 'vnoremap <buffer> <silent> ' . g:paredit_leader.'W  :<C-U>call PareditWrapSelection("(",")")<CR>'
    2   0.000090   0.000013             call RepeatableNNoRemap(g:paredit_leader . 'S', ':<C-U>call PareditSplice()') 
    2              0.000003         endif
                            
    2              0.000032         if g:paredit_electric_return && mapcheck( "<CR>", "i" ) == ""
                                        " Do not override any possible mapping for <Enter>
                                        inoremap <buffer> <expr>   <CR>         PareditEnter()
                                    endif
    2              0.000002     else
                                    " Paredit mode is off: remove keybindings
                                    silent! iunmap <buffer> (
                                    silent! iunmap <buffer> )
                                    silent! iunmap <buffer> "
                                    silent! iunmap <buffer> <BS>
                                    silent! iunmap <buffer> <C-h>
                                    silent! iunmap <buffer> <Del>
                                    silent! unmap  <buffer> (
                                    silent! unmap  <buffer> )
                                    silent! unmap  <buffer> [[
                                    silent! unmap  <buffer> ]]
                                    silent! unmap  <buffer> x
                                    silent! unmap  <buffer> <Del>
                                    silent! unmap  <buffer> X
                                    silent! unmap  <buffer> s
                                    silent! unmap  <buffer> D
                                    silent! unmap  <buffer> C
                                    silent! unmap  <buffer> d
                                    silent! unmap  <buffer> c
                                    silent! unmap  <buffer> dd
                                    silent! unmap  <buffer> cc
                                    silent! unmap  <buffer> cw
                                    silent! unmap  <buffer> cW
                                    silent! unmap  <buffer> cb
                                    silent! unmap  <buffer> ciw
                                    silent! unmap  <buffer> caw
                                    if &ft =~ s:fts_balancing_all_brackets
                                        silent! iunmap <buffer> [
                                        silent! iunmap <buffer> ]
                                        silent! iunmap <buffer> {
                                        silent! iunmap <buffer> }
                                    endif
                                    if mapcheck( "<CR>", "i" ) == "PareditEnter()"
                                        " Remove only if we have added this mapping
                                        silent! iunmap <buffer> <CR>
                                    endif
                                endif

FUNCTION  airline#builder#new()
Called 12 times
Total time:   0.000375
 Self time:   0.000375

count  total (s)   self (s)
   12              0.000076   let builder = copy(s:prototype)
   12              0.000030   let builder._context = a:context
   12              0.000025   let builder._sections = []
                            
   12              0.000200   call extend(builder._context, { 'left_sep': g:airline_left_sep, 'left_alt_sep': g:airline_left_alt_sep, 'right_sep': g:airline_right_sep, 'right_alt_sep': g:airline_right_alt_sep, }, 'keep')
   12              0.000019   return builder

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
    1  14.399031   0.000025  nerdtree#ui_glue#invokeKeyMap()
    1  14.399006   0.000108  77()
    1  14.394059   0.000039  76()
    1  14.394020   0.000020  <SNR>74_activateFileNode()
    1  14.394000   0.000037  105()
    1  14.393963   0.000029  122()
    1  14.393856   0.000019  175()
    1  14.393837   0.000046  176()
    1  14.343760   0.005107  16()
    2  14.156340  14.155607  classpath#detect()
    9   0.064091   0.000361  <SNR>51_on_window_changed()
    1   0.063989   0.000078  <SNR>7_lod_ft()
    6   0.063708   0.000777  airline#update_statusline()
   12   0.062879   0.000740  <SNR>52_invoke_funcrefs()
   14   0.051426   0.002123  airline#check_mode()
  376   0.051125   0.021569  airline#highlighter#get_highlight()
   12   0.050628   0.007539  274()
    1   0.049585   0.000038  170()
    1   0.049521   0.000049  178()
    5   0.049369   0.000292  nerdtree#exec()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
    2  14.156340  14.155607  classpath#detect()
    1              0.030276  <SNR>92_DirenvExport()
  752              0.025939  <SNR>126_get_syn()
  376   0.051125   0.021569  airline#highlighter#get_highlight()
    1   0.017224   0.017209  ctrlp#utils#writecache()
  168   0.046576   0.014164  airline#highlighter#exec()
   12   0.050628   0.007539  274()
    3   0.048391   0.006982  <SNR>19_LoadFTPlugin()
    2   0.048862   0.006179  airline#highlighter#highlight()
    1  14.343760   0.005107  16()
    2   0.017232   0.004814  <SNR>3_SynSet()
   60              0.004225  <SNR>147_map()
  376              0.003616  <SNR>126_get_array()
   58              0.003548  <SNR>130_get_accented_line()
    2              0.003276  <SNR>148_detect()
  168              0.003273  <SNR>126_CheckDefined()
    4              0.003005  rainbow_parentheses#load()
  336              0.002962  <SNR>126_Get()
   28   0.014647   0.002874  <SNR>7_source()
   64   0.035279   0.002846  <SNR>126_exec_separator()

